<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="version" content="0.11"/>
  <meta name="subject" content="build system"/>
  <meta name="title" content="Build System"/>

  <title>The build2 Build System</title>

  <style type="text/css">
/* file      : common.css
 * copyright : Copyright (c) 2014-2019 Code Synthesis Ltd
 * license   : MIT; see accompanying LICENSE file
 */

html
{
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-weight: normal;
  font-size: 18px;
  line-height: 1.4em;
  letter-spacing: 0.01em;

  color: #292929;
}

body {margin: 0;} /* There is non-0 default margin for body. */

/* See notes on what's going on here. */
body {min-width: 17em;}
@media only screen and (min-width: 360px)
{
  body {min-width: 19em;}
}

/*
 * Header (optional).
 */

#header-bar
{
  width: 100%;

  background: rgba(0, 0, 0, 0.04);
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);

  padding: .4em 0 .42em 0;
  margin: 0 0 1.4em 0;
}

#header
{
  /* Same as in #content. */
  max-width: 41em;
  margin: 0 auto 0 auto;
  padding: 0 .4em 0 .4em;

  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;

  width: 100%;
  display: table;
  border: none;
  border-collapse: collapse;
}

#header-logo, #header-menu
{
  display: table-cell;
  border: none;
  padding: 0;
  vertical-align: middle;
}

#header-logo {text-align: left;}
#header-menu {text-align: right;}

/* These overlap with #header's margin because of border collapsing. */
#header-logo {padding-left: .4em;}
#header-menu {padding-right: .4em;}

#header-logo a
{
  color: #000;
  text-decoration: none;
  outline: none;
}
#header-logo a:visited {color: #000;}
#header-logo a:hover, #header-logo a:active {color: #000;}

#header-menu a
{
  font-size: 0.889em;
  line-height: 1.4em;
  text-align: right;
  margin-left: 1.2em;
  white-space: nowrap;
  letter-spacing: 0;
}

#header-menu a
{
  color: #000;
  outline: none;
}
#header-menu a:visited {color: #000;}
#header-menu a:hover, #header-menu a:active
{
  color: #3870c0;
  text-decoration: none;
}

/* Flexbox-based improvements though the above works reasonably well. */
#header-menu-body
{
  width: 100%;

  display: -webkit-inline-flex;
  display: inline-flex;

  -webkit-flex-flow: row wrap;
  flex-flow: row wrap;

  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

/* Whether we want it (and at which point) depends on the size of the menu. */
/*
@media only screen and (max-width: 567px)
{
  #header-menu-body
  {
    -webkit-flex-direction: column;
    flex-direction: column;
  }
}
*/

/*
 * Content.
 */

#content
{
  max-width: 41em;
  margin: 0 auto 0 auto;
  padding: 0 .4em 0 .4em; /* Space between text and browser frame. */

  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

/*
 * Footer (optional).
 */

#footer
{
  color: #767676;
  font-size: 0.7223em;
  line-height: 1.3em;
  margin: 2.2em 0 1em 0;
  text-align: center;
}

#footer a
{
  color: #767676;
  text-decoration: underline;
}
#footer a:visited {color: #767676;}
#footer a:hover, #footer a:active {color: #3870c0;}

/* Screen size indicator in the footer. The before/after content is in case
   we don't have any content in the footer. Margin is to actually see the
   border separate from the browser frame. */

/*
#footer:before {content: "\A0";}
#footer:after {content: "\A0";}

#footer
{
  border-left: 1px solid;
  border-right: 1px solid;
  margin-left: 1px;
  margin-right: 1px;
}

@media only screen and (max-width: 359px)
{
  #footer {border-color: red;}
}

@media only screen and (min-width: 360px) and (max-width: 567px)
{
  #footer {border-color: orange;}
}

@media only screen and (min-width: 568px) and (max-width: 1023px)
{
  #footer {border-color: blue;}
}

@media only screen and (min-width: 1024px)
{
  #footer {border-color: green;}
}
*/

/*
 * Common elements.
 */

p, li, dd {text-align: justify;}
.code {text-align: left;} /* Manually aligned. */
pre {text-align: left;}   /* If it is inside li/dd. */

/* Notes. */

.note
{
  color: #606060;
}

div.note
{
  margin: 2em 0 2em 0; /* The same top/bottom margings as pre box. */

  padding-left: 0.5em;
  border: 0.25em;
  border-left-style: solid;
  border-color: #808080;

  page-break-inside: avoid;
}

div.note :first-child {margin-top:    0;}
div.note :last-child  {margin-bottom: 0;}

span.note::before {content: "[Note: "}
span.note::after  {content: "]"}

/* Links. */
a
{
  color: #3870c0;
  /*color: #4078c0;*/
  text-decoration: none;
}

a:hover, a:active
{
/*color: #006fbf;*/
/*color: #0087e7;*/
  text-decoration: underline;
}

a:visited
{
/*color: #003388;*/
  color: #00409c;
}

/* Standard paragraph. */

p, pre {margin: 1em 0 1em 0;}

/* Standard lists. */
ul, ol, dl {margin: 1em 0 1em 0;}
ul li, ol li {margin: 0 0 .4em 0;}
ul li {list-style-type: circle;}
dl dt {margin: 0 0 0 0;}
dl dd {margin: 0 0 .6em 1.8em;}

code, pre
{
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 0.92em;
  letter-spacing: 0;
}

pre {white-space: pre-wrap;}

@media only screen and (max-width: 567px)
{
  pre {word-break: break-all;}
}

/* Use page rather than system font settings. */
input
{
  font-family: inherit;
  font-weight: inherit;
  font-size:   inherit;
  line-height: inherit;
}

/* file      : pre-box.css
 * copyright : Copyright (c) 2014-2019 Code Synthesis Ltd
 * license   : MIT; see accompanying LICENSE file
 */

pre
{
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 0.2em;
  padding: .8em .4em .8em .4em;
  margin: 2em -.4em 2em -.4em; /* Use margins of #content. */
}

/* file      : code-box.css
 * copyright : Copyright (c) 2014-2019 Code Synthesis Ltd
 * license   : MIT; see accompanying LICENSE file
 */

code
{
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 0.2em;
  padding: .2em .32em .18em .32em;
}

/*
code::before
{
  letter-spacing: -0.2em;
  content: "\00a0";
}

code::after
{
  letter-spacing: -0.2em;
  content: "\00a0";
}
*/

/* file      : toc.css
 * copyright : Copyright (c) 2014-2019 Code Synthesis Ltd
 * license   : MIT; see accompanying LICENSE file
 */

table.toc
{
  border-style      : none;
  border-collapse   : separate;
  border-spacing    : 0;

  margin            : 0.2em 0 0.2em 0;
  padding           : 0 0 0 0;
}

table.toc tr
{
  padding           : 0 0 0 0;
  margin            : 0 0 0 0;
}

table.toc * td, table.toc * th {
  border-style      : none;
  margin            : 0 0 0 0;
  vertical-align    : top;
}

table.toc * th
{
  font-weight       : normal;
  padding           : 0 0.8em 0 0;
  text-align        : left;
  white-space       : nowrap;
}

table.toc * table.toc th
{
  padding-left      : 1em;
}

table.toc * td
{
  padding           : 0 0 0 0;
  text-align        : left;
}

table.toc * td.preface
{
  padding-left      : 1.35em;
}

/* file      : intro.css
 * copyright : Copyright (c) 2014-2019 Code Synthesis Ltd
 * license   : MIT; see accompanying LICENSE file
 */

/* Bases:
 *
 * common.css
 * pre-box.css
 * code-box.css
 *
 */

#content
{
  max-width: 43.6em;
  padding-left: 3em; /* Reserve for headings. */
}

h1
{
  font-weight: normal;
  font-size: 2em;
  line-height: 1.4em;
  margin: 1.6em 0 .6em -1.4em;
}

h1.preface
{
  margin-left: -.56em;
}

h2
{
  font-weight: normal;
  font-size: 1.556em;
  line-height: 1.4em;
  margin: 1.6em 0 .6em -.8em;
}

h3
{
  font-weight: normal;
  font-size: 1.3em;
  line-height: 1.4em;
  margin: 1.6em 0 .6em -.2em;
}

/* Title page */

#titlepage {
  margin: 0 0 4em 0;
  border-bottom: 1px solid black;
}

#titlepage .title {
  font-weight: normal;
  font-size: 2.333em;
  line-height: 1.4em;
  letter-spacing: 0;
  text-align: center;
  margin: 2em 0 2em 0;
}

#titlepage p {
  font-size: 0.889em;
  line-height: 1.4em;
  margin: 2em 0 .6em 0;
}

  </style>

</head>
<body>
<div id="content">

  <div class="noprint"> <!-- Exclude from html2ps. -->

  <div id="titlepage">
    <div class="title">The <code>build2</code> Build System</div>

    <p id="revision">Revision <code>0.11</code>, June 2019<br/>
    This revision of the document describes the <a href="https://build2.org"><code>build2</code></a>
    build system <code>0.11.X</code> series and is available in the
    following formats:
    <a href="build2-build-system-manual.xhtml">XHTML</a>,
    <a href="build2-build-system-manual-a4.pdf">PDF/A4</a>,
    <a href="build2-build-system-manual-letter.pdf">PDF/Letter</a>,
    <a href="build2-build-system-manual-a4.ps">PostScript/A4</a>, and
    <a href="build2-build-system-manual-letter.ps">PostScript/Letter</a>.</p>

    <p>Copyright &#169; 2014-2019 <a href="https://codesynthesis.com">Code
    Synthesis Ltd</a><br/>
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the MIT License.</p>
  </div>

  <h1>Table of Contents</h1>

  <table class="toc">
    <tr><td class="preface" colspan="2"><a
href="#preface">Preface</a></td></tr>
    <tr><th>1</th><td><a href="#intro">Introduction</a>
      <table class="toc">
        <tr><th>1.1</th><td><a href="#intro-hello">Hello, World</a></td></tr>
        <tr><th>1.2</th><td><a href="#intro-proj-struct">Project
Structure</a></td></tr>
        <tr><th>1.3</th><td><a href="#intro-dirs-scopes">Output Directories
and Scopes</a></td></tr>
        <tr><th>1.4</th><td><a href="#intro-operations">Operations</a>
          <table class="toc">
            <tr><th>1.4.1</th><td><a
href="#intro-operations-config">Configuration</a></td></tr>
            <tr><th>1.4.2</th><td><a
href="#intro-operations-test">Testing</a></td></tr>
            <tr><th>1.4.3</th><td><a
href="#intro-operations-install">Installation</a></td></tr>
            <tr><th>1.4.4</th><td><a
href="#intro-operations-dist">Distribution</a></td></tr>
          </table>
        </td></tr>
        <tr><th>1.5</th><td><a href="#intro-import">Target
Importation</a></td></tr>
        <tr><th>1.6</th><td><a href="#intro-lib">Library Exportation and
Versioning</a></td></tr>
        <tr><th>1.7</th><td><a href="#intro-subproj">Subprojects and
Amalgamations</a></td></tr>
        <tr><th>1.8</th><td><a href="#intro-lang">Buildfile Language</a>
          <table class="toc">
            <tr><th>1.8.1</th><td><a href="#intro-lang-expand">Expansion and
Quoting</a></td></tr>
            <tr><th>1.8.2</th><td><a href="#intro-if-else">Conditions
(<code>if-else</code>)</a></td></tr>
            <tr><th>1.8.3</th><td><a href="#intro-fir">Repetitions
(<code>for</code>)</a></td></tr>
          </table>
        </td></tr>
        <tr><th>1.9</th><td><a href="#intro-unit-test">Implementing Unit
Testing</a></td></tr>
        <tr><th>1.10</th><td><a href="#intro-diag-debug">Diagnostics and
Debugging</a></td></tr>
      </table>
    </td></tr>
    <tr><th>2</th><td><a href="#name-patterns">Name Patterns</a></td></tr>
    <tr><th>3</th><td><a href="#variables">Variables</a></td></tr>
    <tr><th>4</th><td><a href="#module-test"><code>test</code>
Module</a></td></tr>
    <tr><th>5</th><td><a href="#module-version"><code>version</code>
Module</a></td></tr>
    <tr><th>6</th><td><a href="#module-bin"><code>bin</code>
Module</a></td></tr>
    <tr><th>7</th><td><a href="#module-cxx"><code>cxx</code> Module</a>
      <table class="toc">
        <tr><th>7.1</th><td><a href="#cxx-modules">C++ Modules Support</a>
          <table class="toc">
            <tr><th>7.1.1</th><td><a href="#cxx-modules-intro">Modules
Introduction</a></td></tr>
            <tr><th>7.1.2</th><td><a href="#cxx-modules-build">Building
Modules</a></td></tr>
            <tr><th>7.1.3</th><td><a href="#cxx-modules-symexport">Module
Symbols Exporting</a></td></tr>
            <tr><th>7.1.4</th><td><a href="#cxx-modules-install">Modules
Installation</a></td></tr>
            <tr><th>7.1.5</th><td><a href="#cxx-modules-guidelines">Modules
Design Guidelines</a></td></tr>
            <tr><th>7.1.6</th><td><a href="#cxx-modules-existing">Modularizing
Existing Code</a></td></tr>
          </table>
        </td></tr>
      </table>
    </td></tr>
    <tr><th>8</th><td><a href="#module-in"><code>in</code>
Module</a></td></tr>
    <tr><th>9</th><td><a href="#module-bash"><code>bash</code> Module</a></td></tr>
  </table>

  </div> <!-- noprint -->
  <h1 id="preface" class="preface">Preface</h1>

  <p>This document describes the <code>build2</code> build system. For the
  build system driver command line interface refer to the <a
  href="b.xhtml"><code><b>b(1)</b></code></a> man pages. For other tools in
  the <code>build2</code> toolchain (package and project managers, etc) see
  the <a href="https://build2.org/doc.xhtml">Documentation</a> index.</p>

  <h1 id="intro">1 Introduction</h1>

  <p>The <code>build2</code> build system is a native, cross-platform build
  system with a terse, mostly declarative description language, a conceptual
  model of build, and a uniform interface with consistent behavior across
  platforms and compilers.</p>

  <p>Those familiar with <code>make</code> will see many similarities, though
  mostly conceptual rather than syntactic. This is not by accident since
  <code>build2</code> borrows the fundamental DAG-based build model from
  original <code>make</code> and many of its conceptual extensions from GNU
  <code>make</code>. We believe, paraphrasing a famous quote, that <i>those
  who do not understand <code>make</code> are condemned to reinvent it,
  poorly.</i> So our goal with <code>build2</code> was to reinvent
  <code>make</code> <i>well</i> while handling the demands and complexity of
  modern cross-platform software development.</p>

  <p>Like <code>make</code>, <code>build2</code> is an <i>"honest"</i> build
  system without magic or black boxes. You can expect to understand what's
  going on underneath and be able to customize most of its behavior to suit
  your needs. This is not to say that it's not an <i>opinionated</i> build
  system and if you find yourself "fighting" some of its fundamental design
  choices, it would probably be wiser to look for alternatives.</p>

  <p>We believe the importance and complexity of the problem warranted the
  design of a new purpose-built language and will hopefully justify the time
  it takes for you to master it. In the end we hope <code>build2</code> will
  make creating and maintaining build infrastructure for your projects a
  pleasant task.</p>

  <p>Also note that <code>build2</code> is not specific to C/C++ or even to
  compiled languages; its build model is general enough to handle any
  DAG-based operations. See the <a href="#module-bash"><code>bash</code>
  Module</a> for a good example.</p>

  <p>While the build system is part of a larger, well-integrated build
  toolchain that includes the package and project dependency managers, it does
  not depend on them and its standalone usage is the only subject of this
  manual.</p>

  <p>We begin with a tutorial introduction that aims to show the essential
  elements of the build system on real examples but without getting into too
  much detail. Specifically, we want to quickly get to the point where we can
  build useful executable and library projects.</p>

  <h2 id="intro-hello">1.1 Hello, World</h2>

  <p>Let's start with the customary <i>"Hello, World"</i> example: a single
  source file from which we would like to build an executable:</p>

  <pre>$ tree hello/
hello/
└── hello.cxx

$ cat hello/hello.cxx

#include &lt;iostream>

int main ()
{
  std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
}</pre>

  <p>While this very basic program hardly resembles what most software
  projects look like today, it is useful for introducing key build system
  concepts without getting overwhelmed. In this spirit we will also use the
  <code>build2</code> <i>simple project</i> structure, which, similarly,
  should not be used for anything but quick sketches.</p>

  <p>To turn our <code>hello/</code> directory into a simple project all we
  need to do is add a <code>buildfile</code>:</p>

  <pre>$ tree hello/
hello/
├── hello.cxx
└── buildfile

$ cat hello/buildfile

using cxx

exe{hello}: cxx{hello.cxx}</pre>

  <p>Let's start from the bottom: the second line is a <i>dependency
  declaration</i>. On the left hand side of <code>:</code> we have a
  <i>target</i>, the <code>hello</code> executable, and on the right hand side
  &#8211; a <i>prerequisite</i>, the <code>hello.cxx</code> source file. Those
  <code>exe</code> and <code>cxx</code> in <code>exe{...}</code> and
  <code>cxx{...}</code> are called <i>target types</i>. In fact, for clarity,
  target type names are always mentioned with trailing <code>{}</code>, for
  example, "the <code>exe{}</code> target type denotes an executable".</p>

  <p>Notice that the dependency declaration does not specify <i>how</i> to
  build an executable from a C++ source file &#8211; this is the job of a
  <i>rule</i>. When the build system needs to update a target, it tries to
  <i>match</i> a suitable rule based on the types of the target and its
  prerequisites. The <code>build2</code> core has a number of predefined
  fundamental rules with the rest coming from <i>build system modules</i>. For
  example, the <code>cxx</code> module defines a number of rules for compiling
  C++ source code as well as linking executables and libraries.</p>

  <p>It should now be easy to guess what the first line of our
  <code>buildfile</code> does: it loads the <code>cxx</code> module which
  defines the rules necessary to build our program (it also registers the
  <code>cxx{}</code> target type).</p>

  <p>Let's now try to build and run our program (<code>b</code> is the build
  system driver):</p>

  <pre>$ cd hello/  # Change to project root.

$ b
c++ cxx{hello}
ld exe{hello}

$ ls -1
buildfile
hello.cxx
hello
hello.d
hello.o
hello.o.d

$ ./hello
Hello, World!</pre>

  <p>Or, if we are on Windows and using Visual Studio, from the Visual Studio
  development command prompt:</p>

  <pre>> cd hello

> b
c++ cxx{hello}
ld exe{hello}

> dir /b
buildfile
hello.cxx
hello.exe
hello.exe.d
hello.exe.obj
hello.exe.obj.d

> .\hello.exe
Hello, World!</pre>

  <p>By default <code>build2</code> uses the same C++ compiler it was built
  with and without passing any extra options, such as debug or optimization.
  To change these defaults we use <i>configuration variables</i>. For example,
  to specify a different C++ compiler we use <code>config.cxx</code>:</p>

  <pre>$ b config.cxx=clang++</pre>

  <p>And for additional compile options, such as debug information or
  optimization level, there is <code>config.cxx.coptions</code>. For
  example:</p>

  <pre>$ b config.cxx=clang++ config.cxx.coptions=-g</pre>

  <div class="note">
  <p>These and other configuration variables will be discussed in more detail
  later. We will also learn how to make our configuration persistent so that
  we don't have to repeat such long command lines on every build system
  invocation.</p>

  <p>Similar to <code>config.cxx</code>, there is also <code>config.c</code>
  for specifying the C compiler. Note, however, that if your project uses both
  C and C++, then you normally only need to specify one of them &#8211;
  <code>build2</code> will determine the other automatically.</p>
  </div>

  <p>Let's discuss a few points about the build output. Firstly, to reduce the
  noise, the commands being executed are by default shown abbreviated and with
  the same target type notation as we used in the <code>buildfile</code>. For
  example:</p>

  <pre>c++ cxx{hello}
ld exe{hello}</pre>

  <p>If, however, you would like to see the actual command lines, you can pass
  <code>-v</code> (to see even more, there is the <code>-V</code> as well as
  <code>--verbose</code> options; see <a
  href="b.xhtml"><code><b>b(1)</b></code></a> for details). For example:</p>

  <pre>$ b -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o</pre>

  <p>Most of the files produced by the build system should be
  self-explanatory: we have the object file (<code>hello.o</code>,
  <code>hello.obj</code>) and executable (<code>hello</code>,
  <code>hello.exe</code>). For each of them we also have the corresponding
  <code>.d</code> files which store the <i>auxiliary dependency
  information</i>, things like compile options, header dependencies, etc.</p>

  <p>To remove the build system output we use the <code>clean</code>
  <i>operation</i> (if no operation is specified, the default is
  <code>update</code>):</p>

  <pre>$ b clean
rm exe{hello}
rm obje{hello}

$ ls -1
buildfile
hello.cxx</pre>

  <p>One of the main reasons behind the <i>target type</i> concept is the
  platform/compiler-specified variances in file names as illustrated by the
  above listings. In our <code>buildfile</code> we refer to the executable
  target as <code>exe{hello}</code>, not as <code>hello.exe</code> or
  <code>hello$EXT</code>. The actual file extension, if any, will be
  determined based on the compiler's target platform by the rule doing the
  linking. In this sense, target types are a platform-independent replacement
  of file extensions (though they do have other benefits, such as allowing
  non-file targets as well as being hierarchical).</p>

  <p>Let's revisit the dependency declaration line from our
  <code>buildfile</code>:</p>

  <pre>exe{hello}: cxx{hello.cxx}</pre>

  <p>In light of target types replacing file extensions this looks
  tautological: why do we need to specify both the <code>cxx{}</code> target
  type <i>and</i> the <code>.cxx</code> file extension? In fact, we don't have
  to if we specify the default file extension for the <code>cxx{}</code>
  target type. Here is our updated <code>buildfile</code> in its entirety:</p>

  <pre>using cxx

cxx{*}: extension = cxx

exe{hello}: cxx{hello}</pre>

  <p>Let's unpack the new line. What we have here is a <i>target
  type/pattern-specific variable</i>. It only applies to targets of the
  <code>cxx{}</code> type whose names match the <code>*</code> wildcard
  pattern. The <code>extension</code> variable name is reserved by the
  <code>build2</code> core for specifying target type extensions.</p>

  <p>Let's see how all these pieces fit together. When the build system needs
  to update <code>exe{hello}</code>, it searches for a suitable rule. A rule
  from the <code>cxx</code> module matches since it knows how to build a
  target of type <code>exe{}</code> from a prerequisite of type
  <code>cxx{}</code>. When the matched rule is <i>applied</i>, it searches for
  a target for the <code>cxx{hello}</code> prerequisite. During this search,
  the <code>extension</code> variable is looked up and its value is used to
  end up with the <code>hello.cxx</code> file.</p>

  <p>Here is our new dependency declaration again:</p>

  <pre>exe{hello}: cxx{hello}</pre>

  <p>It has the canonical form: no extensions, only target types. Sometimes
  explicit extension specification is still necessary, for example, if your
  project uses multiple extensions for the same file type. But if unnecessary,
  it should be omitted for brevity.</p>

  <div class="note">
  <p>If you prefer the <code>.cpp</code> file extension and your source file
  is called <code>hello.cpp</code>, then the only line in our
  <code>buildfile</code> that needs changing is the <code>extension</code>
  variable assignment:</p>

  <pre>cxx{*}: extension = cpp</pre>
  </div>

  <p>Let's say our <code>hello</code> program got complicated enough to
  warrant moving some functionality into a separate source/header module (or a
  real C++ module). For example:</p>

  <pre>$ tree hello/
hello/
├── hello.cxx
├── utility.hxx
├── utility.cxx
└── buildfile</pre>

  <p>This is what our updated <code>buildfile</code> could look like:</p>

  <pre>using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx

exe{hello}: cxx{hello} hxx{utility} cxx{utility}</pre>

  <p>Nothing really new here: we've specified the default extension for the
  <code>hxx{}</code> target type and listed the new header and source files as
  prerequisites. If you have experience with other build systems, then
  explicitly listing headers might seem strange to you. As will be discussed
  later, in <code>build2</code> we have to explicitly list all the
  prerequisites of a target that should end up in a distribution of our
  project.</p>

  <div class="note">
  <p>You don't have to list <i>all</i> headers that you include, only the ones
  belonging to your project. Like all modern C/C++ build systems,
  <code>build2</code> performs automatic header dependency extraction.</p>
  </div>

  <p>In real projects with a substantial number of source files, repeating
  target types and names will quickly become noisy. To tidy things up we can
  use <i>name generation</i>. Here are a few examples of dependency
  declarations equivalent to the above:</p>

  <pre>exe{hello}: cxx{hello utility} hxx{utility}
exe{hello}: cxx{hello} {hxx cxx}{utility}</pre>

  <p>The last form is probably the best choice if your project contains a
  large number of header/source pairs. Here is a more realistic example:</p>

  <pre>exe{hello}: {    cxx}{hello}               \
            {hxx    }{forward types}       \
            {hxx cxx}{format print utility}</pre>

  <p>Manually listing a prerequisite every time we add a new source file to
  our project is both tedious and error prone. Instead, we can automate our
  dependency declarations with <i>wildcard name patterns</i>. For example:</p>

  <pre>exe{hello}: {hxx cxx}{*}</pre>

  <p>Based on the previous discussion of default extensions, you can probably
  guess how this works: for each target type the value of the
  <code>extension</code> variable is added to the pattern and files matching
  the result become prerequisites. So, in our case, we will end up with files
  matching the <code>*.hxx</code> and <code>*.cxx</code> wildcard
  patterns.</p>

  <p>In more complex projects it is often convenient to organize source code
  into subdirectories. To handle such projects we can use the recursive
  wildcard:</p>

  <pre>exe{hello}: {hxx cxx}{**}</pre>

  <div class="note">
  <p>Using wildcards is somewhat controversial. Patterns definitely make
  development more pleasant and less error prone: you don't need to update
  your <code>buildfile</code> every time you add, remove, or rename a source
  file and you won't forget to explicitly list headers, a mistake that is
  often only detected when trying to build a distribution of a project. On the
  other hand, there is the possibility of including stray source files into
  your build without noticing. And, for more complex projects, name patterns
  can become fairly complex (see <a href="#name-patterns">Name Patterns</a>
  for details). Note also that on modern hardware the performance of wildcard
  searches hardly warrants a consideration.</p>

  <p>In our experience, when combined with modern version control systems like
  <code>git(1)</code>, stray source files are rarely an issue and generally
  the benefits of wildcards outweigh their drawbacks. But, in the end, whether
  to use them or not is a personal choice and, as shown above,
  <code>build2</code> supports both approaches.</p>
  </div>

  <p>And that's about all there is to our <code>hello</code> example. To
  summarize, we've seen that to build a simple project we need a single
  <code>buildfile</code> which itself doesn't contain much more than a
  dependency declaration for what we want to build. But we've also mentioned
  that simple projects are only really meant for quick sketches. So let's
  convert our <code>hello</code> example to the <i>standard project</i>
  structure which is what we will be using for most of our real
  development.</p>

  <div class="note">
  <p>Simple projects have so many restrictions and limitations that they are
  hardly usable for anything but, well, <i>really</i> simple projects.
  Specifically, such projects cannot be imported by other projects nor can
  they use build system modules that require bootstrapping. This includes
  <code>test</code>, <code>install</code>, <code>dist</code>, and
  <code>config</code> modules. And without the <code>config</code> module
  there is no support for persistent configurations. As a result, you should
  only use a simple project if you are happy to always build in the source
  directory and with the default build configuration or willing to specify the
  output directory and/or custom configuration on every invocation.</p>
  </div>

  <h2 id="intro-proj-struct">1.2 Project Structure</h2>

  <p>A <code>build2</code> <i>standard project</i> has the following overall
  layout:</p>

  <pre>hello/
├── build/
│   ├── bootstrap.build
│   └── root.build
├── ...
└── buildfile</pre>

  <p>Specifically, the project's root directory should contain the
  <code>build/</code> subdirectory as well as the root <code>buildfile</code>.
  The <code>build/</code> subdirectory contains project-wide build system
  information.</p>

  <div class="note">
  <p>The <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a>
  command is an easy way to create the standard layout executable
  (<code>-t&#160;exe</code>) and library (<code>-t&#160;lib</code>) projects.
  To change the C++ file extensions to <code>.hpp/.cpp</code>, pass <code>-l
  c++,cpp</code>. For example:</p>

  <pre>$ bdep new --no-init -t exe -l c++,cpp hello</pre>
  </div>

  <div class="note">
  <p>It is also possible to use an alternative build file/directory naming
  scheme where every instance of the word <i>build</i> is replaced with
  <i>build2</i>, for example:</p>

  <pre>hello/
├── build2/
│   ├── bootstrap.build2
│   └── root.build2
├── ...
└── build2file</pre>

  <p>Note that the naming must be consistent within a project with all the
  filesystem entries either following <i>build</i> or <i>build2</i> scheme. In
  other words, we cannot call the directory <code>build2/</code> while still
  using <code>buildfile</code>.</p>

  <p>The alternative naming scheme is primarily useful when adding
  <code>build2</code> support to an existing project along with other build
  systems. In this case, the fairly generic standard names might already be in
  use. For example, it is customary to have <code>build/</code> in
  <code>.gitignore</code>. Plus more specific naming will make it easier to
  identify files and directories as belonging to the <code>build2</code>
  support. For new projects as well as for existing projects that are
  switching exclusively to <code>build2</code> the standard naming scheme is
  recommended.</p>

  <p>To create a project with the alternative naming using <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a>
  pass the <code>alt-naming</code> project type sub-option. For example:</p>

  <pre>$ bdep new -t exe,alt-naming ...</pre>
  </div>

  <p>To support lazy loading of subprojects (discussed later), reading of the
  project's build information is split into two phases: bootstrapping and
  loading. During bootstrapping the project's
  <code>build/bootstrap.build</code> file is read. Then, when (and if) the
  project is loaded completely, its <code>build/root.build</code> file is read
  followed by the <code>buildfile</code> (normally from the project root but
  possibly from a subdirectory).</p>

  <p>The <code>bootstrap.build</code> file is required. Let's see what it
  would look like for a typical project using our <code>hello</code> as an
  example:</p>

  <pre>project = hello

using version
using config
using test
using install
using dist</pre>

  <p>The first non-comment line in <code>bootstrap.build</code> should be the
  assignment of the project name to the <code>project</code> variable. After
  that, a typical <code>bootstrap.build</code> file loads a number of build
  system modules. While most modules can be loaded during the project load
  phase in <code>root.build</code>, certain modules have to be loaded early,
  while bootstrapping (for example, because they define new operations).</p>

  <p>Let's examine briefly the modules loaded by our
  <code>bootstrap.build</code>: The <a
  href="#module-version"><code>version</code></a> module helps with managing
  our project versioning. With this module we only maintain the version in a
  single place (project's <code>manifest</code> file) and it is automatically
  made available in various convenient forms throughout our project
  (<code>buildfiles</code>, header files, etc). The <code>version</code>
  module also automates versioning of snapshots between releases.</p>

  <p>The <code>manifest</code> file is what makes our build system project a
  <i>package</i>. It contains all the metadata that a user of a package might
  need to know: name, version, dependencies, etc., all in one place. However,
  even if you don't plan to package your project, it is a good idea to create
  a basic <code>manifest</code> if only to take advantage of the version
  management offered by the <code>version</code> module. So let's go ahead and
  add it next to our root <code>buildfile</code>:</p>

  <pre>$ tree hello/
hello/
├── build/
│   └── ...
├── ...
├── buildfile
└── manifest

$ cat hello/manifest
: 1
name: hello
version: 0.1.0
summary: hello C++ executable</pre>

  <p>The <code>config</code> module provides support for persistent
  configurations. While project configuration is a large topic that we will
  discuss in detail later, in a nutshell <code>build2</code> support for
  configuration is an integral part of the build system with the same
  mechanisms available to the build system core, modules, and your projects.
  However, without <code>config</code>, the configuration information is
  <i>transient</i>. That is, whatever configuration information was
  automatically discovered or that you have supplied on the command line is
  discarded after each build system invocation. With the <code>config</code>
  module, however, we can <i>configure</i> a project to make the configuration
  <i>persistent</i>. We will see an example of this shortly.</p>

  <p>Next up are the <code>test</code>, <code>install</code>, and
  <code>dist</code> modules. As their names suggest, they provide support for
  testing, installation and preparation of distributions. Specifically, the
  <code>test</code> module defines the <code>test</code> operation, the
  <code>install</code> module defines the <code>install</code> and
  <code>uninstall</code> operations, and the <code>dist</code> module defines
  the <code>dist</code> (meta-)operation. Again, we will try them out in a
  moment.</p>

  <p>Moving on, the <code>root.build</code> file is optional though most
  projects will have it. This is the place where we normally establish
  project-wide settings as well as load build system modules that provide
  support for the languages/tools that we use. Here is what it could look like
  for our <code>hello</code> example:</p>

  <pre>cxx.std = latest

using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx</pre>

  <p>As you can see, we've moved the loading of the <code>cxx</code> modules
  and setting of the default file extensions from the root
  <code>buildfile</code> in our simple project to <code>root.build</code> when
  using the standard layout. We've also set the <code>cxx.std</code> variable
  to tell the <code>cxx</code> module to select the latest C++ standard
  available in any particular C++ compiler this project might be built
  with.</p>

  <div class="note">
  <p>Selecting the C++ standard for our project is a messy issue. If we don't
  specify the standard explicitly with <code>cxx.std</code>, then the default
  standard in each compiler will be used, which, currently, can range from
  C++98 to C++14. So unless you carefully write your code to work with any
  standard, this is probably not a good idea.</p>

  <p>Fixing the standard (for example, to <code>c++11</code>,
  <code>c++14</code>, etc) should work theoretically. In practice, however,
  compilers add support for new standards incrementally and many versions,
  while perfectly usable, are not feature-complete. As a result, a better
  practical strategy is to specify the set of minimum supported compiler
  versions rather than the C++ standard.</p>

  <p>There is also the issue of using libraries that require newer standard in
  older code. For example, headers from a library that relies on C++14
  features will not compile when included in a project that is built as C++11.
   And, even if the headers compile (that is, C++14 features are only used in
  the implementation), strictly speaking, there is no guarantee that codebases
  compiled with different C++ standards are ABI compatible (in fact, some
  changes to the C++ language leave the implementations no choice but to break
  the ABI).</p>

  <p>As result, our recommendation is to set the standard to
  <code>latest</code> and specify the minimum supported compilers and versions
  in your project's documentation (see package manifest <a
  href="../../bpkg/doc/build2-package-manager-manual.xhtml#manifest-package-requires"><code>requires</code></a>
  value for one possible place). Practically, this should allow you to include
  and link any library, regardless of the C++ standard that it uses.</p>
  </div>

  <p>Let's now take a look at the root <code>buildfile</code>:</p>

  <pre>./: {*/ -build/}</pre>

  <p>In plain English, this <code>buildfile</code> declares that building this
  directory (and, since it's the root of our project, building this entire
  project) means building all its subdirectories excluding
  <code>build/</code>. Let's now try to understand how this is actually
  achieved.</p>

  <p>We already know this is a dependency declaration, <code>./</code> is the
  target, and what's after <code>:</code> are its prerequisites, which seem to
  be generated with some kind of a name pattern (the wildcard character in
  <code>*/</code> should be the giveaway). What's unusual about this
  declaration, however, is the lack of any target types plus that
  strange-looking <code>./</code>.</p>

  <p>Let's start with the missing target types. In fact, the above
  <code>buildfile</code> can be rewritten as:</p>

  <pre>dir{.}: dir{* -build}</pre>

  <p>So the trailing slash (always forward, even on Windows) is a special
  shorthand notation for <code>dir{}</code>. As we will see shortly, it fits
  naturally with other uses of directories in <code>buildfiles</code> (for
  example, in scopes).</p>

  <p>The <code>dir{}</code> target type is an <i>alias</i> (and, in fact, is
  derived from more general <code>alias{}</code>). Building it means building
  all its prerequisites.</p>

  <div class="note">
  <p>If you are familiar with <code>make</code>, then you can probably see the
  similarity with the ubiquitous <code>all</code> pseudo-target. In
  <code>build2</code> we instead use directory names as more natural aliases
  for the "build everything in this directory" semantics.</p>

  <p>Note also that <code>dir{}</code> is purely an alias and doesn't have
  anything to do with the filesystem. In particular, it does not create any
  directories. If you do want explicit directory creation (which should be
  rarely needed), use the <code>fsdir{</code>} target type instead.</p>
  </div>

  <p>The <code>./</code> target is a special <i>default target</i>. If we run
  the build system without specifying the target explicitly, then this target
  is built by default. Every <code>buildfile</code> has the <code>./</code>
  target. If we don't declare it explicitly, then its declaration is implied
  with the first target in the <code>buildfile</code> as its prerequisite.
  Recall our <code>buildfile</code> from the simple <code>hello</code>
  project:</p>

  <pre>exe{hello}: cxx{hello}</pre>

  <p>It is equivalent to:</p>

  <pre>./: exe{hello}
exe{hello}: cxx{hello}</pre>

  <p>If, however, we had several targets in the same directory that we wanted
  built by default, then we would need to explicitly list them as
  prerequisites of the default target. For example:</p>

  <pre>./: exe{hello}
exe{hello}: cxx{hello}

./: exe{goodby}
exe{goodby}: cxx{goodby}</pre>

  <p>While straightforward, this is somewhat inelegant in its repetitiveness.
  To tidy things up we can use <i>dependency declaration chains</i> that allow
  us to chain together several target-prerequisite declarations in a single
  line. For example:</p>

  <pre>./: exe{hello}: cxx{hello}

./: exe{goodby}: cxx{goodby}</pre>

  <p>With dependency chains a prerequisite of the preceding target becomes a
  target itself for the following prerequisites.</p>

  <p>Let's get back to our root <code>buildfile</code>:</p>

  <pre>./: {*/ -build/}</pre>

  <p>The last unexplained bit is the <code>{*/&#160;-build/}</code> name
  pattern. All it does is exclude <code>build/</code> from the subdirectories
  to build. See <a href="#name-patterns">Name Patterns</a> for details.</p>

  <p>Let's take a look at a slightly more realistic root
  <code>buildfile</code>:</p>

  <pre>./: {*/ -build/} doc{README.md LICENSE} manifest</pre>

  <p>Here we have the customary <code>README.md</code> and
  <code>LICENSE</code> files as well as the package <code>manifest</code>.
  Listing them as prerequisites achieves two things: they will be installed
  if/when our project is installed and, as mentioned earlier, they will be
  included into the project distribution.</p>

  <p>The <code>README.md</code> and <code>LICENSE</code> files use the
  <code>doc{}</code> target type. We could have used the generic
  <code>file{}</code> but using the more precise <code>doc{}</code> makes sure
  that they are installed into the appropriate documentation directory. The
  <code>manifest</code> file doesn't need an explicit target type since it has
  a fixed name (<code>manifest{manifest}</code> is valid but redundant).</p>

  <p>Standard project infrastructure in place, where should we put our source
  code? While we could have everything in the root directory of our project,
  just like we did with the simple layout, it is recommended to instead place
  the source code into a subdirectory named the same as the project. For
  example:</p>

  <pre>hello/
├── build/
│   └── ...
├── hello/
│   ├── hello.cxx
│   └── buildfile
├── buildfile
├── manifest
└── README.md</pre>

  <div class="note">
  <p>There are several reasons for this layout: It implements the canonical
  inclusion scheme where each header is prefixed with its project name. It
  also has a predictable name where users can expect to find our project's
  source code. Finally, this layout prevents clutter in the project's root
  directory which usually contains various other files. See <a
  href="../../build2-toolchain/doc/build2-toolchain-intro.xhtml#structure-canonical">Canonical
  Project Structure</a> for more information.</p>

  <p>Note also that while we can name our header and source files however we
  like (but, again, see <a
  href="../../build2-toolchain/doc/build2-toolchain-intro.xhtml#structure-canonical">Canonical
  Project Structure</a> for some sensible guidelines), C++ module interface
  files need to embed a sufficient amount of the module name suffix in their
  names to unambiguously resolve all the modules within a project. See <a
  href="#cxx-modules-build">Building Modules</a> for details.</p>
  </div>

  <p>The source subdirectory <code>buildfile</code> is identical to the simple
  project's minus the parts moved to <code>root.build</code>:</p>

  <pre>exe{hello}: {hxx cxx}{**}</pre>

  <p>Let's now build our project and see where the build system output ends up
  in this new layout:</p>

  <pre>$ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello}
ld hello/exe{hello}

$ tree ./
./
├── build/
│   └── ...
├── hello/
│   ├── hello.cxx
│   ├── hello
│   ├── hello.d
│   ├── hello.o
│   ├── hello.o.d
│   └── buildfile
├── buildfile
└── manifest

$ hello/hello
Hello, World!</pre>

  <p>If we don't specify a target to build (as we did above), then
  <code>build2</code> will build the current directory or, more precisely, the
  default target in the <code>buildfile</code> in the current directory. We
  can also build a directory other than the current, for example:</p>

  <pre>$ b hello/</pre>

  <div class="note">
  <p>Note that the trailing slash is required. In fact, <code>hello/</code> in
  the above command line is a target and is equivalent to
  <code>dir{hello}</code>, just like in the <code>buildfiles</code>.</p>
  </div>

  <p>Or we can build a specific target:</p>

  <pre>$ b hello/exe{hello}</pre>

  <p>Naturally, nothing prevents us from building multiple targets or even
  projects in the same build system invocation. For example, if we had the
  <code>libhello</code> project next to our <code>hello/</code>, then we could
  build both at once:</p>

  <pre>$ ls -1
hello/
libhello/

$ b hello/ libhello/</pre>

  <p>Speaking of libraries, let's see what the standard project structure
  looks like for one, using <code>libhello</code> created by <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a> as
  an example:</p>

  <pre>$ bdep new --no-init -t lib libhello

$ tree libhello/
libhello/
├── build/
│   ├── bootstrap.build
│   ├── root.build
│   └── export.build
├── libhello/
│   ├── hello.hxx
│   ├── hello.cxx
│   ├── export.hxx
│   ├── version.hxx.in
│   └── buildfile
├── tests/
│   └──  ...
├── buildfile
├── manifest
└── README.md</pre>

  <p>The overall layout (<code>build/</code>, <code>libhello/</code> source
  directory) as well as the contents of the root files
  (<code>bootstrap.build</code>, <code>root.build</code>, root
  <code>buildfile</code>) are exactly the same. There is, however, a new file,
  <code>export.build</code>, in <code>build/</code>, a new subdirectory,
  <code>tests/</code>, and the contents of the project's source subdirectory,
  <code>libhello/</code>, look quite a bit different. We will examine all of
  these differences in the coming sections, as we learn more about the build
  system.</p>

  <div class="note">
  <p>The standard project structure is not type (executable, library, etc) or
  even language specific. In fact, the same project can contain multiple
  executables and/or libraries (for example, both <code>hello</code> and
  <code>libhello</code>). However, if you plan to package your projects, it is
  a good idea to keep them as separate build system projects (they can still
  reside in the same version control repository, though).</p>

  <p>Speaking of projects, this term is unfortunately overloaded to mean two
  different things at different levels of software organization. At the bottom
  we have <i>build system projects</i> which, if packaged, become
  <i>packages</i>. And at the top, related packages are often grouped into
  what is also commonly referred to as <i>projects</i>. At this point both
  usages are probably too well established to look for alternatives.</p>
  </div>

  <p>And this completes the conversion of our simple <code>hello</code>
  project to the standard structure. Earlier, when examining
  <code>bootstrap.build</code>, we mentioned that modules loaded in this file
  usually provide additional operations. So we still need to discuss what
  exactly the term <i>build system operation</i> means and see how to use
  operations that are provided by the modules we have loaded. But before we do
  that, let's see how we can build our projects <i>out of source</i> tree and
  learn about another cornerstone <code>build2</code> concept:
  <i>scopes</i>.</p>

  <h2 id="intro-dirs-scopes">1.3 Output Directories and Scopes</h2>

  <p>Two common requirements placed on modern build systems are the ability to
  build projects out of the source directory tree (referred to as just <i>out
  of source</i> vs <i>in source</i>) as well as isolation of
  <code>buildfiles</code> from each other when it comes to target and variable
  names. In <code>build2</code> these mechanisms are closely-related, integral
  parts of the build system.</p>

  <div class="note">
  <p>This tight integration has advantages, like being always available and
  working well with other build system mechanisms, as well as disadvantages,
  like the inability to implement a completely different out of source
  arrangement and/or isolation model. In the end, if you find yourself
  "fighting" this aspect of <code>build2</code>, it will likely be easier to
  use a different build system than subvert it.</p>
  </div>

  <p>Let's start with an example of an out of source build for our
  <code>hello</code> project. To recap, this is what we have:</p>

  <pre>$ ls -1
hello/

$ tree hello/
hello/
├── build/
│   └── ...
├── hello/
│   └── ...
├── buildfile
└── manifest</pre>

  <p>To start, let's build it in the <code>hello-out/</code> directory next to
  the project:</p>

  <pre>$ b hello/@hello-out/
mkdir fsdir{hello-out/}
mkdir hello-out/fsdir{hello/}
c++ hello/hello/cxx{hello}@hello-out/hello/
ld hello-out/hello/exe{hello}

$ ls -1
hello/
hello-out/

$ tree hello-out/
hello-out/
└── hello/
    ├── hello
    ├── hello.d
    ├── hello.o
    └── hello.o.d</pre>

  <p>This definitely requires some explaining. Let's start from the bottom,
  with the <code>hello-out/</code> layout. It is <i>parallel</i> to the source
  directory. This mirrored side-by-side listing (of the relevant parts) should
  illustrate this clearly:</p>

  <pre>hello/             ~~>  hello-out/
└── hello/         ~~>  └── hello/
    └── hello.cxx  ~~>      └── hello.o</pre>

  <p>In fact, if we copy the contents of <code>hello-out/</code> over to
  <code>hello/</code>, we will end up with exactly the same result as in the
  in source build. And this is not accidental: an in source build is just a
  special case of an out of source build where the <i>out</i> directory is the
  same as <i>src</i>.</p>

  <div class="note">
  <p>In <code>build2</code> this parallel structure of the out and src
  directories is a cornerstone design decision and is non-negotiable, so to
  speak. In particular, out cannot be inside src. And while we can stash the
  build system output (object files, executables, etc) into (potentially
  different) subdirectories, this is not recommended. As will be shown later,
  <code>build2</code> offers better mechanisms to achieve the same benefits
  (like reduced clutter, ability to run executables) but without the drawbacks
  (like name clashes).</p>
  </div>

  <p>Let's now examine how we invoked the build system to achieve this out of
  source build. Specifically, if we were building in source, our command line
  would have been:</p>

  <pre>$ b hello/</pre>

  <p>but for the out of source build, we have:</p>

  <pre>$ b hello/@hello-out/</pre>

  <p>In fact, that strange-looking construct, <code>hello/@hello-out/</code>
  is just a more elaborate target specification that explicitly spells out the
  target's src and out directories. Let's add an explicit target type to make
  it clearer:</p>

  <pre>$ b hello/@hello-out/dir{.}</pre>

  <p>What we have on the right of <code>@</code> is the target in the out
  directory and on the left &#8211; its src directory. In plain English, this
  command line says "build me the default target from <code>hello/</code> in
  the <code>hello-out/</code> directory".</p>

  <p>As an example, if instead we wanted to build only the <code>hello</code>
  executable out of source, then the invocation would have looked like
  this:</p>

  <pre>$ b hello/hello/@hello-out/hello/exe{hello}</pre>

  <p>We could have also specified out for an in source build, but that's
  redundant:</p>

  <pre>$ b hello/@hello/</pre>

  <p>There is another example of this elaborate target specification in the
  build diagnostics:</p>

  <pre>c++ hello/hello/cxx{hello}@hello-out/hello/</pre>

  <p>Notice, however, that now the target (<code>cxx{hello}</code>) is on the
  left of <code>@</code>, that is, in the src directory. It does, however,
  make sense if you think about it: our <code>hello.cxx</code> is a <i>source
  file</i>, it is not built and it resides in the project's source directory.
  This is in contrast, for example, to the <code>exe{hello}</code> target
  which is the output of the build system and goes to the out directory. So in
  <code>build2</code> targets can be either in src or in out (there can also
  be <i>out of any project</i> targets, for example, installed files).</p>

  <p>The elaborate target specification can also be used in
  <code>buildfiles</code>. We haven't encountered any so far because targets
  mentioned without explicit src/out default to out and, naturally, most of
  the targets we mention in <code>buildfiles</code> are things we want built.
  One situation where you may encounter an src target mentioned explicitly is
  when specifying its installability (discussed in the next section). For
  example, if our project includes the customary <code>INSTALL</code> file, it
  probably doesn't make sense to install it. However, since it is a source
  file, we have to use the elaborate target specification when disabling its
  installation:</p>

  <pre>doc{INSTALL}@./: install = false</pre>

  <p>Note also that only targets and not prerequisites have this notion of
  src/out directories. In a sense, prerequisites are relative to the target
  they are prerequisites of and are resolved to targets in a manner that is
  specific to their target types. For <code>file{}</code>-based prerequisites
  the corresponding target in out is first looked up and if found used.
  Otherwise, an existing file in src is searched for and if found the
  corresponding target (now in src) is used. In particular, this semantics
  gives preference to generated code over static.</p>

  <div class="note">
  <p>More precisely, a prerequisite is relative to the scope (discussed below)
  in which the dependency is declared and not to the target that it is a
  prerequisite of. However, in most practical cases, this means the same
  thing.</p>
  </div>

  <p>And this pretty much covers out of source builds. Let's summarize the key
  points we have established so far: Every build has two parallel directory
  trees, src and out, with the in source build being just a special case where
  they are the same. Targets in a project can be either in the src or out
  directory though most of the time targets we mention in our
  <code>buildfiles</code> will be in out, which is the default. Prerequsites
  are relative to targets they are prerequisites of and
  <code>file{</code>}-based prerequisites are first searched for as declared
  targets in out and then as existing files in src.</p>

  <p>Note also that we can have as many out of source builds as we want and we
  can place them anywhere we want (but not inside src), say, on a RAM-backed
  disk/filesystem. As an example, let's build our <code>hello</code> project
  with two different compilers:</p>

  <pre>$ b hello/@hello-gcc/    config.cxx=g++
$ b hello/@hello-clang/  config.cxx=clang++</pre>

  <p>In the next section we will see how to permanently configure our out of
  source builds so that we don't have to keep repeating these long command
  lines.</p>

  <div class="note">
  <p>While technically you can have both in source and out of source builds at
  the same time, this is not recommended. While it may work for basic
  projects, as soon as you start using generated source code (which is fairly
  common in <code>build2</code>), it becomes difficult to predict where the
  compiler will pick generated headers. There is support for remapping
  mis-picked headers but this may not always work with older C/C++ compilers.
  Plus, as we will see in the next section, <code>build2</code> supports
  <i>forwarded configurations</i> which provide most of the benefits of an in
  source build but without the drawbacks.</p>
  </div>

  <p>Let's now turn to <code>buildfile</code> isolation. It is a common,
  well-established practice to organize complex software projects in directory
  hierarchies. One of the benefits of this organization is isolation: we can
  use the same, short file names in different subdirectories. In
  <code>build2</code> the project's directory tree is used as a basis for its
  <i>scope</i> hierarchy. In a sense, scopes are like C++ namespaces that
  automatically track the project's filesystem structure and use directories
  as their names. The following listing illustrates the parallel directory and
  scope hierarchies for our <code>hello</code> project. <span class="note">The
  <code>build/</code> subdirectory is special and does not have a
  corresponding scope.</span></p>

  <pre>hello/                   hello/
│                        {
└── hello/                 hello/
    │                      {
    └── ...                  ...
                           }
                         }</pre>

  <p>Every <code>buildfile</code> is loaded in its corresponding scope,
  variables set in a <code>buildfile</code> are set in this scope and relative
  targets mentioned in a <code>buildfile</code> are relative to this scope's
  directory. Let's "load" the <code>buildfile</code> contents from our
  <code>hello</code> project to the above listing:</p>

  <pre>hello/                   hello/
│                        {
├── buildfile              ./: {*/ -build/}
│
└── hello/                 hello/
    │                      {
    └── buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         }</pre>

  <p>In fact, to be absolutely precise, we should also add the contents of
  <code>bootstrap.build</code> and <code>root.build</code> to the project's
  root scope (module loading is omitted for brevity):</p>

  <pre>hello/                   hello/
│                        {
├── build/
│   ├── bootstrap.build    project = hello
│   │
│   └── root.build         cxx.std = latest
│                          hxx{*}: extension = hxx
│                          cxx{*}: extension = cxx
│
├── buildfile              ./: {*/ -build/}
│
└── hello/                 hello/
    │                      {
    └── buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         }</pre>

  <p>The above scope structure is very similar to what you will see (besides a
  lot of other things) if you build with <code>--dump&#160;match</code>. With
  this option the build system driver dumps the build state after matching
  rules to targets (see <a href="#intro-diag-debug">Diagnostics and
  Debugging</a> for more information). Here is an abbreviated output of
  bulding our <code>hello</code> with <code>--dump</code> (assuming an in
  source build in <code>/tmp/hello</code>):</p>

  <pre>$ b --dump match

/
{
  [target_triplet] build.host = x86_64-linux-gnu
  [string] build.host.class = linux
  [string] build.host.cpu = x86_64
  [string] build.host.system = linux-gnu

  /tmp/hello/
  {

    [dir_path] src_root = /tmp/hello/
    [dir_path] out_root = /tmp/hello/

    [dir_path] src_base = /tmp/hello/
    [dir_path] out_base = /tmp/hello/

    [project_name] project = hello
    [string] project.summary = hello executable
    [string] project.url = https://example.org/hello

    [string] version = 1.2.3
    [uint64] version.major = 1
    [uint64] version.minor = 2
    [uint64] version.patch = 3

    [string] cxx.std = latest

    [string] cxx.id = gcc
    [string] cxx.version = 8.1.0
    [uint64] cxx.version.major = 8
    [uint64] cxx.version.minor = 1
    [uint64] cxx.version.patch = 0

    [target_triplet] cxx.target = x86_64-w64-mingw32
    [string] cxx.target.class = windows
    [string] cxx.target.cpu = x86_64
    [string] cxx.target.system = mingw32

    hxx{*}: [string] extension = hxx
    cxx{*}: [string] extension = cxx

    hello/
    {
      [dir_path] src_base = /tmp/hello/hello/
      [dir_path] out_base = /tmp/hello/hello/

      dir{./}: exe{hello}
      exe{hello.}: cxx{hello.cxx}
    }

    dir{./}: dir{hello/} manifest{manifest}
  }
}</pre>

  <p>This is probably quite a bit more information than what you've expected
  to see so let's explain a couple of things. Firstly, it appears there is
  another scope outer to our project's root. In fact, <code>build2</code>
  extends scoping outside of projects with the root of the filesystem (denoted
  by the special <code>/</code>) being the <i>global scope</i>. This extension
  becomes useful when we try to build multiple unrelated projects or import
  one project into another. In this model all projects are part of a single
  scope hierarchy with the global scope at its root.</p>

  <p>The global scope is read-only and contains a number of pre-defined
  <i>build-wide</i> variables such as the build system version, host platform
  (shown in the above listing), etc.</p>

  <p>Next, inside the global scope, we see our project's root scope
  (<code>/tmp/hello/</code>). Besides the variables that we have set ourselves
  (like <code>project</code>), it also contains a number of variables set by
  the build system core (for example, <code>out_base</code>,
  <code>src_root</code>, etc) as well by build system modules (for example,
  <code>project.*</code> and <code>version.*</code> variables set by the
  <code>version</code> module and <code>cxx.*</code> variables set by the
  <code>cxx</code> module).</p>

  <p>The scope for our project's source directory (<code>hello/</code>) should
  look familiar. We again have a few special variables (<code>out_base</code>,
  <code>src_base</code>). Notice also that the name patterns in prerequisites
  have been expanded to the actual files.</p>

  <p>As you can probably guess from their names, the <code>src_*</code> and
  <code>out_*</code> variables track the association between scopes and
  src/out directories. They are maintained automatically by the build system
  core with the <code>src/out_base</code> pair set on each scope within the
  project and an additional <code>src/out_root</code> pair set on the
  project's root scope so that we can get the project's root directories from
  anywhere in the project. Note that directory paths in these variables are
  always absolute and normalized.</p>

  <p>In the above example the corresponding src/out variable pairs have the
  same values because we were building in source. As an example, this is what
  the association will look like for an out of source build:</p>

  <pre>hello/  ~~>      hello-out/                   &lt;~~  hello-out/
│                {                                 │
│                  src_root = .../hello/           │
│                  out_root = .../hello-out/       │
│                                                  │
│                  src_base = .../hello/           │
│                  out_base = .../hello-out/       │
│                                                  │
└── hello/  ~~>    hello/                     &lt;~~  └── hello/
                   {
                     src_base = .../hello/hello/
                     out_base = .../hello-out/hello/
                   }
                 }</pre>

  <p>Now that we have some scopes and variables to play with, it's a good time
  to introduce variable expansion. To get the value stored in a variable we
  use <code>$</code> followed by the variable's name. The variable is first
  looked up in the current scope (that is, the scope in which the expansion
  was encountered) and, if not found, in the outer scopes all the way to the
  global scope.</p>

  <div class="note">
  <p>To be precise, this is for the default <i>variable visibility</i>.
  Variables, however, can have more limited visibilities, such as
  <i>project</i>, <i>scope</i>, <i>target</i>, or <i>prerequisite</i>.</p>
  </div>

  <p>To illustrate the lookup semantics, let's add the following line to each
  <code>buildfile</code> in our <code>hello</code> project:</p>

  <pre>$ cd hello/  # Change to project root.

$ cat buildfile
...
info "src_base: $src_base"

$ cat hello/buildfile
...
info "src_base: $src_base"</pre>

  <p>And then build it:</p>

  <pre>$ b
buildfile:3:1: info: src_base: /tmp/hello/
hello/buildfile:8:1: info: src_base: /tmp/hello/hello/</pre>

  <p>In this case <code>src_base</code> is defined in each of the two scopes
  and we get their respective values. If, however, we change the above line to
  print <code>src_root</code> instead of <code>src_base</code>, we will get
  the same value from the root scope:</p>

  <pre>buildfile:3:1: info: src_root: /tmp/hello/
hello/buildfile:8:1: info: src_root: /tmp/hello/</pre>

  <div class="note">
  <p>In this section we've only scratched the surface when it comes to
  variables. In particular, variables and variable values in
  <code>build2</code> are optionally typed (those <code>[string]</code>,
  <code>[uint64]</code> we've seen in the build state dump). And in certain
  contexts the lookup semantics actually starts from the target, not from the
  scope (target-specific variables; there are also prerequisite-specific).
  These and other variable-related topics will be covered in subsequent
  sections.</p>
  </div>

  <p>One typical place to find <code>src/out_root</code> expansions is in the
  include search path options. For example, the source directory
  <code>buildfile</code> generated by <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a> for
  an executable project actually looks like this (<code>poptions</code> stands
  for <i>preprocessor options</i>):</p>

  <pre>exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root"</pre>

  <div class="note">
  <p>The strange-looking <code>=+</code> line is a <i>prepend</i> variable
  assignment. It adds the value on the right hand side to the beginning of the
  existing value. So, in the above example, the two header search paths will
  be added before any of the existing preprocessor options (and thus will be
  considered first).</p>

  <p>There are also the <i>append</i> assignment, <code>+=</code>, which adds
  the value on the right hand side to the end of the existing value, as well
  as, of course, the normal or <i>replace</i> assignment, <code>=</code>,
  which replaces the existing value with the right hand side. One way to
  remember where the existing and new values end up in the <code>=+</code> and
  <code>+=</code> results is to imagine the new value taking the position of
  <code>=</code> and the existing value &#8211; of <code>+</code>.</p>
  </div>

  <p>The above <code>buildfile</code> allows us to include our headers using
  the project's name as a prefix, inline with the <a
  href="../../build2-toolchain/doc/build2-toolchain-intro.xhtml#structure-canonical">Canonical
  Project Structure</a> guidelines. For example, if we added the
  <code>utility.hxx</code> header to our <code>hello</code> project, we would
  include it like this:</p>

  <pre>#include &lt;iostream>

#include &lt;hello/utility.hxx>

int main ()
{
...
}</pre>

  <div class="note">
  <p>Besides <code>poptions</code>, there are also <code>coptions</code>
  (compile options), <code>loptions</code> (link options) and
  <code>libs</code> (extra libraries to link). If you are familiar with
  <code>make</code>, these are roughly equivalent to <code>CPPFLAGS</code>,
  <code>CFLAGS</code>/<code>CXXFLAGS</code>, <code>LDFLAGS</code>, and
  <code>LIBS</code>.</p>

  <p>More specifically, there are three sets of these variables:
  <code>cc.*</code> (stands for <i>C-common</i>) which applies to all C-like
  languages as well as <code>c.*</code> and <code>cxx.*</code> which only
  apply during the C and C++ compilation, respectively. We can use these
  variables in our <code>buildfiles</code> to adjust the compiler/linker
  behavior. For example:</p>

  <pre>if ($cc.class == 'gcc')
{
  cc.coptions  += -fno-strict-aliasing  # C and C++
  cxx.coptions += -fno-exceptions       # only C++
}

if ($c.target.class != 'windows')
  c.libs += -lpthread  # only C</pre>

  <p>Additionally, as we will see in <a
  href="#intro-operations-config">Configuration</a>, there are also the
  <code>config.cc.*</code>, <code>config.c.*</code>, and
  <code>config.cxx.*</code> sets which are used by the users of our projects
  to provide external configuration. The initial values of the
  <code>cc.*</code>, <code>c.*</code>, and <code>cxx.*</code> variables are
  taken from the corresponding <code>config.*.*</code> values.</p>

  <p>And, as we will learn in <a href="#intro-lib">Library Exportation</a>,
  there are also the <code>cc.export.*</code>, <code>c.export.*</code>, and
  <code>cxx.export.*</code> sets that are used to specify options that should
  be exported to the users of our library.</p>

  <p>If we adjust the <code>cc.*</code>, <code>c.*</code>, and
  <code>cxx.*</code> variables at the scope level, as in the above fragment,
  then the changes will apply when building every target in this scope (as
  well as in the nested scopes, if any). Usually this is what we want but
  sometimes we may need to pass additional options only when compiling certain
  source files or linking certain libraries or executables. For that we use
  the target-specific variable assignment. For example:</p>

  <pre>exe{hello}: {hxx cxx}{**}

obj{utility}: cxx.poptions += -DNDEBUG
exe{hello}: cxx.loptions += -static</pre>

  <p>Note that we set these variables on targets which they affect. In
  particular, those with a background in other build systems may, for example,
  erroneously expect that setting <code>poptions</code> on a library target
  will affect compilation of its prerequisites. For example, the following
  does not work:</p>

  <pre>exe{hello}: cxx.poptions += -DNDEBUG</pre>

  <p>The recommended way to achieve this behavior in <code>build2</code> is to
  organize your targets into subdirectories, in which case we can just set the
  variables on the scope. And if this is impossible or undesirable, then we
  can use target type/pattern-specific variables (if there is a common
  pattern) or simply list the affected targets explicitly. For example:</p>

  <pre>obj{*.test}: cxx.poptions += -DDEFINE_MAIN
obj{main utility}: cxx.poptions += -DNDEBUG</pre>

  <p>The first line covers compilation of source files that have the
  <code>.test</code> second-level extension (see <a
  href="#intro-unit-test">Implementing Unit Testing</a> for background) while
  the second simply lists the targets explicitly.</p>

  <p>It is also possible to specify different options when producing different
  types of object files (<code>obje{}</code> &#8211; executable,
  <code>obja{}</code> &#8211; static library, or <code>objs{}</code> &#8211;
  shared library) or when linking different libraries (<code>liba{}</code>
  &#8211; static library or <code>libs{}</code> &#8211; shared library). See
  <a href="#intro-lib">Library Exportation and Versioning</a> for an
  example.</p>
  </div>

  <p>As mentioned above, each <code>buildfile</code> in a project is loaded
  into its corresponding scope. As a result, we rarely need to open scopes
  explicitly. In the few cases that we do, we use the following syntax:</p>

  <pre>&lt;directory>/
{
  ...
}</pre>

  <p>If the scope directory is relative, then it is assumed to be relative to
  the current scope. As an exercise for understanding, let's reimplement our
  <code>hello</code> project as a single <code>buildfile</code>. That is, we
  move the contents of the source directory <code>buildfile</code> into the
  root <code>buildfile</code>:</p>

  <pre>$ tree hello/
hello/
├── build/
│   └── ...
├── hello/
│   └── hello.cxx
└── buildfile

$ cat hello/buildfile

./: hello/

hello/
{
  ./: exe{hello}: {hxx cxx}{**}
}</pre>

  <div class="note">
  <p>While this single <code>buildfile</code> setup is not recommended for new
  projects, it can be useful for non-intrusive conversion of existing projects
  to <code>build2</code>. One approach is to place the unmodified original
  project into a subdirectory (potentially automating this with a mechanism
  such as <code>git(1)</code> submodules) then adding the <code>build/</code>
  subdirectory and the root <code>buildfile</code> which explicitly opens
  scopes to define the build over the upstream project's subdirectory
  structure.</p>
  </div>

  <p>Seeing this merged <code>buildfile</code> may make you wonder what
  exactly caused the loading of the source directory <code>buildfile</code> in
  our normal setup. In other words, when we build our <code>hello</code> from
  the project root, who and why loads <code>hello/buildfile</code>?</p>

  <p>Actually, in the earlier days of <code>build2</code>, we had to
  explicitly load <code>buildfiles</code> that define targets we depend on
  with the <code>include</code> directive. In fact, we still can (and have to
  if we are depending on targets other than directories). For example:</p>

  <pre>./: hello/

include hello/buildfile</pre>

  <p>We can also omit <code>buildfile</code> for brevity and have just:</p>

  <pre>include hello/</pre>

  <p>This explicit inclusion, however, quickly becomes tiresome as the number
  of directories grows. It also makes using wildcard patterns for subdirectory
  prerequisites a lot less appealing.</p>

  <p>To overcome this the <code>dir{}</code> target type implements an
  interesting prerequisite to target resolution semantics: if there is no
  existing target with this name, a <code>buildfile</code> that (presumably)
  defines this target is automatically loaded from the corresponding
  directory. In fact, this mechanism goes a step further and, if the
  <code>buildfile</code> does not exist, then it assumes one with the
  following contents was implied:</p>

  <pre>./: */</pre>

  <p>That is, it simply builds all the subdirectories. This is especially
  handy when organizing related tests into directory hierarchies.</p>

  <div class="note">
  <p>As mentioned above, this automatic inclusion is only triggered if the
  target we depend on is <code>dir{}</code> and we still have to explicitly
  include the necessary <code>buildfiles</code> for other targets. One common
  example is a project consisting of a library and an executable that links
  it, each residing in a separate directory next to each other (as noted
  earlier, this is not recommended for projects that you plan to package). For
  example:</p>

  <pre>hello/
├── build/
│   └── ...
├── hello/
│   ├── main.cxx
│   └── buildfile
├── libhello/
│   ├── hello.hxx
│   ├── hello.cxx
│   └── buildfile
└── buildfile</pre>

  <p>In this case the executable <code>buildfile</code> would look along these
  lines:</p>

  <pre>include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} lib{hello}</pre>

  <p>Note also that <code>buildfile</code> inclusion should only be used for
  accessing targets within the same project. For cross-project references we
  use <a href="#intro-import">Target Importation</a>.</p>
  </div>

  <h2 id="intro-operations">1.4 Operations</h2>

  <p>Modern build systems have to perform operations other than just building:
  cleaning the build output, running tests, installing/uninstalling the build
  results, preparing source distributions, and so on. And, if the build system
  has integrated configuration support, configuring the project would
  naturally belong to this list as well.</p>

  <div class="note">
  <p>If you are familiar with <code>make</code>, you should recognize the
  parallel with the common <code>clean</code> <code>test</code>,
  <code>install</code>, and <code>dist</code>, "operation" pseudo-targets.</p>
  </div>

  <p>In <code>build2</code> we have the concept of a <i>build system
  operation</i> performed on a target. The two pre-defined operations are
  <code>update</code> and <code>clean</code> with other operations provided by
  build system modules.</p>

  <p>Operations to be performed and targets to perform them on are specified
  on the command line. As discussed earlier, <code>update</code> is the
  default operation and <code>./</code> in the current directory is the
  default target if no operation and/or target is specified explicitly. And,
  similar to targets, we can specify multiple operations (not necessarily on
  the same target) in a single build system invocation. The list of operations
  to perform and targets to perform them on is called a <i>build
  specification</i> or <i>buildspec</i> for short (see <a
  href="b.xhtml"><code><b>b(1)</b></code></a> for details). Here are a few
  examples:</p>

  <pre>$ cd hello        # Change to project root.

$ b               # Update current directory.
$ b ./            # Same as above.
$ b update        # Same as above.
$ b update: ./    # Same as above.

$ b clean update  # Rebuild.

$ b clean:  hello/             # Clean specific target.
$ b update: hello/exe{hello}   # Update specific target

$ b update: libhello/ tests/   # Update two targets.</pre>

  <p>Let's revisit <code>build/bootstrap.build</code> from our
  <code>hello</code> project:</p>

  <pre>project = hello

using version
using config
using test
using install
using dist</pre>

  <p>Other than <code>version</code>, all the modules we load define new
  operations. Let's examine each of them starting with
  <code>config</code>.</p>

  <h3 id="intro-operations-config">1.4.1 Configuration</h3>

  <p>As mentioned briefly earlier, the <code>config</code> module provides
  support for persisting configurations by having us <i>configure</i> our
  projects. At first it may feel natural to call <code>configure</code>
  another operation. There is, however, a conceptual problem: we don't really
  configure a target. And, perhaps after some meditation, it should become
  clear that what we are really doing is configuring operations on targets.
  For example, configuring updating a C++ project might involve detecting and
  saving information about the C++ compiler while configuring installing it
  may require specifying the installation directory.</p>

  <p>In other words, <code>configure</code> is an operation on operation on
  targets &#8211; a meta-operation.  And so in <code>build2</code> we have the
  concept of a <i>build system meta-operation</i>.  If not specified
  explicitly (as part of the buildspec), the default is <code>perform</code>,
  which is to simply perform the operation.</p>

  <p>Back to <code>config</code>, this module provides two meta-operations:
  <code>configure</code> which saves the configuration of a project into the
  <code>build/config.build</code> file as well as <code>disfigure</code> which
  removes it.</p>

  <div class="note">
  <p>While the common meaning of the word <i>disfigure</i> is somewhat
  different to what we make it mean in this context, we still prefer it over
  the commonly suggested alternative (<i>deconfigure</i>) for the symmetry of
  their Latin <i>con-</i> ("together") and <i>dis-</i> ("apart") prefixes.</p>
  </div>

  <p>Let's say for the in source build of our <code>hello</code> project we
  want to use <code>Clang</code> and enable debug information. Without
  persistence we would have to repeat this configuration on every build system
  invocation:</p>

  <pre>$ cd hello/  # Change to project root.

$ b config.cxx=clang++ config.cxx.coptions=-g</pre>

  <p>Instead, we can configure our project with this information once and from
  then on invoke the build system without any arguments:</p>

  <pre>$ b configure config.cxx=clang++ config.cxx.coptions=-g

$ tree ./
./
├── build/
│   ├── ...
│   └── config.build
└── ...

$ b
$ b clean
$ b
...</pre>

  <p>Let's take a look at <code>config.build</code>:</p>

  <pre>$ cat build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]
...</pre>

  <p>As you can see, it's just a buildfile with a bunch of variable
  assignments. In particular, this means you can tweak your build
  configuration by modifying this file with your favorite editor. Or,
  alternatively, you can adjust the configuration by reconfiguring the
  project:</p>

  <pre>$ b configure config.cxx=g++

$ cat build/config.build

config.cxx = g++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]
...</pre>

  <p>Any variable value specified on the command line overrides those
  specified in the <code>buildfiles</code>. As a result,
  <code>config.cxx</code> was updated while the value of
  <code>config.cxx.coptions</code> was preserved.</p>

  <p>Command line variable overrides are also handy to adjust the
  configuration for a single build system invocation. For example, let's say
  we want to quickly check that our project builds with optimization but
  without permanently changing the configuration:</p>

  <pre>$ b config.cxx.coptions=-O3  # Rebuild with -O3.
$ b                          # Rebuild with -g.</pre>

  <p>We can also configure out of source builds of our projects. In this case,
  besides <code>config.build</code>, <code>configure</code> also saves the
  location of the source directory so that we don't have to repeat that
  either. Remember, this is how we used to build our <code>hello</code> out of
  source:</p>

  <pre>$ b hello/@hello-gcc/   config.cxx=g++
$ b hello/@hello-clang/ config.cxx=clang++</pre>

  <p>And now we can do:</p>

  <pre>$ b configure: hello/@hello-gcc/   config.cxx=g++
$ b configure: hello/@hello-clang/ config.cxx=clang++

$ hello-clang/
hello-clang/
└── build/
    ├── bootstrap/
    │   └── src-root.build
    └── config.build

$ b hello-gcc/
$ b hello-clang/
$ b hello-gcc/ hello-clang/</pre>

  <p>One major benefit of an in source build is the ability to run executables
  as well as examine build and test output (test results, generated source
  code, documentation, etc) without leaving the source directory.
  Unfortunately, we cannot have multiple in source builds and as was discussed
  earlier, mixing in and out of source builds is not recommended.</p>

  <p>To overcome this limitation <code>build2</code> has a notion of
  <i>forwarded configurations</i>. As the name suggests, we can configure a
  project's source directory to forward to one of its out of source builds.
  Once done, whenever we run the build system from the source directory, it
  will automatically build in the corresponded forwarded output directory.
  Additionally, it will <i>backlink</i> (using symlinks or another suitable
  mechanism) certain "interesting" targets (<code>exe{}</code>,
  <code>doc{}</code>) to the source directory for easy access. As an example,
  let's configure our <code>hello/</code> source directory to forward to the
  <code>hello-gcc/</code> build:</p>

  <pre>$ b configure: hello/@hello-gcc/,forward

$ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello}@../hello-gcc/hello/
ld ../hello-gcc/hello/exe{hello}
ln ../hello-gcc/hello/exe{hello} -> hello/</pre>

  <p>Notice the last line in the above listing: it indicates that
  <code>exe{hello</code>} from the out directory was backlinked in our
  project's source subdirectory:</p>

  <pre>$ tree ./
./
├── build/
│   ├── bootstrap/
│   │   └── out-root.build
│   └── ...
├── hello/
│   ├── ...
│   └── hello -> ../../hello-gcc/hello/hello*
└── ...

$ ./hello/hello
Hello World!</pre>

  <div class="note">
  <p>By default only <code>exe{}</code> and <code>doc{}</code> targets are
  backlinked. This, however, can be customized with the <code>backlink</code>
  target-specific variable.</p>
  </div>

  <h3 id="intro-operations-test">1.4.2 Testing</h3>

  <p>The next module we load in <code>bootstrap.build</code> is
  <code>test</code> which defines the <code>test</code> operation. As the name
  suggests, this module provides support for running tests.</p>

  <p>There are two types of tests that we can run with the <code>test</code>
  module: simple and scripted.</p>

  <p>A simple test is just an executable target with the <code>test</code>
  target-specific variable set to <code>true</code>. For example:</p>

  <pre>exe{hello}: test = true</pre>

  <p>A simple test is executed once and in its most basic form (typical for
  unit testing) doesn't take any inputs nor produce any output, indicating
  success via the zero exit status. If we test our <code>hello</code> project
  with the above addition to the <code>buildfile</code>, then we will see the
  following output:</p>

  <pre>$ b test
test hello/exe{hello}
Hello, World!</pre>

  <p>While the test passes (since it exited with zero status), we probably
  don't want to see that <code>Hello, World!</code> every time we run it (this
  can, however, be quite useful when running examples). More importantly, we
  don't really test its functionality and if tomorrow our <code>hello</code>
  starts swearing rather than greeting, the test will still pass.</p>

  <p>Besides checking its exit status we can also supply some basic
  information to a simple test (more common for integration testing).
  Specifically, we can pass command line options (<code>test.options</code>)
  and arguments (<code>test.arguments</code>) as well as input
  (<code>test.stdin</code>, used to supply test's <code>stdin</code>) and
  output (<code>test.stdout</code>, used to compare to test's
  <code>stdout</code>).</p>

  <p>Let's see how we can use this to fix our <code>hello</code> test by
  making sure our program prints the expected greeting. First, we need to add
  a file that will contain the expected output, let's call it
  <code>test.out</code>:</p>

  <pre>$ ls -1 hello/
hello.cxx
test.out
buildfile

$ cat hello/test.out
Hello, World!</pre>

  <p>Next, we arrange for it to be compared to our test's <code>stdout</code>.
  Here is the new <code>hello/buildfile</code>:</p>

  <pre>exe{hello}: {hxx cxx}{**}
exe{hello}: file{test.out}: test.stdout = true</pre>

  <p>The last line looks new. What we have here is a <i>prerequisite-specific
  variable</i> assignment. By setting <code>test.stdout</code> for the
  <code>file{test.out}</code> prerequisite of target <code>exe{hello}</code>
  we mark it as expected <code>stdout</code> output of <i>this</i> target
  (theoretically, we could have marked it as <code>test.input</code> for
  another target). Notice also that we no longer need the <code>test</code>
  target-specific variable; it's unnecessary if one of the other
  <code>test.*</code> variables is specified.</p>

  <p>Now, if we run our test, we won't see any output:</p>

  <pre>$ b test
test hello/exe{hello}</pre>

  <p>And if we try to change the greeting in <code>hello.cxx</code> but not in
  <code>test.out</code>, our test will fail printing the <code>diff(1)</code>
  comparison of the expected and actual output:</p>

  <pre>$ b test
c++ hello/cxx{hello}
ld hello/exe{hello}
test hello/exe{hello}
--- test.out
+++ -
@@ -1 +1 @@
-Hello, World!
+Hi, World!
error: test hello/exe{hello} failed</pre>

  <p>Notice another interesting thing: we have modified <code>hello.cxx</code>
  to change the greeting and our test executable was automatically rebuilt
  before testing. This happened because the <code>test</code> operation
  performs <code>update</code> as its <i>pre-operation</i> on all the targets
  to be tested.</p>

  <p>Let's make our <code>hello</code> program more flexible by accepting the
  name to greet on the command line:</p>

  <pre>#include &lt;iostream>

int main (int argc, char* argv[])
{
  if (argc &lt; 2)
  {
    std::cerr &lt;&lt; "error: missing name" &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; "Hello, " &lt;&lt; argv[1] &lt;&lt; '!' &lt;&lt; std::endl;
}</pre>

  <p>We can exercise its successful execution path with a simple test fairly
  easily:</p>

  <pre>exe{hello}: test.arguments = 'World'
exe{hello}: file{test.out}: test.stdout = true</pre>

  <p>What if we also wanted to test its error handling? Since simple tests are
  single-run, this won't be easy. Even if we could overcome this, having
  expected output for each test in a separate file will quickly become untidy.
  And this is where script-based tests come in. Testscript is
  <code>build2</code>'s portable language for running tests. It vaguely
  resembles Bash and is optimized for concise test implementation and fast,
  parallel execution.</p>

  <p>Just to give you an idea (see <a
  href="build2-testscript-manual.xhtml#intro">Testscript Introduction</a> for
  a proper introduction), here is what testing our <code>hello</code> program
  with Testscript would look like:</p>

  <pre>$ ls -1 hello/
hello.cxx
testscript
buildfile

$ cat hello/buildfile

exe{hello}: {hxx cxx}{**} testscript</pre>

  <p>And this is the contents of <code>hello/testscript</code>:</p>

  <pre>: basics
:
$* 'World' >'Hello, World!'

: missing-name
:
$* 2>>EOE != 0
error: missing name
EOE</pre>

  <p>A couple of key points: The <code>test.out</code> file is gone with all
  the test inputs and expected outputs incorporated into
  <code>testscript</code>. To test an executable with Testscript, all we have
  to do is list the corresponding <code>testscript</code> file as its
  prerequisite (and which, being a fixed name, doesn't need an explicit target
  type, similar to <code>manifest</code>).</p>

  <p>To see Testscript in action, let's say we've made our program more
  forgiving by falling back to a default name if one wasn't specified:</p>

  <pre>#include &lt;iostream>

int main (int argc, char* argv[])
{
  const char* n (argc > 1 ? argv[1] : "World");
  std::cout &lt;&lt; "Hello, " &lt;&lt; n &lt;&lt; '!' &lt;&lt; std::endl;
}</pre>

  <p>If we forget to adjust the <code>missing-name</code> test, then this is
  what we could expect to see when running the tests:</p>

  <pre>b test
c++ hello/cxx{hello}
ld hello/exe{hello}
test hello/testscript{testscript} hello/exe{hello}
hello/testscript:7:1: error: hello/hello exit code 0 == 0
  info: stdout: hello/test-hello/missing-name/stdout</pre>

  <p>Testscript-based integration testing is the default setup for executable
  (<code>-t&#160;exe</code>) projects created by <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a>.
  Here is the recap of the overall layout:</p>

  <pre>hello/
├── build/
│   └── ...
├── hello/
│   ├── hello.cxx
│   ├── testscript
│   └── buildfile
├── buildfile
└── manifest</pre>

  <p>For libraries (<code>-t&#160;lib</code>), however, the integration
  testing setup is a bit different. Here are the relevant parts of the
  layout:</p>

  <pre>libhello/
├── build/
│   └── ...
├── libhello/
│   ├── hello.hxx
│   ├── hello.cxx
│   ├── export.hxx
│   ├── version.hxx.in
│   └── buildfile
├── tests/
│   ├── build/
│   │   ├── bootstrap.build
│   │   └── root.build
│   ├── basics/
│   │   ├── driver.cxx
│   │   └── buildfile
│   └── buildfile
├── buildfile
└── manifest</pre>

  <p>Specifically, there is no <code>testscript</code> in
  <code>libhello/</code>, the project's source directory. Instead, we have the
  <code>tests/</code> subdirectory which itself looks like a project: it
  contains the <code>build/</code> subdirectory with all the familiar files,
  etc. In fact, <code>tests</code> is a <i>subproject</i> of our
  <code>libhello</code> project.</p>

  <p>While we will be examining <code>tests</code> in greater detail later, in
  a nutshell, the reason it is a subproject is to be able to test an installed
  version of our library. By default, when <code>tests</code> is built as part
  of its parent project (called <i>amalgamation</i>), the locally built
  <code>libhello</code> library will be automatically imported. However, we
  can also configure a build of <code>tests</code> out of its amalgamation, in
  which case we can import an installed version of <code>libhello</code>. We
  will learn how to do all that as well as the underlying concepts
  (<i>subproject</i>/<i>amalgamation</i>, <i>import</i>, etc) in the coming
  sections.</p>

  <p>Inside <code>tests/</code> we have the <code>basics/</code> subdirectory
  which contains a simple test for our library's API. By default it doesn't
  use Testscript but if you want to, you can. You can also rename
  <code>basics/</code> to something more meaningful and add more tests next to
  it. For example, if we were creating an XML parsing and serialization
  library, then our <code>tests/</code> could have the following layout:</p>

  <pre>tests/
├── build/
│   └── ...
├── parser/
│   └── ...
├── serializer/
│   └── ...
└── buildfile</pre>

  <div class="note">
  <p>Nothing prevents us from having the <code>tests/</code> subdirectory for
  executable projects. And it can be just a subdirectory or a subproject, the
  same as for libraries. Making it a subproject makes sense if your program
  has complex installation, for example, if its execution requires
  configuration and/or data files that need to be found, etc. For simple
  programs, however, testing the executable before installing it is usually
  sufficient.</p>

  <p>For a general discussion of functional/integration and unit testing refer
  to the <a
  href="../../build2-toolchain/doc/build2-toolchain-intro.xhtml#proj-struct-tests">Tests</a>
  section in the toolchain introduction. For details on the unit test support
  implementation see <a href="#intro-unit-test">Implementing Unit
  Testing</a>.</p>
  </div>

  <h3 id="intro-operations-install">1.4.3 Installation</h3>

  <p>The <code>install</code> module defines the <code>install</code> and
  <code>uninstall</code> operations. As the name suggests, this module
  provides support for project installation.</p>

  <div class="note">
  <p>Installation in <code>build2</code> is modeled after UNIX-like operation
  systems though the installation directory layout is highly customizable.
  While <code>build2</code> projects can import <code>build2</code> libraries
  directly, installation is often a way to "export" them in a form usable by
  other build systems.</p>
  </div>

  <p>The root installation directory is specified with the
  <code>config.install.root</code> configuration variable. Let's install our
  <code>hello</code> program into <code>/tmp/install</code>:</p>

  <pre>$ cd hello/  # Change to project root.

$ b install config.install.root=/tmp/install/</pre>

  <p>And see what we've got (executables are marked with <code>*</code>):</p>

  <pre>$ tree /tmp/install/

/tmp/install/
├── bin/
│   └── *hello
└── share/
    └── doc/
        └── hello/
            └── manifest</pre>

  <p>Similar to the <code>test</code> operation, <code>install</code> performs
  <code>update</code> as a pre-operation for targets that it installs.</p>

  <div class="note">
  <p>We can also configure our project with the desired
  <code>config.install.*</code> values so that we don't have to repeat them on
  every install/uninstall. For example:</p>

  <pre>$ b configure config.install.root=/tmp/install/
$ b install
$ b uninstall</pre>
  </div>

  <p>Now let's try the same for <code>libhello</code> (symbolic link targets
  are shown with <code>-></code> and actual static/shared library names may
  differ on your operating system):</p>

  <pre>$ rm -r /tmp/install

$ cd libhello/  # Change to project root.

$ b install config.install.root=/tmp/install/

$ tree /tmp/install/

/tmp/install/
├── include/
│   └── libhello/
│       ├── hello.hxx
│       ├── export.hxx
│       └── version.hxx
├── lib/
│   ├── pkgconfig/
│   │   ├── libhello.shared.pc
│   │   └── libhello.static.pc
│   ├── libhello.a
│   ├── libhello.so -> libhello-0.1.so
│   └── libhello-0.1.so
└── share/
    └── doc/
        └── libhello/
            └── manifest</pre>

  <p>As you can see, the library headers go into the customary
  <code>include/</code> subdirectory while static and shared libraries (and
  their <code>pkg-config(1)</code> files) &#8211; into <code>lib/</code>.
  Using this installation we should be able to import this library from other
  build systems or even use it in a manual build:</p>

  <pre>$ g++ -I/tmp/install/include -L/tmp/install/lib greet.cxx -lhello</pre>

  <p>If we want to install into a system-wide location like <code>/usr</code>
  or <code>/usr/local</code>, then we most likely will need to specify the
  <code>sudo(1)</code> program:</p>

  <pre>$ b config.install.root=/usr/local/ config.install.sudo=sudo</pre>

  <div class="note">
  <p>In <code>build2</code> only actual install/uninstall commands are
  executed with <code>sudo(1)</code>. And while on the topic of sensible
  implementations, <code>uninstall</code> can be generally trusted to work
  reliably.</p>
  </div>

  <p>The default installability of a target as well as where it is installed
  is determined by its target type. For example, <code>exe{}</code> is by
  default installed into <code>bin/</code>, <code>doc{}</code> &#8211; into
  <code>share/doc/&lt;project>/</code>, and <code>file{}</code> is not
  installed.</p>

  <p>We can, however, override these defaults with the <code>install</code>
  target-specific variable.  Its value should be either special
  <code>false</code> indicating that the target should not be installed or the
  directory to install the target to. As an example, here is what the root
  <code>buildfile</code> from our <code>libhello</code> project looks
  like:</p>

  <pre>./: {*/ -build/} manifest

tests/: install = false</pre>

  <p>The first line we have already seen and the purpose of the second line
  should now be clear: it makes sure we don't try to install anything in the
  <code>tests/</code> subdirectory.</p>

  <p>If the value of the <code>install</code> variable is not
  <code>false</code>, then it is normally a relative path with the first path
  component being one of these names:</p>

  <pre>name        default                         override
----        -------                         --------
root                                        config.install.root

data_root   root/                           config.install.data_root
exec_root   root/                           config.install.exec_root

bin         exec_root/bin/                  config.install.bin
sbin        exec_root/sbin/                 config.install.sbin
lib         exec_root/lib/                  config.install.lib
libexec     exec_root/libexec/&lt;project>/    config.install.libexec
pkgconfig   lib/pkgconfig/                  config.install.pkgconfig

data        data_root/share/&lt;project>/      config.install.data
include     data_root/include/              config.install.include

doc         data_root/share/doc/&lt;project>/  config.install.doc
man         data_root/share/man/            config.install.man
man&lt;N>      man/man&lt;N>/                     config.install.man&lt;N></pre>

  <p>Let's see what's going on here: The default install directory tree is
  derived from the <code>config.install.root</code> value but the location of
  each node in this tree can be overridden by the user that installs our
  project using the corresponding <code>config.install.*</code> variables. In
  our <code>buildfiles</code>, in turn, we use the node names instead of
  actual directories. As an example, here is a <code>buildfile</code> fragment
  from the source directory of our <code>libhello</code> project:</p>

  <pre>hxx{*}:
{
  install         = include/libhello/
  install.subdirs = true
}</pre>

  <p>Here we set the installation location for headers to be the
  <code>libhello/</code> subdirectory of the <code>include</code> installation
  location. Assuming <code>config.install.root</code> is <code>/usr/</code>,
  the <code>install</code> module will perform the following steps to resolve
  this relative path to the actual, absolute installation directory:</p>

  <pre>include/libhello/
data_root/include/libhello/
root/include/libhello/
/usr/include/libhello/</pre>

  <p>In the above <code>buildfile</code> fragment we also see the use of the
  <code>install.subdirs</code> variable. Setting it to <code>true</code>
  instructs the <code>install</code> module to recreate subdirectories
  starting from this point in the project's directory hierarchy.  For example,
  if our <code>libhello/</code> source directory had the <code>details/</code>
  subdirectory with the <code>utility.hxx</code> header, then this header
  would have been installed as
  <code>.../include/libhello/details/utility.hxx</code>.</p>

  <h3 id="intro-operations-dist">1.4.4 Distribution</h3>

  <p>The last module that we load in our <code>bootstrap.build</code> is
  <code>dist</code> which provides support for the preparation of
  distributions and defines the <code>dist</code> meta-operation. Similar to
  <code>configure</code>, <code>dist</code> is a meta-operation rather than an
  operation because, conceptually, we are preparing a distribution for
  performing operations (like <code>update</code>, <code>test</code>) on
  targets rather than targets themselves.</p>

  <p>The preparation of a correct distribution requires that all the necessary
  project files (sources, documentation, etc) be listed as prerequisites in
  the project's <code>buildfiles</code>.</p>

  <div class="note">
  <p>You may wonder why not just use the export support offered by many
  version control systems? The main reason is that in most real-world projects
  version control repositories contain a lot more than what needs to be
  distributed. In fact, it is not uncommon to host multiple build system
  projects/packages in a single repository. As a result, with this approach we
  seem to inevitably end up maintaining an exclusion list, which feels
  backwards: why specify all the things we don't want in a new list instead of
  making sure the already existing list of things that we do want is complete?
  Also, once we have the complete list, it can be put to good use by other
  tools, such as editors, IDEs, etc.</p>
  </div>

  <p>The preparation of a distribution also requires an out of source build.
  This allows the <code>dist</code> module to distinguish between source and
  output targets. By default, targets found in src are included into the
  distribution while those in out are excluded. However, we can customize this
  with the <code>dist</code> target-specific variable.</p>

  <p>As an example, let's prepare a distribution of our <code>hello</code>
  project using the out of source build configured in <code>hello-out/</code>.
  We use <code>config.dist.root</code> to specify the directory to write the
  distribution to:</p>

  <pre>$ b dist: hello-out/ config.dist.root=/tmp/dist

$ ls -1 /tmp/dist
hello-0.1.0/

$ tree /tmp/dist/hello-0.1.0/
/tmp/dist/hello-0.1.0/
├── build/
│   ├── bootstrap.build
│   └── root.build
├── hello/
│   ├── hello.cxx
│   ├── testscript
│   └── buildfile
├── buildfile
└── manifest</pre>

  <p>As we can see, the distribution directory includes the project version
  (comes from the <code>version</code> variable which, in our case, is
  extracted from <code>manifest</code> by the <code>version</code> module).
  Inside the distribution directory we have our project's source files (but,
  for example, without any <code>.gitignore</code> files that we may have had
  in <code>hello/</code>).</p>

  <p>We can also ask the <code>dist</code> module to package the distribution
  directory into one or more archives and generate their checksum files for
  us. For example:</p>

  <pre>$ b dist: hello-out/ \
  config.dist.root=/tmp/dist \
  config.dist.archives="tar.gz zip" \
  config.dist.checksums=sha256

$ ls -1 /tmp/dist
hello-0.1.0/
hello-0.1.0.tar.gz
hello-0.1.0.tar.gz.sha256
hello-0.1.0.zip
hello-0.1.0.zip.sha256</pre>

  <div class="note">
  <p>We can also configure our project with the desired
  <code>config.dist.*</code> values so we don't have to repeat them every
  time. For example:</p>

  <pre>$ b configure: hello-out/ config.dist.root=/tmp/dist ...
$ b dist</pre>
  </div>

  <p>Let's now take a look at an example of customizing what gets distributed.
  Most of the time you will be using this mechanism to include certain targets
  from out. Here is a fragment from the <code>libhello</code> source directory
  <code>buildfile</code>:</p>

  <pre>hxx{version}: in{version} $src_root/manifest
{
  dist = true
}</pre>

  <p>Our library provides the <code>version.hxx</code> header that the users
  can include to obtain its version. This header is generated by the
  <code>version</code> module from the <code>version.hxx.in</code> template.
  In essence, the <code>version</code> module takes the version value from our
  <code>manifest</code>, splits it into various components (major, minor,
  patch, etc) and then preprocesses the <code>in{}</code> file substituting
  these values (see <a href="#module-version"><code>version</code> Module</a>
  for details). The end result is an automatically maintained version
  header.</p>

  <p>One problem with auto-generated headers is that if one does not yet
  exist, then the compiler may still find it somewhere else. For example, we
  may have an older version of a library installed somewhere where the
  compiler searches for headers by default (for example,
  <code>/usr/local/include/</code>). To overcome this problem it is a good
  idea to ship pre-generated headers in our distributions.  But since they are
  output targets, we have to explicitly request this with
  <code>dist=true</code>.</p>

  <h2 id="intro-import">1.5 Target Importation</h2>

  <p>Recall that if we need to depend on a target defined in another
  <code>buildfile</code> within our project, then we simply include said
  <code>buildfile</code> and reference the target.  For example, if our
  <code>hello</code> included both an executable and a library in separate
  subdirectories next to each other:</p>

  <pre>hello/
├── build/
│   └── ...
├── hello/
│   ├── ...
│   └── buildfile
└── libhello/
    ├── ...
    └── buildfile</pre>

  <p>Then our executable <code>buildfile</code> could look like this:</p>

  <pre>include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} lib{hello}</pre>

  <p>What if instead <code>libhello</code> were a separate project? The
  inclusion approach would no longer work for two reasons: we don't know the
  path to <code>libhello</code> (after all, it's an independent project and
  can reside anywhere) and we can't assume the path to the
  <code>lib{hello}</code> target within <code>libhello</code> (the project
  directory layout can change).</p>

  <p>To depend on a target from a separate project we use <i>importation</i>
  instead of inclusion. This mechanism is also used to depend on targets that
  are not part of any project, for example, installed libraries.</p>

  <p>The importing project's side is pretty simple. This is what the above
  <code>buildfile</code> will look like if <code>libhello</code> were a
  separate project:</p>

  <pre>import libs = libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs</pre>

  <p>The <code>import</code> directive is a kind of variable assignment that
  resolves a <i>project-qualified</i> relative target
  (<code>libhello%lib{hello}</code>) to an unqualified absolute target and
  stores it in the variable (<code>libs</code> in our case). We can then
  expand the variable (<code>$libs</code>), normally in the dependency
  declaration, to get the imported target.</p>

  <p>If we needed to import several libraries, then we simply repeat the
  <code>import</code> directive, usually accumulating the result in the same
  variable, for example:</p>

  <pre>import libs  = libformat%lib{format}
import libs += libprint%lib{print}
import libs += libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs</pre>

  <p>Let's now try to build our <code>hello</code> project that uses imported
  <code>libhello</code>:</p>

  <pre>$ b hello/
error: unable to import target libhello%lib{hello}
  info: use config.import.libhello command line variable to specify
        its project out_root</pre>

  <p>While that didn't work out well, it does make sense: the build system
  cannot know the location of <code>libhello</code> or which of its builds we
  want to use. Though it does helpfully suggest that we use
  <code>config.import.libhello</code> to specify its out directory
  (<code>out_root</code>). Let's point it to <code>libhello</code> source
  directory to use its in source build
  (<code>out_root&#160;==&#160;src_root</code>):</p>

  <pre>$ b hello/ config.import.libhello=libhello/
c++ libhello/libhello/cxx{hello}
ld libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello}
ld hello/hello/exe{hello}</pre>

  <p>And it works. Naturally, the importation mechanism works the same for out
  of source builds and we can persist the <code>config.import.*</code>
  variables in the project's configuration. As an example, let's configure
  Clang builds of the two projects out of source:</p>

  <pre>$ b configure: libhello/@libhello-clang/ config.cxx=clang++
$ b configure: hello/@hello-clang/ config.cxx=clang++ \
  config.import.libhello=libhello-clang/

$ b hello-clang/
c++ libhello/libhello/cxx{hello}@libhello-clang/libhello/
ld libhello-clang/libhello/libs{hello}
c++ hello/hello/cxx{hello}@hello-clang/hello/
ld hello-clang/hello/exe{hello}</pre>

  <p>If the corresponding <code>config.import.*</code> variable is not
  specified, <code>import</code> searches for a project in a couple of other
  places. First, it looks in the list of subprojects starting from the
  importing project itself and then continuing with its outer amalgamations
  and their subprojects (see <a href="#intro-subproj">Subprojects and
  Amalgamations</a> for details on this subject).</p>

  <div class="note">
  <p>We've actually seen an example of this search step in action: the
  <code>tests</code> subproject in <code>libhello</code>. The test imports
  <code>libhello</code> which is automatically found as an amalgamation
  containing this subproject.</p>
  </div>

  <p>If the project being imported cannot be located using any of these
  methods, then <code>import</code> falls back to the rule-specific search.
  That is, a rule that matches the target may provide support for importing
  certain target types based on rule-specific knowledge. Support for importing
  installed libraries by the C++ link rule is a good example of this.
  Internally, the <code>cxx</code> module extracts the compiler's library
  search paths (that is, paths that would be used to resolve
  <code>-lfoo</code>) and then the link rule uses them to search for installed
  libraries. This allows us to use the same <code>import</code> directive
  regardless of whether we import a library from a separate build, from a
  subproject, or from an installation directory.</p>

  <div class="note">
  <p>Importation of an installed library will work even if it is not a
  <code>build2</code> project. Besides finding the library itself, the link
  rule will also try to locate its <code>pkg-config(1)</code> file and, if
  present, extract additional compile/link flags from it. The link rule also
  automatically produces <code>pkg-config(1)</code> files for libraries that
  it installs.</p>
  </div>

  <p>Let's now examine the exporting side of the importation mechanism. While
  a project doesn't need to do anything special to be found by
  <code>import</code>, it does need to handle locating the exported target (or
  targets; there could be several) within the project as well as loading their
  <code>buildfiles</code>. And this is the job of an <i>export stub</i>, the
  <code>build/export.build</code> file that you might have noticed in the
  <code>libhello</code> project:</p>

  <pre>libhello
├── build/
│   └── export.build
└── ...</pre>

  <p>Let's take a look inside:</p>

  <pre>$out_root/
{
  include libhello/
}

export $out_root/libhello/$import.target</pre>

  <p>An export stub is a special kind of <code>buildfile</code> that bridges
  from the importing project into exporting. It is loaded in a special
  temporary scope out of any project, in a "no man's land" so to speak. The
  only variables set on the temporary scope are <code>src_root</code> and
  <code>out_root</code> of the project being imported as well as
  <code>import.target</code> containing the name of the target being imported
  (without project qualification; that is, <code>lib{hello}</code> in our
  example).</p>

  <p>Typically, an export stub will open the scope of the exporting project,
  load the <code>buildfile</code> that defines the target being exported and
  finally "return" the absolute target name to the importing project using the
  <code>export</code> directive. And this is exactly what the export stub in
  our <code>libhello</code> does.</p>

  <p>We now have all the pieces of the importation puzzle in place and you can
  probably see how they all fit together. To summarize, when the build system
  sees the <code>import</code> directive, it looks for a project with the
  specified name. If found, it creates a temporary scope, sets the
  <code>src/out_root</code> variables to point to the project and
  <code>import.target</code> &#8211; to the target name specified in the
  <code>import</code> directive. And then it load the project's export stub in
  this scope. Inside the export stub we switch to the project's root scope,
  load its <code>buildfile</code> and then use the <code>export</code>
  directive to return the exported target. Once the export stub is processed,
  the build system obtains the exported target and assigns it to the variable
  specified in the <code>import</code> directive.</p>

  <div class="note">
  <p>Our export stub is quite "loose" in that it allows importing any target
  defined in the project's source subdirectory <code>buildfile</code>. While
  we found it to be a good balance between strictness and flexibility, if you
  would like to "tighten" your export stubs, you can. For example:</p>

  <pre>if ($import.target == lib{hello})
  export $out_root/libhello/$import.target</pre>

  <p>If no <code>export</code> directive is executed in an export stub then
  the build system assumes that the target is not exported by the project and
  issues appropriate diagnostics.</p>
  </div>

  <h2 id="intro-lib">1.6 Library Exportation and Versioning</h2>

  <p>By now we have examined and explained every line of every
  <code>buildfile</code> in our <code>hello</code> executable project. There
  are, however, still a few lines to be covered in the source subdirectory
  <code>buildfile</code> in <code>libhello</code>. Here it is in its
  entirety:</p>

  <pre>int_libs = # Interface dependencies.
imp_libs = # Implementation dependencies.

lib{hello}: {hxx ixx txx cxx}{** -version} hxx{version} \
  $imp_libs $int_libs

# Include the generated version header into the distribution (so that
# we don't pick up an installed one) and don't remove it when cleaning
# in src (so that clean results in a state identical to distributed).
#
hxx{version}: in{version} $src_root/manifest
{
  dist  = true
  clean = ($src_root != $out_root)
}

# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

obja{*}: cxx.poptions += -DLIBHELLO_STATIC_BUILD
objs{*}: cxx.poptions += -DLIBHELLO_SHARED_BUILD

# Export options.
#
lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $int_libs
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor"

# Install into the libhello/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libhello/
  install.subdirs = true
}</pre>

  <p>Let's start with all those <code>cxx.export.*</code> variables. It turns
  out that merely exporting a library target is not enough for the importers
  of the library to be able to use it. They also need to know where to find
  its headers, which other libraries to link, etc. This information is carried
  in a set of target-specific <code>cxx.export.*</code> variables that
  parallel the <code>cxx.*</code> set and that together with the library's
  prerequisites constitute the <i>library meta-information protocol</i>. Every
  time a source file that depends on a library is compiled or a binary is
  linked, this information is automatically extracted by the compile and link
  rules from the library dependency chain, recursively. And when the library
  is installed, this information is carried over to its
  <code>pkg-config(1)</code> file.</p>

  <div class="note">
  <p>Similar to the <code>c.*</code> and <code>cc.*</code> sets discussed
  earlier, there are also <code>c.export.*</code> and <code>cc.export.*</code>
  sets.</p>
  </div>

  <p>Here are the parts relevant to the library meta-information protocol in
  the above <code>buildfile</code>:</p>

  <pre>int_libs = # Interface dependencies.
imp_libs = # Implementation dependencies.

lib{hello}: ... $imp_libs $int_libs

lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $int_libs
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED</pre>

  <p>As a first step we classify all our library dependencies into
  <i>interface dependencies</i> and <i>implementation dependencies</i>. A
  library is an interface dependency if it is referenced from our interface,
  for example, by including (importing) one of its headers (modules) from one
  of our (public) headers (modules) or if one of its functions is called from
  our inline or template functions. Otherwise, it is an implementation
  dependency.</p>

  <p>To illustrate the distinction between interface and implementation
  dependencies, let's say we've reimplemented our <code>libhello</code> to use
  <code>libformat</code> to format the greeting and <code>libprint</code> to
  print it.  Here is our new header (<code>hello.hxx</code>):</p>

  <pre>#include &lt;libformat/format.hxx>

namespace hello
{
  void
  say_hello_formatted (std::ostream&amp;, const std::string&amp; hello);

  inline void
  say_hello (std::ostream&amp; o, const std::string&amp; name)
  {
    say_hello_formatted (o, format::format_hello ("Hello", name));
  }
}</pre>

  <p>And this is the new source file (<code>hello.cxx</code>):</p>

  <pre>#include &lt;libprint/print.hxx>

namespace hello
{
  void
  say_hello_formatted (ostream&amp; o, const string&amp; h)
  {
    print::print_hello (o, h);
  }
}</pre>

  <p>In this case, <code>libformat</code> is our interface dependency since we
  both include its header in our interface and call it from one of our inline
  functions. In contrast, <code>libprint</code> is only included and used in
  the source file and so we can safely treat it as an implementation
  dependency. The corresponding <code>import</code> directives in our
  <code>buildfile</code> will therefore look like this:</p>

  <pre>import int_libs = libformat%lib{format}
import imp_libs = libprint%lib{print}</pre>

  <p>The preprocessor options (<code>poptions</code>) of an interface
  dependency must be made available to our library's users. The library itself
  should also be explicitly linked whenever our library is linked. All this is
  achieved by listing the interface dependencies in the
  <code>cxx.export.libs</code> variable:</p>

  <pre>lib{hello}:
{
  cxx.export.libs = $int_libs
}</pre>

  <div class="note">
  <p>More precisely, the interface dependency should be explicitly linked if a
  user of our library may end up with a direct call to the dependency in one
  of their object files. Not linking such a library is called
  <i>underlinking</i> while linking a library unnecessarily (which can happen
  because we've included its header but are not actually calling any of its
  non-inline/template functions) is called <i>overlinking</i>. Underlinking is
  an error on some platforms while overlinking may slow down the process
  startup and/or waste its memory.</p>

  <p>Note also that this only applies to shared libraries. In case of static
  libraries, both interface and implementation dependencies are always linked,
  recursively.</p>
  </div>

  <p>The remaining lines in the library meta-information fragment are:</p>

  <pre>lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED</pre>

  <p>The first line makes sure the users of our library can locate its headers
  by exporting the relevant <code>-I</code> options. The last two lines define
  the library type macros that are relied upon by the <code>export.hxx</code>
  header to properly setup symbol exporting.</p>

  <div class="note">
  <p>The <code>liba{}</code> and <code>libs{}</code> target types correspond
  to the static and shared libraries, respectively. And <code>lib{}</code> is
  actually a target group that can contain one, the other, or both as its
  members.</p>

  <p>Specifically, when we build a <code>lib{}</code> target, which members
  will be built is determined by the <code>config.bin.lib</code> variable with
  the <code>static</code>, <code>shared</code>, and <code>both</code>
  (default) possible values. So to only build a shared library we can run:</p>

  <pre>$ b config.bin.lib=shared</pre>

  <p>When it comes to linking <code>lib{}</code> prerequisites, which member
  is picked is controlled by the <code>config.bin.{exe,liba,libs}.lib</code>
  variables for the executable, static library, and shared library targets,
  respectively. Each contains a list of <code>shared</code> and
  <code>static</code> values that determine the linking preferences. For
  example, to build both shared and static libraries but to link executable to
  static libraries we can run:</p>

  <pre>$ b config.bin.lib=both config.bin.exe.lib=static</pre>

  <p>See <a href="#module-bin"><code>bin</code> Module</a> for more
  information.</p>
  </div>

  <p>Note also that we don't need to change anything in the above
  <code>buildfile</code> if our library is header-only. In <code>build2</code>
  this is handled dynamically and automatically based on the absence of source
  file prerequisites. In fact, the same library can be header-only on some
  platforms or in some configuration and "source-full" in others.</p>

  <div class="note">
  <p>In <code>build2</code> a header-only library (or a module interface-only
  library) is not a different kind of library compared to static/shared
  libraries but is rather a binary-less, or <i>binless</i> for short, static
  or shared library. So, theoretically, it is possible to have a library that
  has a binless static and a binary-full (<i>binfull</i>) shared variants.
  Note also that binless libraries can depend on binfull libraries and are
  fully supported where the <code>pkg-config(1)</code> functionality is
  concerned.</p>

  <p>If you are creating a new library with <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a> and
  are certain that it will always be binless and in all configurations, then
  you can produce a simplified <code>buildfile</code> by specifying the
  <code>binless</code> option, for example:</p>

  <pre>$ bdep new -t lib -l c++,binless libheader-only</pre>
  </div>

  <p>Let's now turn to the second subject of this section and the last
  unexplained bit in our <code>buildfile</code>: shared library versioning.
  Here is the relevant fragment:</p>

  <pre>if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor"</pre>

  <p>Shared library versioning is a murky, platform-specific area. Instead of
  trying to come up with a unified versioning scheme that few are likely to
  comprehend (similar to <code>autoconf</code>), <code>build2</code> provides
  a platform-independent versioning scheme as well as the ability to specify
  platform-specific versions in a native format.</p>

  <p>The library version is specified with the <code>bin.lib.version</code>
  target-specific variable. Its value should be a sequence of
  <code>@</code>-pairs with the left hand side (key) being the platform name
  and the right hand side (value) being the version. An empty key signifies
  the platform-independent version (see <a href="#module-bin"><code>bin</code>
  Module</a> for the exact semantics). For example:</p>

  <pre>lib{hello}: bin.lib.version = @-1.2 linux@3</pre>

  <p><span class="note">While the interface for platform-specific versions is
  defined, their support is not yet implemented by the C/C++ link and install
  rules.</span></p>

  <p>A platform-independent version is embedded as a suffix into the library
  name (and into its <code>soname</code> on relevant platforms) while
  platform-specific versions are handled according to the platform. Continuing
  with the above example, these would be the resulting shared library names on
  select platforms:</p>

  <pre>libhello.so.3       # Linux
libhello-1.2.dll    # Windows
libhello-1.2.dylib  # Mac OS</pre>

  <p>With this background we can now explain what's going in our
  <code>buildfile</code>:</p>

  <pre>if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor"</pre>

  <p>Here we only use platform-independent library versioning. For releases we
  embed both major and minor version components assuming that patch releases
  are binary compatible. For pre-releases, however, we use the complete
  version to make sure it cannot be used in place of another pre-release or
  the final version.</p>

  <div class="note">
  <p>The <code>version.project_id</code> variable contains the project's (as
  opposed to package's), shortest "version id". See the <a
  href="#module-version"><code>version</code> Module</a> for details.</p>
  </div>

  <h2 id="intro-subproj">1.7 Subprojects and Amalgamations</h2>

  <p>In <code>build2</code> projects can contain other projects, recursively.
  In this arrangement the outer project is called an <i>amalgamation</i> and
  the inner &#8211; <i>subprojects</i>. In contrast to importation where we
  merely reference a project somewhere else, amalgamation is physical
  containment. It can be <i>strong</i> where the src directory of a subproject
  is within the amalgamating project or <i>weak</i> where only the out
  directory is contained.</p>

  <p>There are several distinct use cases for amalgamations. We've already
  discussed the <code>tests/</code> subproject in <code>libhello</code>. To
  recap, traditionally, it is made a subproject rather than a subdirectory to
  support building it as a standalone project in order to test library
  installations.</p>

  <p>As discussed in <a href="#intro-import">Target Importation</a>,
  subprojects and amalgamations (as well as their subprojects, recursively)
  are automatically considered when resolving imports. As a result,
  amalgamation can be used to <i>bundle</i> dependencies to produce an
  external dependency-free distribution. For example, if our
  <code>hello</code> project imports <code>libhello</code>, then we could copy
  the <code>libhello</code> project into <code>hello</code>, for example:</p>

  <pre>$ tree hello/
hello/
├── build/
│   └── ...
├── hello/
│   ├── hello.cxx
│   └── ...
├── libhello/
│   ├── build/
│   │   └── ...
│   ├── libhello/
│   │   ├── hello.hxx
│   │   ├── hello.cxx
│   │   └── ...
│   ├── tests/
│   │   └── ...
│   └── buildfile
└── buildfile

$ b hello/
c++ hello/libhello/libhello/cxx{hello}
ld hello/libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello}
ld hello/hello/exe{hello}</pre>

  <p>Note, however, that while project bundling can be useful in certain
  cases, it does not scale as a general dependency management solution. For
  that, independent packaging and proper dependency management are the
  appropriate mechanisms.</p>

  <div class="note">
  <p>By default <code>build2</code> looks for subprojects only in the root
  directory of a project. That is, every root subdirectory is examined to see
  if it itself is a project root. If you need to place a subproject somewhere
  else in your project's directory hierarchy, then you will need to specify
  its location (and of all other subprojects) explicitly with the
  <code>subprojects</code> variable in <code>bootstrap.build</code>. For
  example, if above we placed <code>libhello</code> into the
  <code>extras/</code> subdirectory of <code>hello</code>, then our
  <code>bootstrap.build</code> would need to start like this:</p>

  <pre>project = hello
subprojects = extras/libhello/
...</pre>

  <p>Note also that while importation of specific targets from subprojects is
  always performed, whether they are loaded and built as part of the overall
  project build is controlled using the standard subdirectories inclusion and
  dependency mechanisms. Continuing with the above example, if we adjust the
  root <code>buildfile</code> in <code>hello</code> to exclude the
  <code>extras/</code> subdirectory from the build:</p>

  <pre>./: {*/ -build/ -extras/}</pre>

  <p>Then while we can still import <code>libhello</code> from any
  <code>buildfile</code> in our project, the entire <code>libhello</code> (for
  example, its tests) will never be built as part of the <code>hello</code>
  build.</p>

  <p>Similar to subprojects we can also explicitly specify the project's
  amalgamation with the <code>amalgamation</code> variable (again, in
  <code>bootstrap.build</code>). This is rarely necessary except if you want
  to prevent the project from being amalgamated, in which case you should set
  it to the empty value.</p>

  <p>If either of these variables is not explicitly set, then they will
  contain the automatically discovered values.</p>
  </div>

  <p>Besides affecting importation, another central property of amalgamation
  is configuration inheritance. As an example, let's configure the above
  bundled <code>hello</code> project in its src directory:</p>

  <pre>$ b configure: hello/ config.cxx=clang++ config.cxx.coptions=-g

$ b tree
hello/
├── build/
│   ├── config.build
│   └── ...
├── libhello/
│   ├── build/
│   │   ├── config.build
│   │   └── ...
│   └── ...
└── ...</pre>

  <p>As you can see, we now have the <code>config.build</code> files in both
  project's <code>build/</code> subdirectories. If we examine the
  amalgamation's <code>config.build</code>, we will see the familiar
  picture:</p>

  <pre>$ cat hello/build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]

...
</pre>

  <p>The subproject's <code>config.build</code>, however, is pretty much
  empty:</p>

  <pre>$ cat hello/libhello/build/config.build

# Base configuration inherited from ../</pre>

  <p>As the comment suggests, the base configuration is inherited from the
  outer project. We can, however, override some values if we need to. For
  example (note that we are re-configuring the <code>libhello</code>
  subproject):</p>

  <pre>$ b configure: hello/libhello/ config.cxx.coptions=-O2

$ cat hello/libhello/build/config.build

# Base configuration inherited from ../

config.cxx.coptions = -O2</pre>

  <p>This configuration inheritance combined with import resolution is behind
  the most common use of amalgamations in <code>build2</code> &#8211; shared
  build configurations. Let's say we are developing multiple projects, for
  example, <code>hello</code> and <code>libhello</code> that it imports:</p>

  <pre>$ ls -1
hello/
libhello/</pre>

  <p>And we want to build them with several compilers, let's say GCC and
  Clang. As we have already seen in <a
  href="#intro-operations-config">Configuration</a>, we can configure several
  out of source builds for each compiler, for example:</p>

  <pre>$ b configure: libhello/@libhello-gcc/   config.cxx=g++
$ b configure: libhello/@libhello-clang/ config.cxx=clang++

$ b configure: hello/@hello-gcc/   \
               config.cxx=g++      \
               config.import.libhello=libhello-gcc/
$ b configure: hello/@hello-clang/ \
               config.cxx=clang++  \
               config.import.libhello=libhello-clang/

$ ls -l
hello/
hello-gcc/
hello-clang/
libhello/
libhello-gcc/
libhello-clang/</pre>

  <p>Needless to say, this is a lot of repetitive typing. Another problem is
  future changes to the configurations. If, for example, we need to adjust
  compile options in the GCC configuration, then we will have to (remember to)
  do it in both places.</p>

  <p>You can probably sense where this is going: why not create a shared build
  configuration (that is, an amalgamation) for GCC and Clang where we build
  both of our projects (as its subprojects)? This is how we can do that:</p>

  <pre>$ b create: build-gcc/,cc   config.cxx=g++
$ b create: build-clang/,cc config.cxx=clang++

$ b configure: libhello/@build-gcc/libhello/
$ b configure: hello/@build-gcc/hello/

$ b configure: libhello/@build-clang/libhello/
$ b configure: hello/@build-clang/hello/

$ ls -l
hello/
libhello/
build-gcc/
build-clang/</pre>

  <p>Let's explain what's going on here. First, we create two build
  configurations using the <code>create</code> meta-operation. These are real
  <code>build2</code> projects just tailored for housing other projects as
  subprojects. In <code>create</code>, after the directory name, we specify
  the list of modules to load in the project's <code>root.build</code>. In our
  case we specify <code>cc</code> which is a common module for C-based
  languages (see <a href="b.xhtml"><code><b>b(1)</b></code></a> for details on
  <code>create</code> and its parameters).</p>

  <div class="note">
  <p>When creating build configurations it is a good idea to get into the
  habit of using the <code>cc</code> module instead of <code>c</code> or
  <code>cxx</code> since with more complex dependency chains we may not know
  whether every project we build only uses C or C++. In fact, it is not
  uncommon for a C++ project to have C implementation details and even the
  other way around (yes, really, there are C libraries with C++
  implementations).</p>
  </div>

  <p>Once the configurations are ready we simply configure our
  <code>libhello</code> and <code>hello</code> as subprojects in each of them.
  Note that now we neither need to specify <code>config.cxx</code>, because it
  will be inherited from the amalgamation, nor <code>config.import.*</code>,
  because the import will be automatically resolved to a subproject.</p>

  <p>Now, to build a specific project in a particular configuration we simply
  build the corresponding subdirectory. We can also build the entire build
  configuration if we want to. For example:</p>

  <pre>$ b build-gcc/hello/

$ b build-clang/</pre>

  <div class="note">
  <p>In case you've already looked into <a
  href="../../bpkg/doc/bpkg.xhtml"><code><b>bpkg(1)</b></code></a> and/or <a
  href="../../bdep/doc/bdep.xhtml"><code><b>bdep(1)</b></code></a>, their
  build configurations are actually these same amalgamations (created
  underneath with the <code>create</code> meta-operation) and their packages
  are just subprojects. And with this understanding you are free to interact
  with them directly using the build system interface.</p>
  </div>

  <h2 id="intro-lang">1.8 Buildfile Language</h2>

  <p>By now we should have a good overall sense of what writing
  <code>buildfiles</code> feels like. In this section we will examine the
  language in slightly more detail and with more precision.</p>

  <p>Buildfile is primarily a declarative language with support for variables,
  pure functions, repetition (<code>for</code>-loop), and conditional
  inclusion/exclusion (<code>if-else</code>).</p>

  <p>Buildfile is a line-oriented language. That is, every construct ends at
  the end of the line unless escaped with line continuation (trailing
  <code>\</code>). For example:</p>

  <pre>exe{hello}: {hxx cxx}{**} \
  $libs</pre>

  <p>Some lines may start a <i>block</i> if followed by <code>{</code> on the
  next line. Such a block ends with a closing <code>}</code> on a separate
  line. Some types of blocks can nest. For example:</p>

  <pre>if ($cxx.target.class == 'windows')
{
  if ($cxx.target.system == 'ming32')
  {
    ...
  }
}</pre>

  <p>A comment starts with <code>#</code> and everything from this character
  and until the end of the line is ignored. A multi-line comment starts with
  <code>#\</code> on a separate line and ends with the same character
  sequence, again on a separate line. For example:</p>

  <pre># Single line comment.

info 'Hello, World!' # Trailing comment.

#\
Multi-
line
comment.
#\</pre>

  <p>The three primary Buildfile constructs are dependency declaration,
  directive, and variable assignment. We've already used all three but let's
  see another example:</p>

  <pre>include ../libhello/                  # Directive.

exe{hello}: {hxx cxx}{**} lib{hello}  # Dependency declaration.

cxx.poptions += -DNDEBUG              # Variable assignment (append).</pre>

  <p>There is also the scope opening (we've seen one in
  <code>export.build</code>) as well as target-specific and
  prerequisite-specific variable assignment blocks. The latter two are used to
  assign several entity-specific variables at once. For example:</p>

  <pre>details/                          # scope
{
  hxx{*}: install = false
}

hxx{version}:                     # target-specific
{
  dist  = true
  clean = ($src_root != $out_root)
}

exe{test}: file{test.roundtrip}:  # prerequisite-specific
{
  test.stdin  = true
  test.stdout = true
}</pre>

  <p>Variable assignment blocks can be combined with dependency declarations,
  for example:</p>

  <pre>h{config}: in{config}
{
  in.symbol = '@'
  in.substitution = lax

  SYSTEM_NAME = $c.target.system
  SYSTEM_PROCESSOR = $c.target.cpu
}</pre>

  <p>In case of a dependency chain, the block applies to the set of
  prerequisites (note: <i>not targets</i>) before last <code>:</code>. For
  example:</p>

  <pre>./: exe{test}: libue{test}: cxx{test}
{
  bin.whole = false  # Applies to the libue{test} prerequisite.
}</pre>

  <div class="note">
  <p>All prerequisite-specific variables must be assigned at once as part of
  the dependency declaration since repeating the same dependency again
  duplicates the prerequisite rather than references the already existing
  one.</p>

  <p>There is also the target type/pattern-specific variable assignment block,
  for example:</p>

  <pre>exe{*.test}:
{
  test = true
  install = false
}</pre>

  <p>See <a href="#variables">Variables</a> for more information.</p>
  </div>

  <p>Each <code>buildfile</code> is processed linearly with directives
  executed and variables expanded as they are encountered. However, certain
  variables, for example, <code>cxx.poptions</code> are also expanded by rules
  during execution in which case they will "see" the final value set in the
  <code>buildfile</code>.</p>

  <div class="note">
  <p>Unlike GNU <code>make(1)</code>, which has deferred (<code>=</code>) and
  immediate (<code>:=</code>) variable assignments, all assignments in
  <code>build2</code> are immediate. For example:</p>

  <pre>x = x
y = $x
x = X
info $y # Prints 'x', not 'X'.</pre>
  </div>

  <h3 id="intro-lang-expand">1.8.1 Expansion and Quoting</h3>

  <p>While we've discussed variable expansion and lookup earlier, to recap, to
  get the variable's value we use <code>$</code> followed by its name. The
  variable name is first looked up in the current scope (that is, the scope in
  which the expansion was encountered) and, if not found, in the outer scopes,
  recursively.</p>

  <p>There are two other kinds of expansions: function calls and evaluation
  contexts, or <i>eval contexts</i> for short. Let's start with the latter
  since function calls are built on top of eval contexts.</p>

  <p>An eval context is essentially a fragment of a line with additional
  interpretations of certain characters to support value comparison, logical
  operators, and a few other constructs. Eval contexts begin with
  <code>(</code>, end with <code>)</code>, and can nest. Here are a few
  examples:</p>

  <pre>info ($src_root != $out_root)                 # Prints true or false.
info ($src_root == $out_root ? 'in' : 'out')  # Prints in or out.

macos = ($cxx.target.class == 'macos')  # Assigns true or false.
linux = ($cxx.target.class == 'linux')  # Assigns true or false.

if ($macos || $linux)  # Also eval context.
  ...</pre>

  <div class="note">
  <p>Below is the eval context grammar that shows supported operators and
  their precedence.</p>

  <pre>eval:         '(' (eval-comma | eval-qual)? ')'
eval-comma:   eval-ternary (',' eval-ternary)*
eval-ternary: eval-or ('?' eval-ternary ':' eval-ternary)?
eval-or:      eval-and ('||' eval-and)*
eval-and:     eval-comp ('&amp;&amp;' eval-comp)*
eval-comp:    eval-value (('=='|'!='|'&lt;'|'>'|'&lt;='|'>=') eval-value)*
eval-value:   value-attributes? (&lt;value> | eval | '!' eval-value)
eval-qual:    &lt;name> ':' &lt;name>

value-attributes: '[' &lt;key-value-pairs> ']'</pre>

  <p>Note that <code>?:</code> (ternary operator) and <code>!</code> (logical
  not) are right-associative. Unlike C++, all the comparison operators have
  the same precedence. A qualified name cannot be combined with any other
  operator (including ternary) unless enclosed in parentheses. The
  <code>eval</code> option in the <code>eval-value</code> production shall
  contain a single value only (no commas).</p>
  </div>

  <p>A function call starts with <code>$</code> followed by its name and an
  eval context listing its arguments. Note that there is no space between the
  name and <code>(</code>. For example:</p>

  <pre>x =
y = Y

info $empty($x)  # true
info $empty($y)  # false

if $regex.match($y, '[A-Z]')
  ...

p = $src_base/foo.txt

info $path.leaf($src_base)              # foo.txt
info $path.directory($src_base)         # $src_base
info $path.base($path.leaf($src_base))  # foo</pre>

  <p>Note that functions in <code>build2</code> are <i>pure</i> in a sense
  that they do not alter the build state in any way.</p>

  <div class="note">
  <p>Functions in <code>build2</code> are currently defined either by the
  build system core or build system modules and are implemented in C++. In the
  future it will be possible to define custom functions in
  <code>buildfiles</code> (also in C++).</p>
  </div>

  <p>Variable and function names follow the C identifier rules. We can also
  group variables into namespaces and functions into families by combining
  multiple identifiers with <code>.</code>. These rules are used to determine
  the end of the variable name in expansions. If, however, a name is
  recognized as being longer than desired, then we can use the eval context to
  explicitly specify its boundaries. For example:</p>

  <pre>base = foo
name = $(base).txt</pre>

  <p>What is the structure of a variable value? Consider this assignment:</p>

  <pre>x = foo bar</pre>

  <p>The value of <code>x</code> could be a string, a list of two strings, or
  something else entirely. In <code>build2</code> the fundamental, untyped
  value is a <i>list of names</i>. A value can be typed to something else
  later but it always starts as a list of names. So in the above example we
  have a list of two names, <code>foo</code> and <code>bar</code>, the same as
  in this example (notice the extra spaces):</p>

  <pre>x = foo    bar</pre>

  <div class="note">
  <p>The motivation behind going with a list of names instead of a string or a
  list of strings is that at its core we are dealing with targets and their
  prerequisites and it would be natural to make the representation of their
  names (that is, the way we refer to them) the default. Consider the
  following two examples; it would be natural for them to mean the same
  thing:</p>

  <pre>exe{hello}: {hxx cxx}{**}</pre>

  <pre>prereqs = {hxx cxx}{**}
exe{hello}: $prereqs</pre>

  <p>Note also that the name semantics was carefully tuned to be
  <i>reversible</i> to its syntactic representation for common non-name
  values, such as paths, command line options, etc., that are usually found in
  <code>buildfiles</code>.</p>
  </div>

  <p>Names are split into a list at whitespace boundaries with certain other
  characters treated as syntax rather than as part of the value. Here are a
  few example:</p>

  <pre>x = $y          # expansion
x = (a == b)    # eval context
x = {foo bar}   # name generation
x = [null]      # attributes
x = name@value  # pairs
x = # comments</pre>

  <p>The complete set of syntax characters is <code>$(){}[]@#</code> plus
  space and tab. Additionally, <code>*?</code> will be treated as wildcards in
  a name pattern. If instead we need these characters to appear literally as
  part of the value, then we either have to <i>escape</i> or <i>quote</i>
  them.</p>

  <p>To escape a special character, we prefix it with a backslash
  (<code>\</code>; to specify a literal backslash double it). For example:</p>

  <pre>x = \$
y = C:\\Program\ Files</pre>

  <p>Similar to UNIX shells, <code>build2</code> supports single
  (<code>''</code>) and double (<code>""</code>) quoting with roughly the same
  semantics. Specifically, expansions (variable, function call, and eval
  context) and escaping are performed inside double-quoted strings but not in
  single-quoted. Note also that quoted strings can span multiple lines with
  newlines treated literally (unless escaped in double-quoted strings). For
  example:</p>

  <pre>x = "(a != b)"  # true
y = '(a != b)'  # (a != b)

x = "C:\\Program Files"
y = 'C:\Program Files'

t = 'line one
line two
line three'</pre>

  <p>Since quote characters are now also part of the syntax, if you need to
  specify them literally in the value, then they will either have to be
  escaped or quoted. For example:</p>

  <pre>cxx.poptions += -DOUTPUT='"debug"'
cxx.poptions += -DTARGET=\"$cxx.target\"</pre>

  <p>An expansion can be one of two kinds: <i>spliced</i> or
  <i>concatenated</i>. In a spliced expansion the variable, function, or eval
  context is separated from other text with whitespaces. In this case, as the
  name suggests, the resulting list of names is spliced into the value. For
  example:</p>

  <pre>x = 'foo fox'
y = bar $x baz  # Three names: 'bar' 'foo fox' 'baz'.</pre>

  <div class="note">
  <p>This is an important difference compared to the semantics of UNIX shells
  where the result of expansion is re-parsed. In particular, this is the
  reason why you won't see quoted expansions in <code>buildfiles</code> as
  often as in (well-written) shell scripts.</p>
  </div>

  <p>In a concatenated expansion the variable, function, or eval context are
  combined with unseparated text before and/or after the expansion. For
  example:</p>

  <pre>x = 'foo fox'
y = bar$(x)foz  # Single name: 'barfoo foxbaz'</pre>

  <p>A concatenated expansion is typed unless it is quoted. In a typed
  concatenated expansion the parts are combined in a type-aware manner while
  in an untyped &#8211; literally, as string. To illustrate the difference,
  consider this <code>buildfile</code> fragment:</p>

  <pre>info $src_root/foo.txt
info "$src_root/foo.txt"</pre>

  <p>If we run it on a UNIX-like operating system, we will see two identical
  lines, along these lines:</p>

  <pre>/tmp/test/foo.txt
/tmp/test/foo.txt</pre>

  <p>However, if we run it on Windows (which uses backslashes as directory
  separators), we will see the output along these lines:</p>

  <pre>C:\test\foo.txt
C:\test/foo.txt</pre>

  <p>The typed concatenation resulted in a native directory separator because
  <code>dir_path</code> (the <code>src_root</code> type) did the right
  thing.</p>

  <p>Not every typed concatenation is well defined and in certain situations
  we may need to force untyped concatenation with quoting. Options specifying
  header search paths (<code>-I</code>) are a typical case, for example:</p>

  <pre>cxx.poptions =+ "-I$out_root" "-I$src_root"</pre>

  <p>If we were to remove the quotes, we would see the following error:</p>

  <pre>buildfile:6:20: error: no typed concatenation of &lt;untyped> to dir_path
  info: use quoting to force untyped concatenation</pre>

  <h3 id="intro-if-else">1.8.2 Conditions (<code>if-else</code>)</h3>

  <p>The <code>if</code> directive can be used to conditionally exclude
  <code>buildfile</code> fragments from being processed. The conditional
  fragment can be a single (separate) line or a block with the initial
  <code>if</code> optionally followed by a number of <code>elif</code>
  directives and a final <code>else</code>, which together form the
  <code>if-else</code> chain. An <code>if-else</code> block can contain nested
  <code>if-else</code> chains. For example:</p>

  <pre>if ($cxx.target.class == 'linux')
  info 'linux'
elif ($cxx.target.class == 'windows')
{
  if ($cxx.target.system == 'mingw32')
    info 'windows-mingw'
  elif ($cxx.target.system == 'win32-msvc')
    info 'windows-msvc'
  else
    info 'windows-other'
}
else
  info 'other'</pre>

  <p>The <code>if</code> and <code>elif</code> directive names must be
  followed by something that expands to a single, literal <code>true</code> or
  <code>false</code>. This can be a variable expansion, a function call, an
  eval context, or a literal value. For example:</p>

  <pre>if $version.pre_release
  ...

if $regex.match($x, '[A-Z]')
  ...

if ($cxx.target.class == 'linux')
  ...

if false
{
  # disabled fragment
}

x = X
if $x  # Error, must expand to true or false.
  ...</pre>

  <p>There are also <code>if!</code> and <code>elif!</code> directives which
  negate the condition that follows (note that there is no space before
  <code>!</code>). For example:</p>

  <pre>if! $version.pre_release
  ...
elif! $regex.match($x, '[A-Z]')
  ...</pre>

  <p>Note also that there is no notion of variable locality in
  <code>if-else</code> blocks and any value set inside is visible outside. For
  example:</p>

  <pre>if true
{
  x = X
}

info $x  # Prints 'X'.</pre>

  <p>The <code>if-else</code> chains should not be used for conditional
  dependency declarations since this would violate the expectation that all of
  the project's source files are listed as prerequisites, irrespective of the
  configuration.  Instead, use the special <code>include</code>
  prerequisite-specific variable to conditionally include prerequisites into
  the build. For example:</p>

  <pre># Incorrect.
#
if ($cxx.target.class == 'linux')
  exe{hello}: cxx{hello-linux}
elif ($cxx.target.class == 'windows')
  exe{hello}: cxx{hello-win32}

# Correct.
#
exe{hello}: cxx{hello-linux}: include = ($cxx.target.class == 'linux')
exe{hello}: cxx{hello-win32}: include = ($cxx.target.class == 'windows')</pre>

  <h3 id="intro-fir">1.8.3 Repetitions (<code>for</code>)</h3>

  <p>The <code>for</code> directive can be used to repeat the same
  <code>buildfile</code> fragment multiple times, once for each element of a
  list. The fragment to repeat can be a single (separate) line or a block,
  which together form the <code>for</code> loop. A <code>for</code> block can
  contain nested <code>for</code> loops. For example:</p>

  <pre>for n: foo bar baz
{
  exe{$n}: cxx{$n}
}</pre>

  <p>The <code>for</code> directive name must be followed by the variable name
  (called <i>loop variable</i>) that on each iteration will be assigned the
  corresponding element, <code>:</code>, and something that expands to a
  potentially empty list of values. This can be a variable expansion, a
  function call, an eval context, or a literal list as in the above fragment.
  Here is a somewhat more realistic example that splits a space-separated
  environment variable value into names and then generates a dependency
  declaration for each of them:</p>

  <pre>for n: $regex.split($getenv(NAMES), ' +', '')
{
  exe{$n}: cxx{$n}
}</pre>

  <p>Note also that there is no notion of variable locality in
  <code>for</code> blocks and any value set inside is visible outside. At the
  end of the iteration the loop variable contains the value of the last
  element, if any. For example:</p>

  <pre>for x: x X
{
  y = Y
}

info $x  # Prints 'X'.
info $y  # Prints 'Y'.</pre>

  <h2 id="intro-unit-test">1.9 Implementing Unit Testing</h2>

  <p>As an example of how many of these features fit together to implement
  more advanced functionality, let's examine a <code>buildfile</code> that
  provides support for unit testing. This support is added by the <a
  href="../../bdep/doc/bdep-new.xhtml"><code><b>bdep-new(1)</b></code></a>
  command if we specify the <code>unit-tests</code> option when creating
  executable (<code>-t&#160;exe,unit-tests</code>) or library
  (<code>-t&#160;lib,unit-tests</code>) projects. Here is the source
  subdirectory <code>buildfile</code> of an executable created with this
  option:</p>

  <pre>./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...}

# Unit tests.
#
exe{*.test}
{
  test = true
  install = false
}

for t: cxx{**.test...}
{
  d = $directory($t)
  n = $name($t)...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
}

cxx.poptions =+ "-I$out_root" "-I$src_root"</pre>

  <p>The basic idea behind this unit testing arrangement is to keep unit tests
  next to the source code files that they test and automatically recognize and
  build them into test executables without having to manually list each in the
  <code>buildfile</code>. Specifically, if we have <code>hello.hxx</code> and
  <code>hello.cxx</code>, then to add a unit test for this module all we have
  to do is drop the <code>hello.test.cxx</code> source file next to them and
  it will be automatically picked up, built into an executable, and run during
  the <code>test</code> operation.</p>

  <p>As an example, let's say we've renamed <code>hello.cxx</code> to
  <code>main.cxx</code> and factored the printing code into the
  <code>hello.hxx/hello.cxx</code> module that we would like to unit-test.
  Here is the new layout:</p>

  <pre>hello/
├── build
│   └── ...
├── hello
│   ├── hello.cxx
│   ├── hello.hxx
│   ├── hello.test.cxx
│   ├── main.cxx
│   └── buildfile
└── ...</pre>

  <p>Let's examine how this support is implemented in our
  <code>buildifle</code>, line by line. Because now we link
  <code>hello.cxx</code> object code into multiple executables (unit tests and
  the <code>hello</code> program itself), we have to place it into a
  <i>utility library</i>. This is what the first line does (it has to
  explicitly list <code>exe{hello}</code> as a prerequisite of the default
  targets since we now have multiple targets that should be built by
  default):</p>

  <pre>./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...}</pre>

  <p>A utility library (<code><b>u</b></code> in <code>lib<b>u</b>e</code>) is
  a static library that is built for a specific type of a <i>primary
  target</i> (<code><b>e</b></code> in <code>libu<b>e</b></code> for
  executable). If we were building a utility library for a library then we
  would have used the <code>libul{}</code> target type instead. In fact, this
  would be the only difference in the above unit testing implementation if it
  were for a library project instead of an executable:</p>

  <pre>./: lib{hello}: libul{hello}: {hxx cxx}{** -**.test...}

...

# Unit tests.
#
...

for t: cxx{**.test...}
{
  ...

  $d/exe{$n}: libul{hello}: bin.whole = false
}</pre>

  <p>Going back to the first three lines of the executable
  <code>buildfile</code>, notice that we had to exclude source files in the
  <code>*.test.cxx</code> form from the utility library. This makes sense
  since we don't want unit testing code (each with its own
  <code>main()</code>) to end up in the utility library.</p>

  <p>The exclusion pattern, <code>-**.test...</code>, looks a bit cryptic.
  What we have here is a second-level extension (<code>.test</code>) which we
  use to classify our source files as belonging to unit tests. Because it is a
  second-level extension, we have to indicate this fact to the pattern
  matching machinery with the trailing triple dot (meaning "there are more
  extensions coming"). If we didn't do that, <code>.test</code> would have
  been treated as a first-level extension explicitly specified for our source
  files.</p>

  <div class="note">
  <p>If you need to specify a name that does not have an extension, then end
  it with a single dot. For example, for a header <code>utility</code> you
  would write <code>hxx{utility.}</code>. If you need to specify a name with
  an actual trailing dot, then escape it with a double dot, for example,
  <code>hxx{utility..}</code>.</p>
  </div>

  <p>The next couple of lines set target type/pattern-specific variables to
  treat all unit test executables as tests that should not be installed:</p>

  <pre>exe{*.test}:
{
  test = true
  install = false
}</pre>

  <div class="note">
  <p>You may be wondering why we had to escape the second-level
  <code>.test</code> extension in the name pattern above but not here. The
  answer is that these are different kinds of patterns in different contexts.
  In particular, patterns in the target type/pattern-specific variables are
  only matched against target names without regard for extensions. See <a
  href="#name-patterns">Name Patterns</a> for details.</p>
  </div>

  <p>Then we have the <code>for</code>-loop that declares an executable target
  for each unit test source file. The list of these files is generated with a
  name pattern that is the inverse of what we've used for the utility
  library:</p>

  <pre>for t: cxx{**.test...}
{
  d = $directory($t)
  n = $name($t)...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
}</pre>

  <p>In the loop body we first split the test source file into the directory
  (remember, we can have sources, including tests, in subdirectories) and name
  (which contains the <code>.test</code> second-level extension and which we
  immediately escape with <code>...</code>). And then we use these components
  to declare a dependency for the corresponding unit test executable. There is
  nothing here that we haven't already seen except for using variable
  expansions instead of literal names.</p>

  <p>By default utility libraries are linked in the "whole archive" mode where
  every object file from the static library ends up in the resulting
  executable or library. This behavior is what we want when linking the
  primary target but can normally be relaxed for unit tests to speed up
  linking. This is what the last line in the loop does using the
  <code>bin.whole</code> prerequisite-specific variable.</p>

  <div class="note">
  <p>You can easily customize this and other aspects on a test-by-test basis
  by excluding the specific test(s) from the loop and then providing a custom
  implementation. For example:</p>

  <pre>for t: cxx{**.test... -special.test...}
{
  ...
}

./: exe{special.test...}: cxx{special.test...} libue{hello}</pre>

  <p>Note also that if you plan to link any of your unit tests in the whole
  archive mode, then you will also need to exclude the source file containing
  the primary executable's <code>main()</code> from the utility library. For
  example:</p>

  <pre>./: exe{hello}: cxx{main} libue{hello}
libue{hello}: {hxx cxx}{** -main -**.test...}</pre>
  </div>

  <h2 id="intro-diag-debug">1.10 Diagnostics and Debugging</h2>

  <p>Sooner or later we will run into a situation where our
  <code>buildfiles</code> don't do what we expect them to. In this section we
  examine a number of techniques and mechanisms that can help us understand
  the cause of a misbehaving build.</p>

  <p>To perform a build the build system goes through several phases. During
  the <i>load</i> phase the <code>buildfiles</code> are loaded and processed.
  The result of this phase is the in-memory <i>build state</i> that contains
  the scopes, targets, variables, etc., defined by the
  <code>buildfiles</code>. Next, is the <i>match</i> phase during which rules
  are matched to the targets that need to be built, recursively. Finally,
  during the <i>execute</i> phase the matched rules are executed to perform
  the build.</p>

  <p>The load phase is always serial and stops at the first error. In
  contrast, by default, both match and execute are parallel and continue in
  the presence of errors (similar to the "keep going" <code>make</code> mode).
  While beneficial in normal circumstances, during debugging this can lead to
  both interleaved output that is hard to correlate as well as extra noise
  from cascading errors. As a result, for debugging, it is usually helpful to
  run serially and stop at the first error, which can be achieved with the
  <code>--serial-stop|-s</code> option.</p>

  <div class="note">
  <p>The match phase can be temporarily switched to either (serial) load or
  (parallel) execute. The former is used, for example, to load additional
  <code>buildfiles</code> during the <code>dir{}</code> prerequisite to target
  resolution, as described in <a href="#intro-dirs-scopes">Output Directories
  and Scopes</a>. While the latter is used to update generated source code
  (such as headers) that is required to complete the match.</p>
  </div>

  <p>Debugging issues in each phase requires different techniques. Let's start
  with the load phase. As mentioned in <a href="#intro-lang">Build
  Language</a>, <code>buildfiles</code> are processed linearly with directives
  executed and variables expanded as they are encountered. As we have already
  seen, to print a variable value we can use the <code>info</code> directive.
  For example:</p>

  <pre>x = X
info $x</pre>

  <p>This will print something along these lines:</p>

  <pre>buildfile:2:1: info: X</pre>

  <p>Or, if we want to clearly see where the value begins and ends (useful
  when investigating whitespace-related issues):</p>

  <pre>x = " X "
info "'$x'"</pre>

  <p>Which prints:</p>

  <pre>buildfile:2:1: info: ' X '</pre>

  <p>Besides the <code>info</code> directive, there are also
  <code>text</code>, which doesn't print the <code>info:</code> prefix,
  <code>warn</code>, which prints a warning, as well as <code>fail</code>
  which prints an error and causes the build system to exit with an error.
  Here is an example of using each:</p>

  <pre>text 'note: we are about to get an error'
warn 'the error is imminent'
fail 'this is the end'
info 'we will never get here'</pre>

  <p>This will produce the following output:</p>

  <pre>buildfile:1:1: note: we are about to get an error
buildfile:2:1: warning: the error is imminent
buildfile:3:1: error: this is the end</pre>

  <p>If you find yourself writing code like this:</p>

  <pre>if ($cxx.target.class == 'windows')
  fail 'Windows is not supported'</pre>

  <p>Then the <code>assert</code> directive is a more concise way to express
  the same:</p>

  <pre>assert ($cxx.target.class != 'windows') 'Windows is not supported'</pre>

  <p>The assert condition must be something that evaluates to
  <code>true</code> or <code>false</code>, similar to the <code>if</code>
  directive (see <a href="#intro-if-else">Conditions
  (<code>if-else</code>)</a> for details). The description after the condition
  is optional and, similar to <code>if</code>, there is also the
  <code>assert!</code> variant, which fails if the condition is
  <code>true</code>.</p>

  <p>All the diagnostics directives write to <code>stderr</code>. If instead
  we need to write something to <code>stdout</code>, for example, to send some
  information back to our caller, then we can use the <code>print</code>
  directive. For example, this will print the C++ compiler id and its
  target:</p>

  <pre>print "$cxx.id $cxx.target"</pre>

  <div class="note">
  <p>To query the value of a target-specific variable we use the qualified
  name syntax (the <code>eval-qual</code> production) of eval context, for
  example:</p>

  <pre>obj{main}: cxx.poptions += -DMAIN
info $(obj{main}: cxx.poptions)</pre>

  <p>There is no direct way to query the value of a prerequisite-specific
  variable since a prerequisite has no identity. Instead, we can use the
  <code>dump</code> directive discussed next to print the entire dependency
  declaration, including prerequisite-specific variables for each
  prerequisite.</p>
  </div>

  <p>While printing variables values is the most common mechanism for
  diagnosing <code>buildfile</code> issues, sometimes it is also helpful to
  examine targets and scopes. For that we use the <code>dump</code>
  directive.</p>

  <p>Without any arguments, <code>dump</code> prints (to <code>stderr</code>)
  the contents of the scope it was encountered in and at that point of
  processing the <code>buildfile</code>. Its output includes variables,
  targets and their prerequsites, as well as nested scopes, recursively. As an
  example, let's print the source directory scope of our <code>hello</code>
  executable project. Here is its <code>buildfile</code> with the
  <code>dump</code> directive at the end:</p>

  <pre>exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root"

dump</pre>

  <p>This will produce the output along these lines:</p>

  <pre>buildfile:5:1: dump:
  /tmp/hello/hello/
  {
    [strings] cxx.poptions = -I/tmp/hello -I/tmp/hello
    [dir_path] out_base = /tmp/hello/hello/
    [dir_path] src_base = /tmp/hello/hello/

    build{buildfile.}:

    exe{hello.?}: cxx{hello.?}
  }</pre>

  <div class="note">
  <p>The question marks (<code>?</code>) in the dependency declaration mean
  that the file extensions haven't been assigned yet, which happens during the
  match phase.</p>
  </div>

  <p>Instead of printing the entire scope, we can also print individual
  targets by specifying one or more target names in <code>dump</code>. To make
  things more interesting, let's convert our <code>hello</code> project to use
  a utility library, similar to the unit testing setup (<a
  href="#intro-unit-test">Implementing Unit Testing</a>). We will also link to
  the <code>pthread</code> library to see an example of a target-specific
  variable being dumped:</p>

  <pre>exe{hello}: libue{hello}: bin.whole = false
exe{hello}: cxx.libs += -lpthread
libue{hello}: {hxx cxx}{**}

dump exe{hello}</pre>

  <p>The output will look along these lines:</p>

  <pre>buildfile:5:1: dump:
  /tmp/hello/hello/exe{hello.?}:
  {
    [strings] cxx.libs = -lpthread
  }
  /tmp/hello/hello/exe{hello.?}: /tmp/hello/hello/:libue{hello.?}:
  {
    [bool] bin.whole = false
  }</pre>

  <p>The output of <code>dump</code> might look familiar: in <a
  href="#intro-dirs-scopes">Output Directories and Scopes</a> we've used the
  <code>--dump</code> option to print the entire build state, which looks
  pretty similar. In fact, the <code>dump</code> directive uses the same
  mechanism but allows us to print individual scopes and targets.</p>

  <p>There is, however, an important difference to keep in mind:
  <code>dump</code> prints the state of a target or scope at the point in the
  <code>buildfile</code> load phase where it was executed. In contrast, the
  <code>--dump</code> option can be used to print the state after the load
  phase (<code>--dump load</code>) and/or after the match phase (<code>--dump
  match</code>). In particular, the after match printout reflects the changes
  to the build state made by the matching rules, which may include entering of
  additional dependencies, setting of additional variables, resolution of
  prerequsites to targets, assignment of file extensions, etc. As a result,
  while the <code>dump</code> directive should be sufficient in most cases,
  sometimes you may need to use the <code>--dump</code> option to examine the
  build state just before rule execution.</p>

  <p>Let's now move from state to behavior. As we already know, to see the
  underlying commands executed by the build system we use the <code>-v</code>
  options (which is equivalent to <code>--verbose&#160;2</code>). Note,
  however, that these are <i>logical</i> rather than actual commands. You can
  still run them and they should produce the desired result, but in reality
  the build system may have achieved the same result in a different way. To
  see the actual commands we use the <code>-V</code> option instead
  (equivalent to <code>--verbose&#160;3</code>). Let's see the difference in
  an example. Here is what building our <code>hello</code> executable with
  <code>-v</code> might look like:</p>

  <pre>$ b -s -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o</pre>

  <p>And here is the same build with <code>-V</code>:</p>

  <pre>$ b -s -V
g++ -MD -E -fdirectives-only -MF hello.o.t -o hello.o.ii hello.cxx
g++ -E -fpreprocessed -fdirectives-only hello.o.ii
g++ -o hello.o -c -fdirectives-only hello.o.ii
g++ -o hello hello.o</pre>

  <p>From the second listing we can see that in reality <code>build2</code>
  first partially preprocessed <code>hello.cxx</code> while extracting its
  header dependency information. It then preprocessed it fully, which is used
  to extract module dependency information, calculate the checksum for
  ignorable change detection, etc.  When it comes to producing
  <code>hello.o</code>, the build system compiled the partially preprocessed
  output rather than the original <code>hello.cxx</code>. The end result,
  however, is the same as in the first listing.</p>

  <p>Verbosity level <code>3</code> (<code>-V</code>) also triggers printing
  of the build system module configuration information. Here is what we would
  see for the <code>cxx</code> module:</p>

  <pre>cxx hello@/tmp/hello/
  cxx        g++@/usr/bin/g++
  id         gcc
  version    7.2.0 (Ubuntu 7.2.0-1ubuntu1~16.04)
  major      7
  minor      2
  patch      0
  build      (Ubuntu 7.2.0-1ubuntu1~16.04)
  signature  gcc version 7.2.0 (Ubuntu 7.2.0-1ubuntu1~16.04)
  checksum   09b3b59d337eb9a760dd028fa0df585b307e6a49c2bfa00b3[...]
  target     x86_64-linux-gnu
  runtime    libgcc
  stdlib     libstdc++
  c stdlib   glibc
...</pre>

  <p>Verbosity levels higher than <code>3</code> enable build system tracing.
  In particular, level <code>4</code> is useful for understanding why a rule
  doesn't match a target or if it does, why it determined the target to be out
  of date. For example, assuming we have an up-to-date build of our
  <code>hello</code>, let's change a compile option:</p>

  <pre>$ b -s --verbose 4
info: /tmp/hello/dir{hello/} is up to date

$ b -s --verbose 4 config.cxx.poptions+=-DNDEBUG
trace: cxx::compile_rule::apply: options mismatch forcing update
of /tmp/hello/hello/obje{hello.o}
...</pre>

  <p>Higher verbosity levels result in more and more tracing statements being
  printed. These include <code>buildfile</code> loading and parsing,
  prerequisite to target resolution, as well as build system module and
  rule-specific logic.</p>

  <p>Another useful diagnostics option is <code>--mtime-check</code>. When
  specified, the build system performs a number of file modification time
  sanity checks that can be helpful in diagnosing spurious rebuilds.</p>

  <p>If neither state dumps nor behavior analysis are sufficient to understand
  the problem, there is always an option of running the build system under a
  C++ debugger in order to better understand what's going on. This can be
  particularly productive for debugging complex rules.</p>

  <p>Finally, to help with diagnosing the build system performance issues,
  there is the <code>--stat</code> option. It causes <code>build2</code> to
  print various execution statistics which can be useful for pin-pointing the
  bottlenecks. There are also a number of options for tuning the build
  system's performance, such as, the number of jobs to perform in parallel,
  the stack size, queue depths, etc. See the <a
  href="b.xhtml"><code><b>b(1)</b></code></a> man pages for details.</p>

  <h1 id="name-patterns">2 Name Patterns</h1>

  <p>For convenience, in certain contexts, names can be generated with
  shell-like wildcard patterns. A name is a <i>name pattern</i> if its value
  contains one or more unquoted wildcard characters or character sequences.
  For example:</p>

  <pre>./: */                     # All (immediate) subdirectories
exe{hello}: {hxx cxx}{**}  # All C++ header/source files.
pattern = '*.txt'          # Literal '*.txt'.</pre>

  <p>Pattern-based name generation is not performed in certain contexts.
  Specifically, it is not performed in target names where it is interpreted as
  a pattern for target type/pattern-specific variable assignments. For
  example.</p>

  <pre>s = *.txt             # Variable assignment (performed).
./: cxx{*}            # Prerequisite names (performed).
cxx{*}: dist = false  # Target pattern (not performed).</pre>

  <p>In contexts where it is performed, it can be inhibited with quoting, for
  example:</p>

  <pre>pat = 'foo*bar'
./: cxx{'foo*bar'}</pre>

  <p>The following characters are wildcards:</p>

  <pre>*  - match any number of characters (including zero)
?  - match any single character</pre>

  <p>If a pattern ends with a directory separator, then it only matches
  directories. Otherwise, it only matches files. Matches that start with a dot
  (<code>.</code>) are automatically ignored unless the pattern itself also
  starts with this character.</p>

  <p>In addition to the above wildcard characters, <code>**</code> and
  <code>***</code> are recognized as wildcard character sequences. If a
  pattern contains <code>**</code>, then it is matched just like
  <code>*</code> but in all the subdirectories, recursively, but excluding
  directories that contain the <code>.buildignore</code> file. The
  <code>***</code> wildcard behaves like <code>**</code> but also matches the
  start directory itself. For example:</p>

  <pre>exe{hello}: cxx{**}  # All C++ source files recursively.</pre>

  <p>A group-enclosed (<code>{}</code>) pattern value may be followed by
  inclusion/exclusion patterns/matches. A subsequent value is treated as an
  inclusion or exclusion if it starts with a literal, unquoted plus
  (<code>+</code>) or minus (<code>-</code>) sign, respectively. In this case
  the remaining group values, if any, must all be inclusions or exclusions. If
  the second value doesn't start with a plus or minus, then all the group
  values are considered independent with leading pluses and minuses not having
  any special meaning. For regularity as well as to allow patterns without
  wildcards, the first pattern can also start with the plus sign. For
  example:</p>

  <pre>exe{hello}: cxx{f* -foo}            # Exclude foo if exists.
exe{hello}: cxx{f* +bar}            # Include bar if exists.
exe{hello}: cxx{f* -fo?}            # Exclude foo and fox if exist.
exe{hello}: cxx{f* +b* -foo -bar}   # Exclude foo and bar if exist.
exe{hello}: cxx{+f* +b* -foo -bar}  # Same as above.
exe{hello}: cxx{+foo}               # Pattern without wildcards.
exe{hello}: cxx{f* b* -z*}          # Names matching three patterns.</pre>

  <p>Inclusions and exclusions are applied in the order specified and only to
  the result produced up to that point. The order of names in the result is
  unspecified. However, it is guaranteed not to contain duplicates. The first
  pattern and the following inclusions/exclusions must be consistent with
  regards to the type of filesystem entry they match. That is, they should all
  match either files or directories. For example:</p>

  <pre>exe{hello}: cxx{f* -foo +*oo}  # Exclusion has no effect.
exe{hello}: cxx{f* +*oo}       # Ok, no duplicates.
./: {*/ -build}                # Error: exclusion not a directory.</pre>

  <p>As a more realistic example, let's say we want to exclude source files
  that reside in the <code>test/</code> directories (and their subdirectories)
  anywhere in the tree. This can be achieved with the following pattern:</p>

  <pre>exe{hello}: cxx{** -***/test/**}</pre>

  <p>Similarly, if we wanted to exclude all source files that have the
  <code>-test</code> suffix:</p>

  <pre>exe{hello}: cxx{** -**-test}</pre>

  <p>In contrast, the following pattern only excludes such files from the top
  directory:</p>

  <pre>exe{hello}: cxx{** -*-test}</pre>

  <p>If many inclusions or exclusions need to be specified, then an
  inclusion/exclusion group can be used. For example:</p>

  <pre>exe{hello}: cxx{f* -{foo bar}}
exe{hello}: cxx{+{f* b*} -{foo bar}}</pre>

  <p>This is particularly useful if you would like to list the names to
  include or exclude in a variable. For example, this is how we can exclude
  certain files from compilation but still include them as ordinary file
  prerequisites (so that they are still included into the distribution):</p>

  <pre>exc = foo.cxx bar.cxx
exe{hello}: cxx{+{f* b*} -{$exc}} file{$exc}</pre>

  <p>If we want to specify our pattern in a variable, then we have to use the
  explicit inclusion syntax, for example:</p>

  <pre>pat = 'f*'
exe{hello}: cxx{+$pat} # Pattern match.
exe{hello}: cxx{$pat}  # Literal 'f*'.

pat = '+f*'
exe{hello}: cxx{$pat}  # Literal '+f*'.

inc = 'f*'  'b*'
exc = 'f*o' 'b*r'
exe{hello}: cxx{+{$inc} -{$exc}}</pre>

  <p>One common situation that calls for exclusions is auto-generated source
  code. Let's say we have auto-generated command line parser in
  <code>options.hxx</code> and <code>options.cxx</code>. Because of the
  in-tree builds, our name pattern may or may not find these files. Note,
  however, that we cannot just include them as non-pattern prerequisites. We
  also have to exclude them from the pattern match since otherwise we may end
  up with duplicate prerequisites. As a result, this is how we have to handle
  this case provided we want to continue using patterns to find other,
  non-generated source files:</p>

  <pre>exe{hello}: {hxx cxx}{* -options} {hxx cxx}{options}</pre>

  <p>If the name pattern includes an absolute directory, then the pattern
  match is performed in that directory and the generated names include
  absolute directories as well. Otherwise, the pattern match is performed in
  the <i>pattern base</i> directory. In buildfiles this is
  <code>src_base</code> while on the command line &#8211; the current working
  directory. In this case the generated names are relative to the base
  directory. For example, assuming we have the <code>foo.cxx</code> and
  <code>b/bar.cxx</code> source files:</p>

  <pre>exe{hello}: $src_base/cxx{**}  # $src_base/cxx{foo} $src_base/b/cxx{bar}
exe{hello}:           cxx{**}  #           cxx{foo}           b/cxx{bar}</pre>

  <p>Pattern matching as well as inclusion/exclusion logic is target
  type-specific. If the name pattern does not contain a type, then the
  <code>dir{}</code> type is assumed if the pattern ends with a directory
  separator and <code>file{}</code> otherwise.</p>

  <p>For the <code>dir{}</code> target type the trailing directory separator
  is added to the pattern and all the inclusion/exclusion patterns/matches
  that do not already end with one. Then the filesystem search is performed
  for matching directories. For example:</p>

  <pre>./: dir{* -build}  # Search for */, exclude build/.</pre>

  <p>For the <code>file{}</code> and <code>file{}</code>-based target types
  the default extension (if any) is added to the pattern and all the
  inclusion/exclusion patterns/matches that do not already contain an
  extension. Then the filesystem search is performed for matching files.</p>

  <p>For example, the <code>cxx{}</code> target type obtains the default
  extension from the <code>extension</code> variable. Assuming we have the
  following line in our <code>root.build</code>:</p>

  <pre>cxx{*}: extension = cxx</pre>

  <p>And the following in our <code>buildfile</code>:</p>

  <pre>exe{hello}: {cxx}{* -foo -bar.cxx}</pre>

  <p>The pattern match will first search for all the files matching the
  <code>*.cxx</code> pattern in <code>src_base</code> and then exclude
  <code>foo.cxx</code> and <code>bar.cxx</code> from the result. Note also
  that target type-specific decorations are removed from the result. So in the
  above example if the pattern match produces <code>baz.cxx</code>, then the
  prerequisite name is <code>cxx{baz}</code>, not
  <code>cxx{baz.cxx}</code>.</p>

  <p>If the name generation cannot be performed because the base directory is
  unknown, target type is unknown, or the target type is not directory or
  file-based, then the name pattern is returned as is (that is, as an ordinary
  name). Project-qualified names are never considered to be patterns.</p>

  <h1 id="variables">3 Variables</h1>

  <p>Note: this section is a work in progress.</p>

  <p>Note that while expansions in the target and prerequisite-specific
  assignments happen in the corresponding target and prerequisite contexts,
  respectively, for type/pattern-specific assignments they happen in the scope
  context. Plus, a type/pattern-specific prepend/append is applied at the time
  of expansion for the actual target. For example:</p>

  <pre>x = s

file{foo}:              # target
{
  x += t    # s t
  y = $x y  # s t y
}

file{foo}: file{bar}    # prerequisite
{
  x += p    # x t p
  y = $x y  # x t p y
}

file{b*}:               # type/pattern
{
  x += w   # &lt;append w>
  y = $x w # &lt;assign s w>
}

x = S

info $(file{bar}: x) # S w
info $(file{bar}: y) # s w</pre>

  <h1 id="module-test">4 <code>test</code> Module</h1>

  <p>The targets to be tested as well as the tests/groups from testscripts to
  be run can be narrowed down using the <code>config.test</code> variable.
  While this value is normally specified as a command line override (for
  example, to quickly re-run a previously failed test), it can also be
  persisted in <code>config.build</code> in order to create a configuration
  that will only run a subset of tests by default. For example:</p>

  <pre>b test config.test=foo/exe{driver} # Only test foo/exe{driver} target.
b test config.test=bar/baz         # Only run bar/baz testscript test.</pre>

  <p>The <code>config.test</code> variable contains a list of
  <code>@</code>-separated pairs with the left hand side being the target and
  the right hand side being the testscript id path. Either can be omitted
  (along with <code>@</code>). If the value contains a target type or ends
  with a directory separator, then it is treated as a target name. Otherwise
  &#8211; an id path. The targets are resolved relative to the root scope
  where the <code>config.test</code> value is set. For example:</p>

  <pre>b test config.test=foo/exe{driver}@bar</pre>

  <p>To specify multiple id paths for the same target we can use the pair
  generation syntax:</p>

  <pre>b test config.test=foo/exe{driver}@{bar baz}</pre>

  <p>If no targets are specified (only id paths), then all the targets are
  tested (with the testscript tests to be run limited to the specified id
  paths). If no id paths are specified (only targets), then all the testscript
  tests are run (with the targets to be tested limited to the specified
  targets). An id path without a target applies to all the targets being
  considered.</p>

  <p>A directory target without an explicit target type (for example,
  <code>foo/</code>) is treated specially. It enables all the tests at and
  under its directory. This special treatment can be inhibited by specifying
  the target type explicitly (for example, <code>dir{foo/}</code>).</p>

  <h1 id="module-version">5 <code>version</code> Module</h1>

  <p>A project can use any version format as long as it meets the package
  version requirements. The toolchain also provides additional functionality
  for managing projects that conform to the <code>build2</code> <i>standard
  version</i> format. If you are starting a new project that uses
  <code>build2</code>, you are strongly encouraged to use this versioning
  scheme. It is based on much thought and, often painful, experience. If you
  decide not to follow this advice, you are essentially on your own when
  version management is concerned.</p>

  <p>The standard <code>build2</code> project version conforms to <a
  href="http://semver.org">Semantic Versioning</a> and has the following
  form:</p>

  <pre>&lt;major>.&lt;minor>.&lt;patch>[-&lt;prerel>]</pre>

  <p>For example:</p>

  <pre>1.2.3
1.2.3-a.1
1.2.3-b.2</pre>

  <p>The <code>build2</code> package version that uses the standard project
  version will then have the following form (<i>epoch</i> is the versioning
  scheme version and <i>revision</i> is the package revision):</p>

  <pre>[+&lt;epoch>-]&lt;major>.&lt;minor>.&lt;patch>[-&lt;prerel>][+&lt;revision>]</pre>

  <p>For example:</p>

  <pre>1.2.3
1.2.3+1
+2-1.2.3-a.1+2</pre>

  <p>The <i>major</i>, <i>minor</i>, and <i>patch</i> should be numeric values
  between <code>0</code> and <code>99999</code> and all three cannot be zero
  at the same time. For initial development it is recommended to use
  <code>0</code> for <i>major</i>, start with version <code>0.1.0</code>, and
  change to <code>1.0.0</code> once things stabilize.</p>

  <p>In the context of C and C++ (or other compiled languages), you should
  increment <i>patch</i> when making binary-compatible changes, <i>minor</i>
  when making source-compatible changes, and <i>major</i> when making breaking
  changes. While the binary compatibility must be set in stone, the source
  compatibility rules can sometimes be bent. For example, you may decide to
  make a breaking change in a rarely used interface as part of a minor release
  (though this is probably still a bad idea if your library is widely depended
  upon). Note also that in the context of C++ deciding whether a change is
  binary-compatible is a non-trivial task. There are resources that list the
  rules but no automated tooling yet. If unsure, increment <i>minor</i>.</p>

  <p>If present, the <i>prerel</i> component signifies a pre-release. Two
  types of pre-releases are supported by the standard versioning scheme:
  <i>final</i> and <i>snapshot</i> (non-pre-release versions are naturally
  always final). For final pre-releases the <i>prerel</i> component has the
  following form:</p>

  <pre>(a|b).&lt;num></pre>

  <p>For example:</p>

  <pre>1.2.3-a.1
1.2.3-b.2</pre>

  <p>The letter '<code>a</code>' signifies an alpha release and
  '<code>b</code>' &#8211; beta. The alpha/beta numbers (<i>num</i>) should be
  between 1 and 499.</p>

  <p>Note that there is no support for release candidates. Instead, it is
  recommended that you use later-stage beta releases for this purpose (and, if
  you wish, call them "release candidates" in announcements, etc).</p>

  <p>What version should be used during development? The common approach is to
  increment to the next version and use that until the release. This has one
  major drawback: if we publish intermediate snapshots (for example, for
  testing) they will all be indistinguishable both between each other and,
  even worse, from the final release. One way to remedy this is to increment
  the pre-release number before each publication. However, unless automated,
  this will be burdensome and error-prone. Also, there is a real possibility
  of running out of version numbers if, for example, we do continuous
  integration by publishing and testing each commit.</p>

  <p>To address this, the standard versioning scheme supports <i>snapshot
  pre-releases</i> with the <i>prerel</i> component having the following
  extended form:</p>

  <pre>(a|b).&lt;num>.&lt;snapsn>[.&lt;snapid>]</pre>

  <p>For example:</p>

  <pre>1.2.3-a.1.20180319215815.26efe301f4a7</pre>

  <p>In essence, a snapshot pre-release is after the previous final release
  but before the next (<code>a.1</code> and, perhaps, <code>a.2</code> in the
  above example) and is uniquely identified by the snapshot sequence number
  (<i>snapsn</i>) and optional snapshot id (<i>snapid</i>).</p>

  <p>The <i>num</i> component has the same semantics as in the final
  pre-releases except that it can be <code>0</code>. The <i>snapsn</i>
  component should be either the special value '<code>z</code>' or a numeric,
  non-zero value that increases for each subsequent snapshot. It must not be
  longer than 16 decimal digits. The <i>snapid</i> component, if present,
  should be an alpha-numeric value that uniquely identifies the snapshot. It
  is not required for version comparison (<i>snapsn</i> should be sufficient)
  and is included for reference. It must not be longer than 16 characters.</p>

  <p>Where do the snapshot number and id come from? Normally from the version
  control system. For example, for <code>git</code>, <i>snapsn</i> is the
  commit date in the <i>YYYYMMDDhhmmss</i> form and UTC timezone and
  <i>snapid</i> is a 12-character abbreviated commit id. As discussed below,
  the <code>build2</code> <code>version</code> module extracts and manages all
  this information automatically (but the use of <code>git</code> commit dates
  is not without limitations; see below for details).</p>

  <p>The special '<code>z</code>' <i>snapsn</i> value identifies the
  <i>latest</i> or <i>uncommitted</i> snapshot. It is chosen to be greater
  than any other possible <i>snapsn</i> value and its use is discussed further
  below.</p>

  <p>As an illustration of this approach, let's examine how versions change
  during the lifetime of a project:</p>

  <pre>0.1.0-a.0.z     # development after a.0
0.1.0-a.1       # pre-release
0.1.0-a.1.z     # development after a.1
0.1.0-a.2       # pre-release
0.1.0-a.2.z     # development after a.2
0.1.0-b.1       # pre-release
0.1.0-b.1.z     # development after b.1
0.1.0           # release
0.1.1-b.0.z     # development after b.0 (bugfix)
0.2.0-a.0.z     # development after a.0
0.1.1           # release (bugfix)
1.0.0           # release (jumped straight to 1.0.0)
...</pre>

  <p>As shown in the above example, there is nothing wrong with "jumping" to a
  further version (for example, from alpha to beta, or from beta to release,
  or even from alpha to release). We cannot, however, jump backwards (for
  example, from beta back to alpha). As a result, a sensible strategy is to
  start with <code>a.0</code> since it can always be upgraded (but not
  downgrade) at a later stage.</p>

  <p>When it comes to the version control systems, the recommended workflow is
  as follows: The change to the final version should be the last commit in the
  (pre-)release. It is also a good idea to tag this commit with the project
  version. A commit immediately after that should change the version to a
  snapshot, "opening" the repository for development.</p>

  <p>The project version without the snapshot part can be represented as a
  64-bit decimal value comparable as integers (for example, in preprocessor
  directives). The integer representation has the following form:</p>

  <pre>AAAAABBBBBCCCCCDDDE

AAAAA - major
BBBBB - minor
CCCCC - patch
DDD   - alpha / beta (DDD + 500)
E     - final (0) / snapshot (1)</pre>

  <p>If the <i>DDDE</i> value is not zero, then it signifies a pre-release. In
  this case one is subtracted from the <i>AAAAABBBBBCCCCC</i> value. An alpha
  number is stored in <i>DDD</i> as is while beta &#8211; incremented by
  <code>500</code>. If <i>E</i> is <code>1</code>, then this is a snapshot
  after <i>DDD</i>.</p>

  <p>For example:</p>

  <pre>             AAAAABBBBBCCCCCDDDE
0.1.0        0000000001000000000
0.1.2        0000000001000020000
1.2.3        0000100002000030000
2.2.0-a.1    0000200001999990010
3.0.0-b.2    0000299999999995020
2.2.0-a.1.z  0000200001999990011</pre>

  <p>A project that uses standard versioning can rely on the
  <code>build2</code> <code>version</code> module to simplify and automate
  version managements. The <code>version</code> module has two primary
  functions: eliminate the need to change the version anywhere except in the
  project's manifest file and automatically extract and propagate the snapshot
  information (serial number and id).</p>

  <p>The <code>version</code> module must be loaded in the project's
  <code>bootstrap.build</code>. While being loaded, it reads the project's
  manifest and extracts its version (which must be in the standard form). The
  version is then parsed and presented as the following build system variables
  (which can be used in the buildfiles):</p>

  <pre>[string] version                     # +2-1.2.3-b.4.1234567.deadbeef+3

[string] version.project             # 1.2.3-b.4.1234567.deadbeef
[uint64] version.project_number      # 0000100002000025041
[string] version.project_id          # 1.2.3-b.4.deadbeef

[bool]   version.stub                # false (true for 0[+&lt;revision>])

[uint64] version.epoch               # 2

[uint64] version.major               # 1
[uint64] version.minor               # 2
[uint64] version.patch               # 3

[bool]   version.alpha               # false
[bool]   version.beta                # true
[bool]   version.pre_release         # true
[string] version.pre_release_string  # b.4
[uint64] version.pre_release_number  # 4

[bool]   version.snapshot            # true
[uint64] version.snapshot_sn         # 1234567
[string] version.snapshot_id         # deadbeef
[string] version.snapshot_string     # 1234567.deadbeef
[bool]   version.snapshot_committed  # true

[uint64] version.revision            # 3</pre>

  <p>As a convenience, the <code>version</code> module also extract the
  <code>summary</code> and <code>url</code> manifest values and sets them as
  the following build system variables (this additional information is used,
  for example, when generating the <code>pkg-config</code> files):</p>

  <pre>[string] project.summary
[string] project.url</pre>

  <p>If the version is the latest snapshot (that is, it's in the
  <code>.z</code> form), then the <code>version</code> module extracts the
  snapshot information from the version control system used by the project.
  Currently only <code>git</code> is supported with the following
  semantics.</p>

  <p>If the project's source directory (<code>src_root</code>) is clean (that
  is, it does not have any changed or untracked files), then the
  <code>HEAD</code> commit date and id are used as the snapshot number and id,
  respectively.</p>

  <p>Otherwise (that is, the project is between commits), the
  <code>HEAD</code> commit date is incremented by one second and is used as
  the snapshot number with no id. While we can work with such uncommitted
  snapshots locally, we should not distribute or publish them since they are
  indistinguishable from each other.</p>

  <p>Finally, if the project does not have <code>HEAD</code> (that is, the
  project has no commits yet), the special <code>19700101000000</code> (UNIX
  epoch) commit date is used.</p>

  <p>The use of <code>git</code> commit dates for snapshot ordering has its
  limitations: they have one second resolution which means it is possible to
  create two commits with the same date (but not the same commit id and thus
  snapshot id). We also need all the committers to have a reasonably accurate
  clock. Note, however, that in case of a commit date clash/ordering issue, we
  still end up with distinct versions (because of the commit id) &#8211; they
  are just not ordered correctly. As a result, we feel that the risks are
  justified when the only alternative is manual version management (which is
  always an option, nevertheless).</p>

  <p>When we prepare a distribution of a snapshot, the <code>version</code>
  module automatically adjusts the package name to include the snapshot
  information as well as patches the manifest file in the distribution with
  the snapshot number and id (that is, replacing <code>.z</code> in the
  version value with the actual snapshot information). The result is a package
  that is specific to this commit.</p>

  <p>Besides extracting the version information and making it available as
  individual components, the <code>version</code> module also provide rules
  for installing the manifest file as well as automatically generating version
  headers (or other similar version-based files).</p>

  <p>By default the project's <code>manifest</code> file is installed as
  documentation, just like other <code>doc{</code>} targets (thus replacing
  the <code>version</code> file customarily shipped in the project root
  directory). The manifest installation rule in the <code>version</code>
  module in addition patches the installed manifest file with the actual
  snapshot number and id, just like during the preparation of
  distributions.</p>

  <p>The version header rule is based on the <a
  href="#module-in"><code>in</code></a> module rule and can be used to
  preprocesses a template file with version information. While it is usually
  used to generate C/C++ version headers (thus the name), it can really
  generate any kind of files.</p>

  <p>The rule matches a <code>file</code>-based target that has the
  corresponding <code>in</code> prerequisite and also depends on the project's
  <code>manifest</code> file. As an example, let's assume we want to
  auto-generate a header called <code>version.hxx</code> for our
  <code>libhello</code> library. To accomplish this we add the
  <code>version.hxx.in</code> template as well as something along these lines
  to our <code>buildfile</code>:</p>

  <pre>lib{hello}: ... hxx{version}

hxx{version}: in{version} $src_root/file{manifest}
{
  dist = true
}</pre>

  <p>The header rule is a line-based preprocessor that substitutes fragments
  enclosed between (and including) a pair of dollar signs (<code>$</code>)
  with <code>$$</code> being the escape sequence (see the <a
  href="#module-in"><code>in</code></a> module for details). As an example,
  let's assume our <code>version.hxx.in</code> contains the following
  lines:</p>

  <pre>#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#endif</pre>

  <p>If our <code>libhello</code> is at version <code>1.2.3</code>, then the
  generated <code>version.hxx</code> will look like this:</p>

  <pre>#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#endif</pre>

  <p>The first component after the opening <code>$</code> should be either the
  name of the project itself (like <code>libhello</code> above) or a name of
  one of its dependencies as listed in the manifest. If it is the project
  itself, then the rest can refer to one of the <code>version.*</code>
  variables that we discussed earlier (in reality it can be any variable
  visible from the project's root scope).</p>

  <p>If the name refers to one of the dependecies (that is, projects listed
  with <code>depends:</code> in the manifest), then the following special
  substitutions are recognized:</p>

  <pre>$&lt;name>.version$                           - textual version constraint
$&lt;name>.condition(&lt;VERSION>[,&lt;SNAPSHOT>])$ - numeric satisfaction condition
$&lt;name>.check(&lt;VERSION>[,&lt;SNAPSHOT>])$     - numeric satisfaction check</pre>

  <p>Here <i>VERSION</i> is the version number macro and the optional
  <i>SNAPSHOT</i> is the snapshot number macro. The snapshot is only required
  if you plan to include snapshot information in your dependency
  constraints.</p>

  <p>As an example, let's assume our <code>libhello</code> depends on
  <code>libprint</code> which is reflected with the following line in our
  manifest:</p>

  <pre>depends: libprint >= 2.3.4</pre>

  <p>We also assume that <code>libprint</code> provides its version
  information in the <code>libprint/version.hxx</code> header and uses
  analogous-named macros. Here is how we can add a version check to our
  <code>version.hxx.in</code>:</p>

  <pre>#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#include &lt;libprint/version.hxx>

$libprint.check(LIBPRINT_VERSION)$

#endif</pre>

  <p>After the substitution our <code>version.hxx</code> header will look like
  this:</p>

  <pre>#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#include &lt;libprint/version.hxx>

#ifdef LIBPRINT_VERSION
#  if !(LIBPRINT_VERSION >= 200003000040000ULL)
#    error incompatible libprint version, libprint >= 2.3.4 is required
#  endif
#endif

#endif</pre>

  <p>The <code>version</code> and <code>condition</code> substitutions are the
  building blocks of the <code>check</code> substitution. For example, here is
  how we can implement a check with a customized error message:</p>

  <pre>#if !($libprint.condition(LIBPRINT_VERSION)$)
#  error bad libprint, need libprint $libprint.version$
#endif</pre>

  <p>The <code>version</code> module also treats one dependency in a special
  way: if you specify the required version of the build system in your
  manifest, then the module will automatically check it for you. For example,
  if we have the following line in our manifest:</p>

  <pre>depends: * build2 >= 0.5.0</pre>

  <p>And someone tries to build our project with <code>build2</code>
  <code>0.4.0</code>, then they will see an error like this:</p>

  <pre>build/bootstrap.build:3:1: error: incompatible build2 version
  info: running 0.4.0
  info: required 0.5.0</pre>

  <p>What version constraints should be use when depending on other project.
  We start with a simple case where we depend on a release. Let's say
  <code>libprint</code> <code>2.3.0</code> added a feature that we need in our
  <code>libhello</code>. If <code>libprint</code> follows the source/binary
  compatibility guidelines discussed above, then any <code>2.X.Y</code>
  version should work provided <code>X >= 3</code>. And this how we can
  specify it in the manifest:</p>

  <pre>depends: libprint ^2.3.0</pre>

  <p>Let's say we are now working on <code>libhello</code> <code>2.0.0</code>
  and would like to start using features from <code>libprint</code>
  <code>3.0.0</code>. However, currently, only pre-releases of
  <code>3.0.0</code> are available. If you would like to add a dependency on a
  pre-release (most likely from your own pre-release), then the recommendation
  is to only allow a specific version, essentially "expiring" the combination
  as soon as newer versions become available. For example:</p>

  <pre>version: 2.0.0-b.1
depends: libprint == 3.0.0-b.2</pre>

  <p>Finally, let's assume we are feeling adventerous and would like to test
  development snapshots of <code>libprint</code> (most likey from our own
  snapshots). In this case the recommendation is to only allow a snapshot
  range for a specific pre-release with the understanding and a warning that
  no compatibility between snapshot versions is guaranteed. For example:</p>

  <pre>version: 2.0.0-b.1.z
depends: libprint [3.0.0-b.2.1 3.0.0-b.3)</pre>

  <h1 id="module-bin">6 <code>bin</code> Module</h1>

  <p>Coming soon.</p>

  <h1 id="module-cxx">7 <code>cxx</code> Module</h1>

  <p>This chapter describes the <code>cxx</code> build system module which
  provides the C++ compilation and linking support. Most of its functionality,
  however, is provided by the <code>cc</code> module, a common implementation
  for the C-family languages.</p>

  <h2 id="cxx-modules">7.1 C++ Modules Support</h2>

  <p>This section describes the build system support for C++ modules.</p>

  <h3 id="cxx-modules-intro">7.1.1 Modules Introduction</h3>

  <p>The goal of this section is to provide a practical introduction to C++
  Modules and to establish key concepts and terminology.</p>

  <p>A pre-modules C++ program or library consists of one or more
  <i>translation units</i> which are customarily referred to as C++ source
  files. Translation units are compiled to <i>object files</i> which are then
  linked together to form a program or library.</p>

  <p>Let's also recap the difference between an <i>external name</i> and a
  <i>symbol</i>: External names refer to language entities, for example
  classes, functions, and so on. The <i>external</i> qualifier means they are
  visible across translation units.</p>

  <p>Symbols are derived from external names for use inside object files. They
  are the cross-referencing mechanism for linking a program from multiple,
  separately-compiled translation units. Not all external names end up
  becoming symbols and symbols are often <i>decorated</i> with additional
  information, for example, a namespace. We often talk about a symbol having
  to be satisfied by linking an object file or a library that provides it.
  Similarly, duplicate symbol issues may arise if more than one object file or
  library provides the same symbol.</p>

  <p>What is a C++ module? It is hard to give a single but intuitive answer to
  this question.  So we will try to answer it from three different
  perspectives: that of a module consumer, a module producer, and a build
  system that tries to make those two play nice. But we can make one thing
  clear at the outset: modules are a <i>language-level</i> not a
  preprocessor-level mechanism; it is <code>import</code>, not
  <code>#import</code>.</p>

  <p>One may also wonder why C++ modules, what are the benefits? Modules offer
  isolation, both from preprocessor macros and other modules' symbols. Unlike
  headers, modules require explicit exportation of entities that will be
  visible to the consumers. In this sense they are a <i>physical design
  mechanism</i> that forces us to think how we structure our code. Modules
  promise significant build speedups since importing a module, unlike
  including a header, should be essentially free. Modules are also the first
  step to not needing the preprocessor in most translation units. Finally,
  modules have a chance of bringing to mainstream reliable and easy to setup
  distributed C++ compilation, since with modules build systems can make sure
  compilers on the local and remote hosts are provided with identical
  inputs.</p>

  <p>To refer to a module we use a <i>module name</i>, a sequence of
  dot-separated identifiers, for example <code>hello.core</code>. While the
  specification does not assign any hierarchical semantics to this sequence,
  it is customary to refer to <code>hello.core</code> as a submodule of
  <code>hello</code>. We discuss submodules and provide the module naming
  guidelines below.</p>

  <p>From a consumer's perspective, a module is a collection of external
  names, called <i>module interface</i>, that become <i>visible</i> once the
  module is imported:</p>

  <pre>import hello.core</pre>

  <p>What exactly does <i>visible</i> mean? To quote the standard: <i>An
  import-declaration makes exported declarations [...] visible to name lookup
  in the current translation unit, in the same namespaces and contexts [...].
  [ Note: The entities are not redeclared in the translation unit containing
  the module import declaration. -- end note ]</i> One intuitive way to think
  about this visibility is <i>as if</i> there were only a single translation
  unit for the entire program that contained all the modules as well as all
  their consumers. In such a translation unit all the names would be visible
  to everyone in exactly the same way and no entity would be redeclared.</p>

  <p>This visibility semantics suggests that modules are not a name scoping
  mechanism and are orthogonal to namespaces. Specifically, a module can
  export names from any number of namespaces, including the global namespace.
  While the module name and its namespace names need not be related, it
  usually makes sense to have a parallel naming scheme, as discussed below.
  Finally, the <code>import</code> declaration does not imply any additional
  visibility for names declared inside namespaces. Specifically, to access
  such names we must continue using the standard mechanisms, such as
  qualification or using declaration/directive.  For example:</p>

  <pre>import hello.core;        // Exports hello::say().

say ();                   // Error.
hello::say ();            // Ok.

using namespace hello;
say ();                   // Ok.</pre>

  <p>Note also that from the consumer's perspective a module does not provide
  any symbols, only C++ entity names. If we use names from a module, then we
  may have to satisfy the corresponding symbols using the usual mechanisms:
  link an object file or a library that provides them. In this respect,
  modules are similar to headers and as with headers, module's use is not
  limited to libraries; they make perfect sense when structuring programs.
  Furthermore, a library may also have private or implementation modules that
  are not meant to be consumed by the library's users.</p>

  <p>The producer perspective on modules is predictably more complex. In
  pre-modules C++ we only had one kind of translation unit (or source file).
  With modules there are three kinds: <i>module interface unit</i>, <i>module
  implementation unit</i>, and the original kind which we will call a
  <i>non-module translation unit</i>.</p>

  <p>From the producer's perspective, a module is a collection of module
  translation units: one interface unit and zero or more implementation units.
  A simple module may consist of just the interface unit that includes
  implementations of all its functions (not necessarily inline). A more
  complex module may span multiple implementation units.</p>

  <p>A translation unit is a module interface unit if it contains an
  <i>exporting module declaration</i>:</p>

  <pre>export module hello.core;</pre>

  <p>A translation unit is a module implementation unit if it contains a
  <i>non-exporting module declaration</i>:</p>

  <pre>module hello.core;</pre>

  <p>While module interface units may use the same file extension as normal
  source files, we recommend that a different extension be used to distinguish
  them as such, similar to header files. While the compiler vendors suggest
  various (and predictably different) extensions, our recommendation is
  <code>.mxx</code> for the <code>.hxx/.cxx</code> source file naming and
  <code>.mpp</code> for <code>.hpp/.cpp</code>. And if you are using some
  other naming scheme, then perhaps now is a good opportunity to switch to one
  of the above. Continuing using the source file extension for module
  implementation units appears reasonable and that's what we recommend.</p>

  <p>A module declaration (exporting or non-exporting) starts a <i>module
  purview</i> that extends until the end of the module translation unit. Any
  name declared in a module's purview <i>belongs</i> to said module. For
  example:</p>

  <pre>#include &lt;string>                // Not in purview.

export module hello.core;        // Start of purview.

void
say_hello (const std::string&amp;);  // In purview.</pre>

  <p>A name that belongs to a module is <i>invisible</i> to the module's
  consumers unless it is <i>exported</i>. A name can be declared exported only
  in a module interface unit, only in the module's purview, and there are
  several syntactic ways to accomplish this. We can start the declaration with
  the <code>export</code> specifier, for example:</p>

  <pre>export module hello.core;

export enum class volume {quiet, normal, loud};

export void
say_hello (const char*, volume);</pre>

  <p>Alternatively, we can enclose one or more declarations into an
  <i>exported group</i>, for example:</p>

  <pre>export module hello.core;

export
{
  enum class volume {quiet, normal, loud};

  void
  say_hello (const char*, volume);
}</pre>

  <p>Finally, if a namespace definition is declared exported, then every name
  in its body is exported, for example:</p>

  <pre>export module hello.core;

export namespace hello
{
  enum class volume {quiet, normal, loud};

  void
  say (const char*, volume);
}

namespace hello
{
  void
  impl (const char*, volume); // Not exported.
}</pre>

  <p>Up until now we've only been talking about names belonding to a module.
  What about the corresponding symbols? For exported names, the resulting
  symbols would be the same as if those names were declared outside of a
  module's purview (or as if no modules were used at all). Non-exported names,
  on the other hand, have <i>module linkage</i>: their symbols can be resolved
  from this module's units but not from other translation units. They also
  cannot clash with symbols for identical names from other modules (and
  non-modules). This is usually achieved by decorating the non-exported
  symbols with the module name.</p>

  <p>This ownership model has an important backwards compatibility
  implication: a library built with modules enabled can be linked to a program
  that still uses headers. And even the other way around: we can build and use
  a module for a library that was built with headers.</p>

  <p>What about the preprocessor? Modules do not export preprocessor macros,
  only C++ names. A macro defined in the module interface unit cannot affect
  the module's consumers. And macros defined by the module's consumers cannot
  affect the module interface they are importing. In other words, module
  producers and consumers are isolated from each other when the preprocessor
  is concerned. For example, consider this module interface:</p>

  <pre>export module hello;

#ifndef SMALL
#define HELLO
export void say_hello (const char*);
#endif</pre>

  <p>And its consumer:</p>

  <pre>// module consumer
//
#define SMALL       // No effect.
import hello;

#ifdef HELLO        // Not defined.
...
#endif</pre>

  <p>This is not to say that the preprocessor cannot be used by either, it
  just doesn't "leak" through the module interface. One practical implication
  of this model is the insignificance of the import order.</p>

  <p>If a module imports another module in its purview, the imported module's
  names are not made automatically visible to the consumers of the importing
  module. This is unlike headers and can be surprising. Consider this module
  interface as an example:</p>

  <pre>export module hello;

import std.core;

export void
say_hello (const std::string&amp;);</pre>

  <p>And its consumer:</p>

  <pre>import hello;

int
main ()
{
  say_hello ("World");
}</pre>

  <p>This example will result in a compile error and the diagnostics may
  confusingly indicate that there is no known conversion from a C string to
  "something" called <code>std::string</code>. But with the understanding of
  the difference between <code>import</code> and <code>#include</code> the
  reason should be clear: while the module interface "sees"
  <code>std::string</code> (because it imported its module), we (the consumer)
  do not (since we did not). So the fix is to explicitly import
  <code>std.core</code>:</p>

  <pre>import std.core;
import hello;

int
main ()
{
  say_hello ("World");
}</pre>

  <p>A module, however, can choose to re-export a module it imports. In this
  case, all the names from the imported module will also be visible to the
  importing module's consumers. For example, with this change to the module
  interface the first version of our consumer will compile without errors
  (note that whether this is a good design choice is debatable, as discussed
  below):</p>

  <pre>export module hello;

export import std.core;

export void
say_hello (const std::string&amp;);</pre>

  <p>One way to think of a re-export is <i>as if</i> an import of a module
  also "injects" all the imports said module re-exports, recursively. That's
  essentially how most compilers implement it.</p>

  <p>Module re-export is the mechanism for assembling bigger modules out of
  submodules. As an example, let's say we had the <code>hello.core</code>,
  <code>hello.basic</code>, and <code>hello.extra</code> modules. To make life
  easier for users that want to import all of them we can create the
  <code>hello</code> module that re-exports the three:</p>

  <pre>export module hello;

export
{
  import hello.core;
  import hello.basic;
  import hello.extra;
}</pre>

  <p>Besides starting a module purview, a non-exporting module declaration in
  the implementation unit makes non-internal linkage names declared or made
  visible in the <i>interface purview</i> also visible in the
  <i>implementation purview</i>. In this sense non-exporting module
  declaration acts as an extended <code>import</code>. For example:</p>

  <pre>import hello.impl;          // Not visible (exports impl()).

void
extra_impl ();              // Not visible.

export module hello.extra;  // Start of interface purview.

import hello.core;          // Visible (exports core()).

void
extra ();                   // Visible.

static void
extra2 ();                  // Not visible (internal linkage).</pre>

  <p>And this is the implementation unit:</p>

  <pre>module hello.extra;         // Start of implementation purview.

void
f ()
{
  impl ();        // Error.
  extra_impl ();  // Error.
  core ();        // Ok.
  extra ();       // Ok.
  extra2 ();      // Error.
}</pre>

  <p>In particular, this means that while the relative order of imports is not
  significant, the placement of imports in the module interface unit relative
  to the module declaration can be.</p>

  <p>The final perspective that we consider is that of the build system. From
  its point of view the central piece of the module infrastructure is the
  <i>binary module interface</i>: a binary file that is produced by compiling
  the module interface unit and that is required when compiling any
  translation unit that imports this module as well as the module's
  implementation units.</p>

  <p>Then, in a nutshell, the main functionality of a build system when it
  comes to modules support is figuring out the order in which all the
  translation units should be compiled and making sure that every compilation
  process is able to find the binary module interfaces it needs.</p>

  <p>Predictably, the details are more complex. Compiling a module interface
  unit produces two outputs: the binary module interface and the object file.
  The latter contains object code for non-inline functions, global variables,
  etc., that the interface unit may define. This object file has to be linked
  when producing any binary (program or library) that uses this module.</p>

  <p>Also, all the compilers currently implement module re-export as a shallow
  reference to the re-exported module name which means that their binary
  interfaces must be discoverable as well, recursively. In fact, currently,
  all the imports are handled like this, though a different implementation is
  at least plausible, if unlikely.</p>

  <p>While the details vary between compilers, the contents of the binary
  module interface can range from a stream of preprocessed tokens to something
  fairly close to object code. As a result, binary interfaces can be sensitive
  to the compiler options and if the options used to produce the binary
  interface (for example, when building a library) are sufficiently different
  compared to the ones used when compiling the module consumers, the binary
  interface may be unusable. So while a build system should strive to reuse
  existing binary interfaces, it should also be prepared to compile its own
  versions "on the side".</p>

  <p>This also suggests that binary module interfaces are not a distribution
  mechanism and should probably not be installed. Instead, we should install
  and distribute module interface sources and build systems should be prepared
  to compile them, again, on the side.</p>

  <h3 id="cxx-modules-build">7.1.2 Building Modules</h3>

  <p>Compiler support for C++ Modules is still experimental. As a result, it
  is currently only enabled if the C++ standard is set to
  <code>experimental</code>. After loading the <code>cxx</code> module we can
  check if modules are enabled using the <code>cxx.features.modules</code>
  boolean variable. This is what the relevant <code>root.build</code> fragment
  could look like for a modularized project:</p>

  <pre>cxx.std = experimental

using cxx

assert $cxx.features.modules 'compiler does not support modules'

mxx{*}: extension = mxx
cxx{*}: extension = cxx</pre>

  <p>To support C++ modules the <code>cxx</code> module (build system) defines
  several additional target types. The <code>mxx{}</code> target is a module
  interface unit. As you can see from the above <code>root.build</code>
  fragment, in this project we are using the <code>.mxx</code> extension for
  our module interface files. While you can use the same extension as for
  <code>cxx{}</code> (source files), this is not recommended since some
  functionality, such as wildcard patterns, will become unusable.</p>

  <p>The <code>bmi{}</code> group and its <code>bmie{}</code>,
  <code>bmia{}</code>, and <code>bmis{}</code> members are used to represent
  binary module interfaces targets. We normally do not need to mention them
  explicitly in our buildfiles except, perhaps, to specify additional, module
  interface-specific compile options. We will see some examples of this
  below.</p>

  <p>To build a modularized executable or library we simply list the module
  interfaces as its prerequisites, just as we do for source files. As an
  example, let's build the <code>hello</code> program that we have started in
  the introduction (you can find the complete project in the <a
  href="https://build2.org/pkg/hello">Hello Repository</a> under
  <code>mhello</code>). Specifically, we assume our project contains the
  following files:</p>

  <pre>// file: hello.mxx (module interface)

export module hello;

import std.core;

export void
say_hello (const std::string&amp;);</pre>

  <pre>// file: hello.cxx (module implementation)

module hello;

import std.io;

using namespace std;

void
say_hello (const string&amp; name)
{
  cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; '!' &lt;&lt; endl;
}</pre>

  <pre>// file: driver.cxx

import std.core;
import hello;

int
main ()
{
  say_hello ("World");
}</pre>

  <p>To build a <code>hello</code> executable from these files we can write
  the following <code>buildfile</code>:</p>

  <pre>exe{hello}: cxx{driver} {mxx cxx}{hello}</pre>

  <p>Or, if you prefer to use wildcard patterns:</p>

  <pre>exe{hello}: {mxx cxx}{*}</pre>

  <p>Alternatively, we can package the module into a library and then link the
  library to the executable:</p>

  <pre>exe{hello}: cxx{driver} lib{hello}
lib{hello}: {mxx cxx}{hello}</pre>

  <p>As you might have surmised from this example, the modules support in
  <code>build2</code> automatically resolves imports to module interface units
  that are specified either as direct prerequisites or as prerequisites of
  library prerequisites.</p>

  <p>To perform this resolution without a significant overhead, the
  implementation delays the extraction of the actual module name from module
  interface units (since not all available module interfaces are necessarily
  imported by all the translation units). Instead, the implementation tries to
  guess which interface unit implements each module being imported based on
  the interface file path. Or, more precisely, a two-step resolution process
  is performed: first a best match between the desired module name and the
  file path is sought and then the actual module name is extracted and the
  correctness of the initial guess is verified.</p>

  <p>The practical implication of this implementation detail is that our
  module interface files must embed a portion of a module name, or, more
  precisely, a sufficient amount of "module name tail" to unambiguously
  resolve all the modules used in a project. Note also that this guesswork is
  only performed for direct module interface prerequisites; for those that
  come from libraries the module names are known and are therefore matched
  exactly.</p>

  <p>As an example, let's assume our <code>hello</code> project had two
  modules: <code>hello.core</code> and <code>hello.extra</code>. While we
  could call our interface files <code>hello.core.mxx</code> and
  <code>hello.extra.mxx</code>, respectively, this doesn't look particularly
  good and may be contrary to the file naming scheme used in our project. To
  resolve this issue the match of module names to file names is made "fuzzy":
  it is case-insensitive, it treats all separators (dots, dashes, underscores,
  etc) as equal, and it treats a case change as an imaginary separator. As a
  result, the following naming schemes will all match the
  <code>hello.core</code> module name:</p>

  <pre>hello-core.mxx
hello_core.mxx
HelloCore.mxx
hello/core.mxx</pre>

  <p>We also don't have to embed the full module name. In our case, for
  example, it would be most natural to call the files <code>core.mxx</code>
  and <code>extra.mxx</code> since they are already in the project directory
  called <code>hello/</code>. This will work since our module names can still
  be guessed correctly and unambiguously.</p>

  <p>If a guess turns out to be incorrect, the implementation issues
  diagnostics and exits with an error before attempting to build anything. To
  resolve this situation we can either adjust the interface file names or we
  can specify the module name explicitly with the <code>cxx.module_name</code>
  variable. The latter approach can be used with interface file names that
  have nothing in common with module names, for example:</p>

  <pre>mxx{foobar}@./: cxx.module_name = hello</pre>

  <p>Note also that standard library modules (<code>std</code> and
  <code>std.*</code>) are treated specially: they are not fuzzy-matched and
  they need not be resolvable to the corresponding <code>mxx{}</code> or
  <code>bmi{}</code> in which case it is assumed they will be resolved in an
  ad hoc way by the compiler. This means that if you want to build your own
  standard library module (for example, because your compiler doesn't yet ship
  one; note that this may not be supported by all compilers), then you have to
  specify the module name explicitly. For example:</p>

  <pre>exe{hello}: cxx{driver} {mxx cxx}{hello} mxx{std-core}

mxx{std-core}@./: cxx.module_name = std.core</pre>

  <p>When C++ modules are enabled and available, the build system makes sure
  the <code>__cpp_modules</code> feature test macro is defined. Currently, its
  value is <code>201703</code> for VC and <code>201704</code> for GCC and
  Clang but this will most likely change in the future.</p>

  <p>One major difference between the current C++ modules implementation in VC
  and the other two compilers is the use of the <code>export module</code>
  syntax to identify the interface units. While both GCC and Clang have
  adopted this new syntax, VC is still using the old one without the
  <code>export</code> keyword. We can use the <code>__cpp_modules</code> macro
  to provide a portable declaration:</p>

  <pre>#if __cpp_modules >= 201704
export
#endif
module hello;</pre>

  <p>Note, however, that the modules support in <code>build2</code> provides
  temporary "magic" that allows us to use the new syntax even with VC (don't
  ask how).</p>

  <h3 id="cxx-modules-symexport">7.1.3 Module Symbols Exporting</h3>

  <p>When building a shared library, some platforms (notably Windows) require
  that we explicitly export symbols that must be accessible to the library
  users. If you don't need to support such platforms, you can thank your lucky
  stars and skip this section.</p>

  <p>When using headers, the traditional way of achieving this is via an
  "export macro" that is used to mark exported APIs, for example:</p>

  <pre>LIBHELLO_EXPORT void
say_hello (const string&amp;);</pre>

  <p>This macro is then appropriately defined (often in a separate "export
  header") to export symbols when building the shared library and to import
  them when building the library's users.</p>

  <p>The introduction of modules changes this in a number of ways, at least as
  implemented by VC (hopefully other compilers will follow suit). While we
  still have to explicitly mark exported symbols in our module interface unit,
  there is no need (and, in fact, no way) to do the same when said module is
  imported. Instead, the compiler automatically treats all such explicitly
  exported symbols (note: symbols, not names) as imported.</p>

  <p>One notable aspect of this new model is the locality of the export macro:
  it is only defined when compiling the module interface unit and is not
  visible to the consumers of the module. This is unlike headers where the
  macro has to have a unique per-library name (that <code>LIBHELLO_</code>
  prefix) because a header from one library can be included while building
  another library.</p>

  <p>We can continue using the same export macro and header with modules and,
  in fact, that's the recommended approach when maintaining the dual,
  header/module arrangement for backwards compatibility (discussed below).
  However, for modules-only codebases, we have an opportunity to improve the
  situation in two ways: we can use a single, keyword-like macro instead of a
  library-specific one and we can make the build system manage it for us thus
  getting rid of the export header.</p>

  <p>To enable this functionality in <code>build2</code> we set the
  <code>cxx.features.symexport</code> boolean variable to <code>true</code>
  before loading the <code>cxx</code> module. For example:</p>

  <pre>cxx.std = experimental

cxx.features.symexport = true

using cxx

...</pre>

  <p>Once enabled, <code>build2</code> automatically defines the
  <code>__symexport</code> macro to the appropriate value depending on the
  platform and the type of library being built. As library authors, all we
  have to do is use it in appropriate places in our module interface units,
  for example:</p>

  <pre>export module hello;

import std.core;

export __symexport void
say_hello (const std::string&amp;);</pre>

  <p>As an aside, you may be wondering why can't a module export automatically
  mean a symbol export? While you will normally want to export symbols of all
  your module-exported names, you may also need to do so for some
  non-module-exported ones. For example:</p>

  <pre>export module foo;

__symexport void
f_impl ();

export __symexport inline void
f ()
{
  f_impl ();
}</pre>

  <p>Furthermore, symbol exporting is a murky area with many limitations and
  pitfalls (such as auto-exporting of base classes). As a result, it would not
  be unreasonable to expect such an automatic module exporting to only further
  muddy the matter.</p>

  <h3 id="cxx-modules-install">7.1.4 Modules Installation</h3>

  <p>As discussed in the introduction, binary module interfaces are not a
  distribution mechanism and installing module interface sources appears to be
  the preferred approach.</p>

  <p>Module interface units are by default installed in the same location as
  headers (for example, <code>/usr/include</code>). However, instead of
  relying on a header-like search mechanism (<code>-I</code> paths, etc.), an
  explicit list of exported modules is provided for each library in its
  <code>.pc</code> (<code>pkg-config</code>) file.</p>

  <p>Specifically, the library's <code>.pc</code> file contains the
  <code>cxx_modules</code> variable that lists all the exported C++ modules in
  the <code>&lt;name>=&lt;path></code> form with <code>&lt;name></code> being
  the module's C++ name and <code>&lt;path></code> &#8211; the module
  interface file's absolute path. For example:</p>

  <pre>Name: libhello
Version: 1.0.0
Cflags:
Libs: -L/usr/lib -lhello

cxx_modules = hello.core=/usr/include/hello/core.mxx hello.extra=/usr/include/hello/extra.mxx</pre>

  <p>Additional module properties are specified with variables in the
  <code>cxx_module_&lt;property>.&lt;name></code> form, for example:</p>

  <pre>cxx_module_symexport.hello.core = true
cxx_module_preprocessed.hello.core = all</pre>

  <p>Currently, two properties are defined. The <code>symexport</code>
  property with the boolean value signals whether the module uses the
  <code>__symexport</code> support discussed above.</p>

  <p>The <code>preprocessed</code> property indicates the degree of
  preprocessing the module unit requires and is used to optimize module
  compilation. Valid values are <code>none</code> (not preprocessed),
  <code>includes</code> (no <code>#include</code> directives in the source),
  <code>modules</code> (as above plus no module declarations depend on the
  preprocessor, for example, <code>#ifdef</code>, etc.), and <code>all</code>
  (the source is fully preprocessed). Note that for <code>all</code> the
  source may still contain comments and line continuations.</p>

  <h3 id="cxx-modules-guidelines">7.1.5 Modules Design Guidelines</h3>

  <p>Modules are a physical design mechanism for structuring and organizing
  our code. Their explicit exportation semantics combined with the way they
  are built make many aspects of creating and consuming modules significantly
  different compared to headers. This section provides basic guidelines for
  designing modules. We start with the overall considerations such as module
  granularity and partitioning into translation units then continue with the
  structure of typical module interface and implementation units. The
  following section discusses practical approaches to modularizing existing
  code and providing dual, header/module interfaces for
  backwards-compatibility.</p>

  <p>Unlike headers, the cost of importing modules should be negligible. As a
  result, it may be tempting to create "mega-modules", for example, one per
  library. After all, this is how the standard library is modularized with its
  fairly large <code>std.core</code> and <code>std.io</code> modules.</p>

  <p>There is, however, a significant drawback to this choice: every time we
  make a change, all consumers of such a mega-module will have to be
  recompiled, whether the change affects them or not. And the bigger the
  module the higher the chance that any given change does not (semantically)
  affect a large portion of the module's consumers. Note also that this is not
  an issue for the standard library modules since they are not expected to
  change often.</p>

  <p>Another, more subtle, issue with mega-modules (which does affect the
  standard library) is the inability to re-export only specific interfaces, as
  will be discussed below.</p>

  <p>The other extreme in choosing module granularity is a large number of
  "mini-modules". Their main drawback is the tediousness of importation by the
  consumers.</p>

  <p>The sensible approach is then to create modules of conceptually-related
  and commonly-used entities possibly complemented with aggregate modules for
  ease of importation. This also happens to be generally good design.</p>

  <p>As an example, let's consider an XML library that provides support for
  both parsing and serialization. Since it is common for applications to only
  use one of the functionalities, it makes sense to provide the
  <code>xml.parser</code> and <code>xml.serializer</code> modules. While it is
  not too tedious to import both, for convenience we could also provide the
  <code>xml</code> module that re-exports the two.</p>

  <p>Once we are past selecting an appropriate granularity for our modules,
  the next question is how to partition them into translation units. A module
  can consist of just the interface unit and, as discussed above, such a unit
  can contain anything an implementation unit can, including non-inline
  function definitions. Some may then view this as an opportunity to get rid
  of the header/source separation and have everything in a single file.</p>

  <p>There are a number of drawbacks with this approach: Every time we change
  anything in the module interface unit, all its consumers have to be
  recompiled. If we keep everything in a single file, then every time we
  change the implementation we trigger recompilations that would have been
  avoided had the implementation been factored out into a separate unit. Note
  that a build system in cooperation with the compiler could theoretically
  avoid such unnecessary recompilations: if the compiler produces identical
  binary interface files when the module interface is unchanged, then the
  build system could detect this and skip recompiling the module's
  consumers.</p>

  <p>A related issue with single-file modules is the reduction in the build
  parallelization opportunities. If the implementation is part of the
  interface unit, then the build system cannot start compiling the module's
  consumers until both the interface and the implementation are compiled. On
  the other hand, had the implementation been split into a separate file, the
  build system could start compiling the module's consumers (as well as the
  implementation unit) as soon as the module interface is compiled.</p>

  <p>Another issues with combining the interface with the implementation is
  the readability of the interface which could be significantly reduced if
  littered with implementation details. We could keep the interface separate
  by moving the implementation to the bottom of the interface file but then we
  might as well move it into a separate file and avoid the unnecessary
  recompilations or parallelization issues.</p>

  <p>The sensible guideline is then to have a separate module implementation
  unit except perhaps for modules with a simple implementation that is mostly
  inline/template. Note that more complex modules may have several
  implementation units, however, based on our granularity guideline, those
  should be rare.</p>

  <p>Once we start writing our first real module the immediate question that
  normally comes up is where to put <code>#include</code> directives and
  <code>import</code> declarations and in what order. To recap, a module unit,
  both interface and implementation, is split into two parts: before the
  module declaration which obeys the usual or "old" translation unit rules and
  after the module declaration which is the module purview. Inside the module
  purview all non-exported declarations have module linkage which means their
  symbols are invisible to any other module (including the global module).
  With this understanding, consider the following module interface:</p>

  <pre>export module hello;

#include &lt;string></pre>

  <p>Do you see the problem? We have included <code>&lt;string></code> in the
  module purview which means all its names (as well as all the names in any
  headers it might include, recursively) are now declared as having the
  <code>hello</code> module linkage. The result of doing this can range from
  silent code blot to strange-looking unresolved symbols.</p>

  <p>The guideline this leads to should be clear: including a header in the
  module purview is almost always a bad idea. There are, however, a few types
  of headers that may make sense to include in the module purview. The first
  are headers that only define preprocessor macros, for example, configuration
  or export headers. There are also cases where we do want the included
  declarations to end up in the module purview. The most common example is
  inline/template function implementations that have been factored out into
  separate files for code organization reasons. As an example, consider the
  following module interface that uses an export header (which presumably sets
  up symbols exporting macros) as well as an inline file:</p>

  <pre>#include &lt;string>

export module hello;

#include &lt;libhello/export.hxx>

export namespace hello
{
  ...
}

#include &lt;libhello/hello.ixx></pre>

  <p>A note on inline/template files: in header-based projects we could
  include additional headers in those files, for example, if the included
  declarations are only needed in the implementation. For the reasons just
  discussed, this does not work with modules and we have to move all the
  includes into the interface file, before the module purview. On the other
  hand, with modules, it is safe to use namespace-level using-directives (for
  example, <code>using namespace std;</code>) in inline/template files (and,
  with care, even in the interface file).</p>

  <p>What about imports, where should we import other modules? Again, to
  recap, unlike a header inclusion, an <code>import</code> declaration only
  makes exported names visible without redeclaring them. As result, in module
  implementation units, it doesn't really matter where we place imports, in or
  out of the module purview. There are, however, two differences when it comes
  to module interface units: only imports in the purview are visible to
  implementation units and we can only re-export an imported module from the
  purview.</p>

  <p>The guideline is then for interface units to import in the module purview
  unless there is a good reason not to make the import visible to the
  implementation units. And for implementation units to always import in the
  purview for consistency. For example:</p>

  <pre>#include &lt;cassert>

export module hello;

import std.core;

#include &lt;libhello/export.hxx>

export namespace hello
{
  ...
}

#include &lt;libhello/hello.ixx></pre>

  <p>By putting all these guidelines together we can then create a module
  interface unit template:</p>

  <pre>// Module interface unit.

&lt;header includes>

export module &lt;name>;      // Start of module purview.

&lt;module imports>

&lt;special header includes>  // Configuration, export, etc.

&lt;module interface>

&lt;inline/template includes></pre>

  <p>As well as the module implementation unit template:</p>

  <pre>// Module implementation unit.

&lt;header includes>

module &lt;name>;             // Start of module purview.

&lt;extra module imports>     // Only additional to interface.

&lt;module implementation></pre>

  <p>Let's now discuss module naming. Module names are in a separate "name
  plane" and do not collide with namespace, type, or function names. Also, as
  mentioned earlier, the standard does not assign a hierarchical meaning to
  module names though it is customary to assume module <code>hello.core</code>
  is a submodule of <code>hello</code> and importing the latter also imports
  the former.</p>

  <p>It is important to choose good names for public modules (that is, modules
  packaged into libraries and used by a wide range of consumers) since
  changing them later can be costly. We have more leeway with naming private
  modules (that is, the ones used by programs or internal to libraries) though
  it's worth coming up with a consistent naming scheme here as well.</p>

  <p>The general guideline is to start names of public modules with the
  library's namespace name followed by a name describing the module's
  functionality. In particular, if a module is dedicated to a single class
  (or, more generally, has a single primary entity), then it makes sense to
  use its name as the module name's last component.</p>

  <p>As a concrete example, consider <code>libbutl</code> (the
  <code>build2</code> utility library): All its components are in the
  <code>butl</code> namespace so all its module names start with
  <code>butl.</code> One of its components is the <code>small_vector</code>
  class template which resides in its own module called
  <code>butl.small_vector</code>. Another component is a collection of string
  parsing utilities that are grouped into the <code>butl::string_parser</code>
  namespace with the corresponding module called
  <code>butl.string_parser</code>.</p>

  <p>When is it a good idea to re-export a module? The two straightforward
  cases are when we are building an aggregate module out of submodules, for
  example, <code>xml</code> out of <code>xml.parser</code> and
  <code>xml.serializer</code>, or when one module extends or supersedes
  another, for example, as <code>std.core</code> extends
  <code>std.fundamental</code>. It is also clear that there is no need to
  re-export a module that we only use in the implementation. The case when we
  use a module in our interface is, however, a lot less clear cut.</p>

  <p>But before considering the last case in more detail, let's understand the
  issue with re-export. In other words, why not simply re-export any module we
  import in our interface? In essence, re-export implicitly injects another
  module import anywhere our module is imported. If we re-export
  <code>std.core</code> then consumers of our module will also automatically
  "see" all the names exported by <code>std.core</code>. They can then start
  using names from <code>std</code> without explicitly importing
  <code>std.core</code> and everything will compile until one day they no
  longer need to import our module or we no longer need to import
  <code>std.core</code>. In a sense, re-export becomes part of our interface
  and it is generally good design to keep interfaces minimal.</p>

  <p>And so, at the outset, the guideline is then to only re-export the
  minimum necessary. This, by the way, is the reason why it may make sense to
  divide <code>std.core</code> into submodules such as
  <code>std.core.string</code>, <code>std.core.vector</code>, etc.</p>

  <p>Let's now discuss a few concrete examples to get a sense of when
  re-export might or might not be appropriate. Unfortunately, there does not
  seem to be a hard and fast rule and instead one has to rely on their good
  sense of design.</p>

  <p>To start, let's consider a simple module that uses
  <code>std::string</code> in its interface:</p>

  <pre>export module hello;

import std.core;

export namespace hello
{
  void say (const std::string&amp;);
}</pre>

  <p>Should we re-export <code>std.core</code> (or,
  <code>std.core.string</code>) in this case? Most likely not. If consumers of
  our module want to use <code>std::string</code> in order to pass an argument
  to our function, then it is natural to expect them to explicitly import the
  necessary module. In a sense, this is analogous to scoping: nobody expects
  to be able to use just <code>string</code> (without <code>std::</code>)
  because of <code>using namespace hello;</code>.</p>

  <p>So it seems that a mere usage of a name in an interface does not
  generally warrant a re-export. The fact that a consumer may not even use
  this part of our interface further supports this conclusion.</p>

  <p>Let's now consider a more interesting case (inspired by real events):</p>

  <pre>export module small_vector;

import std.core;

template &lt;typename T, std::size_t N>
export class small_vector: public std::vector&lt;T, ...>
{
  ...
};</pre>

  <p>Here we have the <code>small_vector</code> container implemented in terms
  of <code>std::vector</code> by providing a custom allocator and with most of
  the functions derived as is. Consider now this innocent-looking consumer
  code:</p>

  <pre>import small_vector;

small_vector&lt;int, 1> a, b;

if (a == b) // Error.
  ...</pre>

  <p>We don't reference <code>std::vector</code> directly so presumably we
  shouldn't need to import its module. However, the comparison won't compile:
  our <code>small_vector</code> implementation re-uses the comparison
  operators provided by <code>std::vector</code> (via implicit to-base
  conversion) but they aren't visible.</p>

  <p>There is a palpable difference between the two cases: the first merely
  uses <code>std.core</code> interface while the second is <i>based on</i>
  and, in a sense, <i>extends</i> it which feels like a stronger relationship.
  Re-exporting <code>std.core</code> (or, better yet,
  <code>std.core.vector</code>, should it become available) does not seem
  unreasonable.</p>

  <p>Note also that there is no re-export of headers nor header inclusion
  visibility in the implementation units. Specifically, in the previous
  example, if the standard library is not modularized and we have to use it
  via headers, then the consumers of our <code>small_vector</code> will always
  have to explicitly include <code>&lt;vector></code>. This suggest that
  modularizing a codebase that still consumes substantial components (like the
  standard library) via headers can incur some development overhead compared
  to the old, headers-only approach.</p>

  <h3 id="cxx-modules-existing">7.1.6 Modularizing Existing Code</h3>

  <p>The aim of this section is to provide practical guidelines to
  modularizing existing codebases as well as supporting the dual,
  header/module interface for backwards-compatibility.</p>

  <p>Predictably, a well modularized (in the general sense) set of headers
  makes conversion to C++ modules easier. Inclusion cycles will be
  particularly hard to deal with (C++ modules do not allow circular interface
  dependencies). Furthermore, as we will see below, if you plan to provide the
  dual header/module interface, then having a one-to-one header to module
  mapping will simplify this task. As a result, it may make sense to spend
  some time cleaning and re-organizing your headers prior to attempting
  modularization.</p>

  <p>Let's first discuss why the modularization approach illustrated by the
  following example does not generally work:</p>

  <pre>export module hello;

export
{
#include "hello.hxx"
}</pre>

  <p>There are several issue that usually make this unworkable. Firstly, the
  header we are trying to export most likely includes other headers. For
  example, our <code>hello.hxx</code> may include <code>&lt;string></code> and
  we have already discussed why including it in the module purview, let alone
  exporting its names, is a bad idea. Secondly, the included header may
  declare more names than what should be exported, for example, some
  implementation details. In fact, it may declare names with internal linkage
  (uncommon for headers but not impossible) which are illegal to export.
  Finally, the header may define macros which will no longer be visible to the
  consumers.</p>

  <p>Sometimes, however, this can be the only approach available (for example,
  if trying to non-intrusively modularize a third-party library). It is
  possible to work around the first issue by <i>pre-including</i> outside of
  the module purview headers that should not be exported. Here we rely on the
  fact that the second inclusion of the same header will be ignored. For
  example:</p>

  <pre>#include &lt;string> // Pre-include to suppress inclusion below.

export module hello;

export
{
#include "hello.hxx"
}</pre>

  <p>Needless to say this approach is very brittle and usually requires that
  you place all the inter-related headers into a single module. As a result,
  its use is best limited to exploratory modularization and early
  prototyping.</p>

  <p>When starting modularization of a codebase there are two decisions we
  have to make at the outset: the level of the C++ modules support we can
  assume and the level of backwards compatibility we need to provide.</p>

  <p>The two modules support levels we distinguish are just modules and
  modules with the modularized standard library. The choice we have to make
  then is whether to support the standard library only as headers, only as
  modules, or both. Note that some compiler/standard library combinations may
  not be usable in some of these modes.</p>

  <p>The possible backwards compatibility levels are <i>modules-only</i>
  (consumption via headers is no longer supported), <i>modules-or-headers</i>
  (consumption either via headers or modules), and <i>modules-and-headers</i>
  (as the previous case but with support for consuming a library built with
  modules via headers and vice versa).</p>

  <p>What kind of situations call for the last level? We may need to continue
  offering the library as headers if we have a large number of existing
  consumers that cannot possibly be all modularized at once (or even ever). So
  the situation we may end up in is a mixture of consumers trying to use the
  same build of our library with some of them using modules and some &#8211;
  headers. The case where we may want to consume a library built with headers
  via modules is not as far fetched as it may seem: the library might have
  been built with an older version of the compiler (for example, it was
  installed from a distribution's package) while the consumer is being built
  with a compiler version that supports modules. Note also that as discussed
  earlier the modules ownership semantics supports both kinds of such
  "cross-usage".</p>

  <p>Generally, compiler implementations do not support mixing inclusion and
  importation of the same entities in the same translation unit. This makes
  migration tricky if you plan to use the modularized standard library because
  of its pervasive use. There are two plausible strategies to handling this
  aspect of migration: If you are planning to consume the standard library
  exclusively as modules, then it may make sense to first change your entire
  codebase to do that. Simply replace all the standard library header
  inclusions with importation of the relevant <code>std.*</code> modules.</p>

  <p>The alternative strategy is to first complete the modularization of our
  entire project (as discussed next) while continuing consuming the standard
  library as headers. Once this is done, we can normally switch to using the
  modularized standard library quite easily. The reason for waiting until the
  complete modularization is to eliminate header inclusions between components
  which would often result in conflicting styles of the standard library
  consumption.</p>

  <p>Note also that due to the lack of header re-export and include visibility
  support discussed earlier, it may make perfect sense to only support the
  modularized standard library when modules are enabled even when providing
  backwards compatibility with headers. In fact, if all the compiler/standard
  library implementations that your project caters to support the modularized
  standard library, then there is little sense not to impose such a
  restriction.</p>

  <p>The overall strategy for modularizing our own components is to identify
  and modularize inter-dependent sets of headers one at a time starting from
  the lower-level components. This way any newly modularized set will only
  depend on the already modularized ones. After converting each set we can
  switch its consumers to using imports keeping our entire project buildable
  and usable.</p>

  <p>While ideally we would want to be able to modularize just a single
  component at a time, this does not seem to work in practice because we will
  have to continue consuming some of the components as headers. Since such
  headers can only be imported out of the module purview, it becomes hard to
  reason (both for us and often the compiler) what is imported/included and
  where. For example, it's not uncommon to end up importing the module in its
  implementation unit which is not something that all the compilers can handle
  gracefully.</p>

  <p>Let's now explore how we can provide the various levels of backwards
  compatibility discussed above. Here we rely on two feature test macros to
  determine the available modules support level: <code>__cpp_modules</code>
  (modules are available) and <code>__cpp_lib_modules</code> (standard library
  modules are available, assumes <code>__cpp_modules</code> is also
  defined).</p>

  <p>If backwards compatibility is not necessary (the <i>modules-only</i>
  level), then we can use the module interface and implementation unit
  templates presented earlier and follow the above guidelines. If we continue
  consuming the standard library as headers, then we don't need to change
  anything in this area. If we only want to support the modularized standard
  library, then we simply replace the standard library header inclusions with
  the corresponding module imports. If we want to support both ways, then we
  can use the following templates. The module interface unit template:</p>

  <pre>// C includes, if any.

#ifndef __cpp_lib_modules
&lt;std includes>
#endif

// Other includes, if any.

export module &lt;name>;

#ifdef __cpp_lib_modules
&lt;std imports>
#endif

&lt;module interface></pre>

  <p>The module implementation unit template:</p>

  <pre>// C includes, if any.

#ifndef __cpp_lib_modules
&lt;std includes>

&lt;extra std includes>
#endif

// Other includes, if any.

module &lt;name>;

#ifdef __cpp_lib_modules
&lt;extra std imports>        // Only additional to interface.
#endif

&lt;module implementation></pre>

  <p>For example:</p>

  <pre>// hello.mxx (module interface)

#ifndef __cpp_lib_modules
#include &lt;string>
#endif

export module hello;

#ifdef __cpp_lib_modules
import std.core;
#endif

export void say_hello (const std::string&amp; name);</pre>

  <pre>// hello.cxx (module implementation)

#ifndef __cpp_lib_modules
#include &lt;string>

#include &lt;iostream>
#endif

module hello;

#ifdef __cpp_lib_modules
import std.io;
#endif

using namespace std;

void say_hello (const string&amp; n)
{
  cout &lt;&lt; "Hello, " &lt;&lt; n &lt;&lt; '!' &lt;&lt; endl;
}</pre>

  <p>If we need support for symbol exporting in this setup (that is, we are
  building a library and need to support Windows), then we can use the
  <code>__symexport</code> mechanism discussed earlier, for example:</p>

  <pre>// hello.mxx (module interface)

...

export __symexport void say_hello (const std::string&amp; name);</pre>

  <p>The consumer code in the <i>modules-only</i> setup is straightforward:
  they simply import the desired modules.</p>

  <p>To support consumption via headers when modules are unavailable (the
  <i>modules-or-headers</i> level) we can use the following setup. Here we
  also support the dual header/modules consumption for the standard library
  (if this is not required, replace <code>#ifndef __cpp_lib_modules</code>
  with <code>#ifndef __cpp_modules</code> and remove <code>#ifdef
  __cpp_lib_modules</code>). The module interface unit template:</p>

  <pre>#ifndef __cpp_modules
#pragma once
#endif

// C includes, if any.

#ifndef __cpp_lib_modules
&lt;std includes>
#endif

// Other includes, if any.

#ifdef __cpp_modules
export module &lt;name>;

#ifdef __cpp_lib_modules
&lt;std imports>
#endif
#endif

&lt;module interface></pre>

  <p>The module implementation unit template:</p>

  <pre>#ifndef __cpp_modules
#include &lt;module interface file>
#endif

// C includes, if any.

#ifndef __cpp_lib_modules
&lt;std includes>

&lt;extra std includes>
#endif

// Other includes, if any

#ifdef __cpp_modules
module &lt;name>;

#ifdef __cpp_lib_modules
&lt;extra std imports>        // Only additional to interface.
#endif
#endif

&lt;module implementation></pre>

  <p>Notice the need to repeat <code>&lt;std includes></code> in the
  implementation file due to the lack of include visibility discussed above.
  This is necessary when modules are enabled but the standard library is not
  modularized since in this case the implementation does not "see" any of the
  headers included in the interface.</p>

  <p>Besides these templates we will most likely also need an export header
  that appropriately defines a module export macro depending on whether
  modules are used or not. This is also the place where we can handle symbol
  exporting. For example, here is what it could look like for our
  <code>libhello</code> library:</p>

  <pre>// export.hxx (module and symbol export)

#pragma once

#ifdef __cpp_modules
#  define LIBHELLO_MODEXPORT export
#else
#  define LIBHELLO_MODEXPORT
#endif

#if   defined(LIBHELLO_SHARED_BUILD)
#  ifdef _WIN32
#    define LIBHELLO_SYMEXPORT __declspec(dllexport)
#  else
#    define LIBHELLO_SYMEXPORT
#  endif
#elif defined(LIBHELLO_SHARED)
#  ifdef _WIN32
#    define LIBHELLO_SYMEXPORT __declspec(dllimport)
#  else
#    define LIBHELLO_SYMEXPORT
#  endif
#else
#  define LIBHELLO_SYMEXPORT
#endif</pre>

  <p>And this is the module that uses it and provides the dual header/module
  support:</p>

  <pre>// hello.mxx (module interface)

#ifndef __cpp_modules
#pragma once
#endif

#ifndef __cpp_lib_modules
#include &lt;string>
#endif

#ifdef __cpp_modules
export module hello;

#ifdef __cpp_lib_modules
import std.core;
#endif
#endif

#include &lt;libhello/export.hxx>

LIBHELLO_MODEXPORT namespace hello
{
  LIBHELLO_SYMEXPORT void say (const std::string&amp; name);
}</pre>

  <pre>// hello.cxx (module implementation)

#ifndef __cpp_modules
#include &lt;libhello/hello.mxx>
#endif

#ifndef __cpp_lib_modules
#include &lt;string>

#include &lt;iostream>
#endif

#ifdef __cpp_modules
module hello;

#ifdef __cpp_lib_modules
import std.io;
#endif
#endif

using namespace std;

namespace hello
{
  void say (const string&amp; n)
  {
    cout &lt;&lt; "Hello, " &lt;&lt; n &lt;&lt; '!' &lt;&lt; endl;
  }
}</pre>

  <p>The consumer code in the <i>modules-or-headers</i> setup has to use
  either inclusion or importation depending on the modules support
  availability, for example:</p>

  <pre>#ifdef __cpp_modules
import hello;
#else
#include &lt;libhello/hello.mxx>
#endif</pre>

  <p>Predictably, the final backwards compatibility level
  (<i>modules-and-headers</i>) is the most onerous to support. Here existing
  consumers have to continue working with the modularized version of our
  library which means we have to retain all the existing header files. We also
  cannot assume that just because modules are available they are used (a
  consumer may still prefer headers), which means we cannot rely on (only) the
  <code>__cpp_modules</code> and <code>__cpp_lib_modules</code> macros to make
  the decisions.</p>

  <p>One way to arrange this is to retain the headers and adjust them
  according to the <i>modules-or-headers</i> template but with one important
  difference: instead of using the standard module macros we use our custom
  ones (and we can also have unconditional <code>#pragma once</code>). For
  example:</p>

  <pre>// hello.hxx (module header)

#pragma once

#ifndef LIBHELLO_LIB_MODULES
#include &lt;string>
#endif

#ifdef LIBHELLO_MODULES
export module hello;

#ifdef LIBHELLO_LIB_MODULES
import std.core;
#endif
#endif

#include &lt;libhello/export.hxx>

LIBHELLO_MODEXPORT namespace hello
{
  LIBHELLO_SYMEXPORT void say (const std::string&amp; name);
}</pre>

  <p>Now if this header is included (for example, by an existing consumer)
  then none of the <code>LIBHELLO_*MODULES</code> macros will be defined and
  the header will act as, well, a plain old header. Note that we will also
  need to make the equivalent change in the export header.</p>

  <p>We also provide the module interface files which appropriately define the
  two custom macros and then simply includes the corresponding headers:</p>

  <pre>// hello.mxx (module interface)

#ifdef __cpp_modules
#define LIBHELLO_MODULES
#endif

#ifdef __cpp_lib_modules
#define LIBHELLO_LIB_MODULES
#endif

#include &lt;libhello/hello.hxx></pre>

  <p>The module implementation unit can remain unchanged. In particular, we
  continue including <code>hello.mxx</code> if modules support is unavailable.
  However, if you find the use of different macros in the header and source
  files confusing, then instead it can be adjusted as follows (note also that
  now we are including <code>hello.hxx</code>):</p>

  <pre>// hello.cxx (module implementation)

#ifdef __cpp_modules
#define LIBHELLO_MODULES
#endif

#ifdef __cpp_lib_modules
#define LIBHELLO_LIB_MODULES
#endif

#ifndef LIBHELLO_MODULES
#include &lt;libhello/hello.hxx>
#endif

#ifndef LIBHELLO_LIB_MODULES
#include &lt;string>

#include &lt;iostream>
#endif

#ifdef LIBHELLO_MODULES
module hello;

#ifdef LIBHELLO_LIB_MODULES
import std.io;
#endif
#endif

...</pre>

  <p>In this case it may also make sense to factor the
  <code>LIBHELLO_*MODULES</code> macro definitions into a common header.</p>

  <p>In the <i>modules-and-headers</i> setup the existing consumers that would
  like to continue using headers don't require any changes. And for those that
  would like to use modules if available the arrangement is the same as for
  the <i>modules-or-headers</i> compatibility level.</p>

  <p>If our module needs to "export" macros then the recommended approach is
  to simply provide an additional header that the consumer includes. While it
  might be tempting to also wrap the module import into this header, some may
  prefer to explicitly import the module and include the header, especially if
  the macros may not be needed by all consumers. This way we can also keep the
  header macro-only which means it can be included freely, in or out of module
  purviews.</p>

  <h1 id="module-in">8 <code>in</code> Module</h1>

  <p>The <code>in</code> build system module provides support for
  <code>.in</code> (input) file preprocessing. Specifically, the
  <code>.in</code> file can contain a number of <i>substitutions</i> &#8211;
  build system variable names enclosed with the substitution symbol
  (<code>$</code> by default) &#8211; which are replaced with the
  corresponding variable values to produce the output file. For example:</p>

  <pre># build/root.build

using in</pre>

  <pre>// config.hxx.in

#define TARGET "$cxx.target$"</pre>

  <pre># buildfile

hxx{config}: in{config}</pre>

  <p>The <code>in</code> module defines the <code>in{}</code> target type and
  implements the <code>in</code> build system rule.</p>

  <p>While we can specify the <code>.in</code> extension explicitly, it is not
  necessary because the <code>in{}</code> target type implements
  <i>target-dependent search</i> by taking into account the target it is a
  prerequisite of. In other words, the following dependency declarations
  produce the same result:</p>

  <pre>hxx{config}:     in{config}
hxx{config.hxx}: in{config}
hxx{config.hxx}: in{config.hxx.in}</pre>

  <p>By default the <code>in</code> rule uses <code>$</code> as the
  substitution symbol. This can be changed using the <code>in.symbol</code>
  variable. For example:</p>

  <pre>// data.cxx.in

const char data[] = "@data@";</pre>

  <pre># buildfile

cxx{data}: in{data}
{
  in.symbol = '@'
  data = 'Hello, World!'
}</pre>

  <p>Note that the substitution symbol must be a single character.</p>

  <p>The default substitution mode is strict. In this mode every substitution
  symbol is expected to start a substitution with unresolved (to a variable
  value) names treated as errors. The double substitution symbol (for example,
  <code>$$</code>) serves as an escape sequence.</p>

  <p>The substitution mode can be relaxed using the
  <code>in.substitution</code> variable. Its valid values are
  <code>strict</code> (default) and <code>lax</code>. In the lax mode a pair
  of substitution symbols is only treated as a substitution if what's between
  them looks like a build system variable name (that is, it doesn't contain
  spaces, etc). Everything else, including unterminated substitution symbols,
  is copied as is. Note also that in this mode the double substitution symbol
  is not treated as an escape sequence.</p>

  <p>The lax mode is mostly useful when trying to reuse existing
  <code>.in</code> files from other build systems, such as
  <code>autoconf</code>. Note, however, that the lax mode is still stricter
  than the <code>autoconf</code>'s semantics which also leaves unresolved
  substitutions as is. For example:</p>

  <pre># buildfile

h{config}: in{config} # config.h.in
{
  in.symbol = '@'
  in.substitution = lax

  CMAKE_SYSTEM_NAME = $c.target.system
  CMAKE_SYSTEM_PROCESSOR = $c.target.cpu
}</pre>

  <p>The <code>in</code> rule tracks changes to the input file as well as the
  substituted variable values and automatically regenerates the output file if
  any were detected. Substituted variable values are looked up starting from
  the target-specific variables. Typed variable values are converted to string
  using the corresponding <code>builtin.string()</code> function overload
  before substitution.</p>

  <p>A number of other build system modules, for example, <a
  href="#module-version"><code>version</code></a> and <a
  href="#module-bash"><code>bash</code></a>, are based on the <code>in</code>
  module and provide extended functionality. The <code>in</code> preprocessing
  rule matches any <code>file{}</code>-based target that has the corresponding
  <code>in{}</code> prerequisite provided none of the extended rules
  match.</p>

  <h1 id="module-bash">9 <code>bash</code> Module</h1>

  <p>The <code>bash</code> build system module provides modularization support
  for <code>bash</code> scripts. It is based on the <a
  href="#module-in"><code>in</code></a> build system module and extends its
  preprocessing rule with support for <i>import substitutions</i> in the
  <code>@import&#160;&lt;module>@</code> form. During preprocessing, such
  imports are replaced with suitable <code>source</code> builtin calls. For
  example:</p>

  <pre># build/root.build

using bash</pre>

  <pre># hello/say-hello.bash

function say_hello ()
{
  echo "Hello, $1!"
}</pre>

  <pre>#!/usr/bin/env bash

# hello/hello.in

@import hello/say-hello@

say_hello 'World'</pre>

  <pre># hello/buildfile

exe{hello}: in{hello} bash{say-hello}</pre>

  <p>By default the <code>bash</code> preprocessing rule uses the lax
  substitution mode and <code>@</code> as the substitution symbol but this can
  be overridden using the standard <code>in</code> module mechanisms.</p>

  <p>In the above example, <code>say-hello.bash</code> is a <i>module</i>. By
  convention, <code>bash</code> modules have the <code>.bash</code> extension
  and we use the <code>bash{}</code> target type (defined by the
  <code>bash</code> build system module) to refer to them in buildfiles.</p>

  <p>The <code>say-hello.bash</code> module is <i>imported</i> by the
  <code>hello</code> script with the
  <code>@import&#160;hello/say-hello@</code> substitution. The <i>import
  path</i> (<code>hello/say-hello</code> in our case) is a relative path to
  the module file within the project. Its first component (<code>hello</code>
  in our case) must be the project base name and the <code>.bash</code> module
  extension can be omitted. <span class="note">The constraint placed on the
  first component of the import path is required to implement importation of
  installed modules, as discussed below.</span></p>

  <p>During preprocessing, the import substitution will be replaced with a
  <code>source</code> builtin call and the import path resolved to one of the
  <code>bash{}</code> prerequisites from the script's dependency declaration.
  The actual module path used in <code>source</code> depends on whether the
  script is preprocessed for installation. If it's not (development build),
  then the absolute path to the module file is used. Otherwise, a path
  relative to the sourcing script's directory is derived. This allows
  installed scripts and their modules to be moved around.</p>

  <div class="note">
  <p>The derivation of the sourcing script's directory works even if the
  script is executed via a symbolic link from another directory. Implementing
  this, however, requires <code>readlink(1)</code> with support for the
  <code>-f</code> option. One notable platform that does not provide such
  <code>readlink(1)</code> by default is Mac OS. The script, however, can
  provide a suitable implementation as a function. See the <code>bash</code>
  module tests for a sample implementation of such a function.</p>
  </div>

  <p>By default, <code>bash</code> modules are installed into a subdirectory
  of the <code>bin/</code> installation directory named as the project base
  name. For instance, in the above example, the script will be installed as
  <code>bin/hello</code> and the module as
  <code>bin/hello/say-hello.bash</code> with the script sourcing the module
  relative to the <code>bin/</code> directory. Note that currently it is
  assumed the script and all its modules are installed into the same
  <code>bin/</code> directory.</p>

  <p>Naturally, modules can import other modules and modules can be packaged
  into <i>module libraries</i> and imported using the standard build system
  import mechanism. For example, we could factor the
  <code>say-hello.bash</code> module into a separate <code>libhello</code>
  project:</p>

  <pre># build/export.build

$out_root/
{
  include libhello/
}

export $src_root/libhello/$import.target</pre>

  <pre># libhello/say-hello.bash

function hello_say_hello ()
{
  echo "Hello, $1!"
}</pre>

  <p>And then import it in a module of our <code>hello</code> project:</p>

  <pre># hello/hello-world.bash.in

@import libhello/say-hello@

function hello_world ()
{
  hello_say_hello 'World'
}</pre>

  <pre>#!/usr/bin/env bash

# hello/hello.in

@import hello/hello-world@

hello_world</pre>

  <pre># hello/buildfile

import mods = libhello%bash{say-hello}

exe{hello}:        in{hello}       bash{hello-world}
bash{hello-world}: in{hello-world} $mods</pre>

  <p>The <code>bash</code> preprocessing rule also supports importation of
  installed modules by searching in the <code>PATH</code> environment
  variable.</p>

  <p>By convention, <code>bash</code> module libraries should use the
  <code>lib</code> name prefix, for example, <code>libhello</code>. If there
  is also a native library (that is, one written in C/C++) that provides the
  same functionality (or the <code>bash</code> library is a language binding
  for said library), then it is customary to add the <code>.bash</code>
  extension to the <code>bash</code> library name, for example,
  <code>libhello.bash</code>. Note that in this case the project base name is
  <code>libhello</code>.</p>

  <p>Modules can be <i>private</i> or <i>public</i>. Private modules are
  implementation details of a specific project and are not expected to be
  imported from other projects. The <code>hello/hello-world.bash.in</code>
  module above is an example of a private module. Public modules are meant to
  be used by other projects and are normally packaged into libraries, like the
  <code>libhello/say-hello.bash</code> module above.</p>

  <p>Public modules must take care to avoid name clashes. Since
  <code>bash</code> does not have a notion of namespaces, the recommended way
  is to prefix all module functions (and global variables, if any) with the
  library name (without the <code>lib</code> prefix), like in the
  <code>libhello/say-hello.bash</code> module above.</p>

  <p>While using such decorated function names can be unwieldy, it is
  relatively easy to create wrappers with shorter names and use those instead.
  For example:</p>

  <pre>@import libhello/say-hello@

function say_hello () { hello_say_hello "$@"; }</pre>

  <p>A module should normally also prevent itself from being sourced multiple
  times. The recommended way to achieve this is to begin the module with a
  <i>source guard</i>. For example:</p>

  <pre># libhello/say-hello.bash

if [ "$hello_say_hello" ]; then
  return 0
else
  hello_say_hello=true
fi

function hello_say_hello ()
{
  echo "Hello, $1!"
}</pre>

  <p>The <code>bash</code> preprocessing rule matches <code>exe{}</code>
  targets that have the corresponding <code>in{}</code> and one or more
  <code>bash{}</code> prerequisites as well as <code>bash{}</code> targets
  that have the corresponding <code>in{}</code> prerequisite (if you need to
  preprocess a script that does not depend on any modules, you can use the
  <code>in</code> module's rule).</p>

</div>

</body>
</html>
