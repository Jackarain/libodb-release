%!PS
%%Title: The build2 Build System
%%Creator: html2ps version 1.0 beta7
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 471 F div D
/IL 621 F div D
/PS 791 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [12 9 19 17 15 13 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}{ h }][{ h }{()}][{()}{()}]] D
/ZZ [[{ (Revision ) ME 0 get join(, June 2019)join }{ Pn }][{ Pn }{ (Revision ) ME 0 get join(, June 2019)join }][{ Ti }{ Ti }]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Tp t D
/Fe f D
/TI 2 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 706 D
/yR 706 D
/Wl 471 F div D
/Wr 471 F div D
/hL 621 F div D
/hR 621 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.6 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th { (
) 2 Al()BR (
  ) 0 1 -1 H()4 FZ (The ) SM (build2) ES ( ) ME 1 get join ES()EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
) Ea()BR (
  ) 0 P (Copyright © 2014-2019 Code Synthesis Ltd) BR (  Permission is granted to copy, distribute and/or modify this document under
  the terms of the MIT License.) EP (

  ) 0 P (Revision ) SM() ME 0 get join ES (, June 2019) BR (  This revision of the document describes the ) SM (build2) ES ( ) ME 2 get join(
  )join SM() ME 0 get join(.x)join ES ( series.) EP()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{/Ms t D NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()0 Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\232)(\253\240)(\233)(\234)(\273)(\253)][(\231)(\253\240)(`)(')(\273)(\253)]] D
/QC [[(\233)(\240\273)(\234)(\234)(\253)(\273)][(`)(\240\273)(')(')(\253)(\273)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 2 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta7) /Author () /Keywords () /Subject (build system)
 /Title (The build2 Build System) /DOCINFO pdfmark
/ND 1 D
/HN [(1) (1) (1) (1) (2) (7) (15) (26) (27) (30) (35) (38) (40) (43) (49) (53)
(55) (59) (61) (62) (65) (70) (73) (74) (74) (82) (82) (83) (83) (90) (93)
(94) (95) (101) (110) (112) (1) (1) (2) (7) (15) (26) (27) (30) (35) (38)
(40) (43) (49) (53) (55) (59) (61) (62) (65) (70) (73) (74) (74) (82) (82)
(83) (83) (90) (93) (94) (95) (101) (110) (112)] D
/h0 [()(Table of Contents)] D
/h1 [(1\240\240)(Preface)] D
/h2 [(2\240\240)(1 Introduction)] D
/h3 [(2.1\240\240)(1.1 Hello, World)] D
/h4 [(2.2\240\240)(1.2 Project Structure)] D
/h5 [(2.3\240\240)(1.3 Output Directories and Scopes)] D
/h6 [(2.4\240\240)(1.4 Operations)] D
/h7 [(2.4.1\240\240)(1.4.1 Configuration)] D
/h8 [(2.4.2\240\240)(1.4.2 Testing)] D
/h9 [(2.4.3\240\240)(1.4.3 Installation)] D
/h10 [(2.4.4\240\240)(1.4.4 Distribution)] D
/h11 [(2.5\240\240)(1.5 Target Importation)] D
/h12 [(2.6\240\240)(1.6 Library Exportation and Versioning)] D
/h13 [(2.7\240\240)(1.7 Subprojects and Amalgamations)] D
/h14 [(2.8\240\240)(1.8 Buildfile Language)] D
/h15 [(2.8.1\240\240)(1.8.1 Expansion and Quoting)] D
/h16 [(2.8.2\240\240)(1.8.2 Conditions \(if-else\))] D
/h17 [(2.8.3\240\240)(1.8.3 Repetitions \(for\))] D
/h18 [(2.9\240\240)(1.9 Implementing Unit Testing)] D
/h19 [(2.10\240\240)(1.10 Diagnostics and Debugging)] D
/h20 [(3\240\240)(2 Name Patterns)] D
/h21 [(4\240\240)(3 Variables)] D
/h22 [(5\240\240)(4 test Module)] D
/h23 [(6\240\240)(5 version Module)] D
/h24 [(7\240\240)(6 bin Module)] D
/h25 [(8\240\240)(7 cxx Module)] D
/h26 [(8.1\240\240)(7.1 C++ Modules Support)] D
/h27 [(8.1.1\240\240)(7.1.1 Modules Introduction)] D
/h28 [(8.1.2\240\240)(7.1.2 Building Modules)] D
/h29 [(8.1.3\240\240)(7.1.3 Module Symbols Exporting)] D
/h30 [(8.1.4\240\240)(7.1.4 Modules Installation)] D
/h31 [(8.1.5\240\240)(7.1.5 Modules Design Guidelines)] D
/h32 [(8.1.6\240\240)(7.1.6 Modularizing Existing Code)] D
/h33 [(9\240\240)(8 in Module)] D
/h34 [(10\240\240)(9 bash Module)] D
/Hr [36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57
58 59 60 61 62 63 64 65 66 67 68 69]D
/HV [1 1 2 2 2 2 3 3 3 3 2 2 2 2 3 3 3 2 2 1 1 1 1 1 1 2 3 3 3 3 3 3 1
1]D
/Cn [0 10 0 0 0 4 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 1 6 0 0 0 0 0 0 0
0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (https://build2.org/doc.xhtml) D
/R2 (http://semver.org/) D
/R3 (https://build2.org/pkg/hello) D
/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Build System) D
/Au () D
/Df f D
/ME [(0.11)(Build System)(build system)] D
Pt
/BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
 tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(The build2 Build System)ES()0 1 TN()EA()BN}if
1 NH le{36(1\240\240)1 C(Preface)WB 2 Sn()36 1 TN()EA()BN}if
1 NH le{37(2\240\240)1 C(1)WB 3 Sn( Intro)HY(duc)HY(tion)YH()37 1 TN()EA()BN}if
2 NH le{38(2.1\240\240)2 C(1.1)WB 4 Sn( Hello, World)38 1 TN()EA()BN}if
2 NH le{39(2.2\240\240)2 C(1.2)WB 5 Sn( Project Struc)HY(ture)YH()39 1 TN()EA()BN}if
2 NH le{40(2.3\240\240)2 C(1.3)WB 6 Sn( Output Direc)HY(to)HY(ries)YH( and Scopes)40 1 TN()EA()BN}if
2 NH le{41(2.4\240\240)2 C(1.4)WB 7 Sn( Oper)HY(a)HY(tions)YH()41 1 TN()EA()BN}if
3 NH le{42(2.4.1\240\240)3 C(1.4.1)WB 8 Sn( Config)HY(u)HY(ra)HY(tion)YH()42 1 TN()EA()BN}if
3 NH le{43(2.4.2\240\240)3 C(1.4.2)WB 9 Sn( Testing)43 1 TN()EA()BN}if
3 NH le{44(2.4.3\240\240)3 C(1.4.3)WB 10 Sn( Instal)HY(la)HY(tion)YH()44 1 TN()EA()BN}if
3 NH le{45(2.4.4\240\240)3 C(1.4.4)WB 11 Sn( Distri)HY(bu)HY(tion)YH()45 1 TN()EA()BN}if
2 NH le{46(2.5\240\240)2 C(1.5)WB 12 Sn( Target Impor)HY(ta)HY(tion)YH()46 1 TN()EA()BN}if
2 NH le{47(2.6\240\240)2 C(1.6)WB 13 Sn( Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()47 1 TN()EA()BN}if
2 NH le{48(2.7\240\240)2 C(1.7)WB 14 Sn( Subpro)HY(jects)YH( and Amal)HY(ga)HY(ma)HY(tions)YH()48 1 TN()EA()BN}if
2 NH le{49(2.8\240\240)2 C(1.8)WB 15 Sn( Build)HY(file)YH( Language)49 1 TN()EA()BN}if
3 NH le{50(2.8.1\240\240)3 C(1.8.1)WB 16 Sn( Expan)HY(sion)YH( and Quoting)50 1 TN()EA()BN}if
3 NH le{51(2.8.2\240\240)3 C(1.8.2)WB 17 Sn( Condi)HY(tions)YH( \201)SM(if-else)ES(\202)51 1 TN()EA()BN}if
3 NH le{52(2.8.3\240\240)3 C(1.8.3)WB 18 Sn( Repe)HY(ti)HY(tions)YH( \201)SM(for)ES(\202)52 1 TN()EA()BN}if
2 NH le{53(2.9\240\240)2 C(1.9)WB 19 Sn( Imple)HY(ment)HY(ing)YH( Unit Testing)53 1 TN()EA()BN}if
2 NH le{54(2.10\240\240)2 C(1.10)WB 20 Sn( Diag)HY(nos)HY(tics)YH( and Debug)HY(ging)YH()54 1 TN()EA()BN}if
1 NH le{55(3\240\240)1 C(2)WB 21 Sn( Name Patterns)55 1 TN()EA()BN}if
1 NH le{56(4\240\240)1 C(3)WB 22 Sn( Vari)HY(ables)YH()56 1 TN()EA()BN}if
1 NH le{57(5\240\240)1 C(4)WB 23 Sn( )SM(test)ES( Module)57 1 TN()EA()BN}if
1 NH le{58(6\240\240)1 C(5)WB 24 Sn( )SM(version)ES( Module)58 1 TN()EA()BN}if
1 NH le{59(7\240\240)1 C(6)WB 25 Sn( )SM(bin)ES( Module)59 1 TN()EA()BN}if
1 NH le{60(8\240\240)1 C(7)WB 26 Sn( )SM(cxx)ES( Module)60 1 TN()EA()BN}if
2 NH le{61(8.1\240\240)2 C(7.1)WB 27 Sn( C++ Modules Support)61 1 TN()EA()BN}if
3 NH le{62(8.1.1\240\240)3 C(7.1.1)WB 28 Sn( Modules Intro)HY(duc)HY(tion)YH()62 1 TN()EA()BN}if
3 NH le{63(8.1.2\240\240)3 C(7.1.2)WB 29 Sn( Build)HY(ing)YH( Modules)63 1 TN()EA()BN}if
3 NH le{64(8.1.3\240\240)3 C(7.1.3)WB 30 Sn( Module Symbols Export)HY(ing)YH()64 1 TN()EA()BN}if
3 NH le{65(8.1.4\240\240)3 C(7.1.4)WB 31 Sn( Modules Instal)HY(la)HY(tion)YH()65 1 TN()EA()BN}if
3 NH le{66(8.1.5\240\240)3 C(7.1.5)WB 32 Sn( Modules Design Guide)HY(lines)YH()66 1 TN()EA()BN}if
3 NH le{67(8.1.6\240\240)3 C(7.1.6)WB 33 Sn( Modu)HY(lar)HY(iz)HY(ing)YH( Exist)HY(ing)YH( Code)67 1 TN()EA()BN}if
1 NH le{68(9\240\240)1 C(8)WB 34 Sn( )SM(in)ES( Module)68 1 TN()EA()BN}if
1 NH le{69(10\240\240)1 C(9)WB 35 Sn( )SM(bash)ES( Module)69 1 TN()EA()BN}if
/OU t D /Cb Db D NP Ep ET 
/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Build System) D
/Au () D
/Df f D
/ME [(0.11)(Build System)(build system)] D

NP RC ZF
()2 Sl()WB 0 Sn(
)BR()WB 1 Sn(
   
  )0 1 0 H(Preface)WB 36 Sn()WB 2 Sn()EH(

  )0 P(This docu)HY(ment)YH( describes the )SM(build2)ES( build system. For the
  build system driver command line inter)HY(face)YH( refer to the )0 2 A()SM()BD(b\2011\202)ES()ES()EA( man pages. For other tools in
  the )SM(build2)ES( toolchain \201package and project managers, etc\202 see
  the )R1 2 A(Docu)HY(men)HY(ta)HY(tion)YH()EA( index.)EP(

  )0 1 1 H(1)WB 37 Sn()WB 3 Sn( Intro)HY(duc)HY(tion)YH()EH(

  )0 P(The )SM(build2)ES( build system is a native, cross-plat)HY(form)YH( build
  system with a terse, mostly declar)HY(a)HY(tive)YH( descrip)HY(tion)YH( language, a concep)HY(tual)YH(
  model of build, and a uniform inter)HY(face)YH( with consis)HY(tent)YH( behav)HY(ior)YH( across
  plat)HY(forms)YH( and compil)HY(ers)YH(.)EP(

  )0 P(Those famil)HY(iar)YH( with )SM(make)ES( will see many simi)HY(lar)HY(i)HY(ties)YH(, though
  mostly concep)HY(tual)YH( rather than syntac)HY(tic)YH(. This is not by acci)HY(dent)YH( since
  )SM(build2)ES( borrows the funda)HY(men)HY(tal)YH( DAG-based build model from
  orig)HY(i)HY(nal)YH( )SM(make)ES( and many of its concep)HY(tual)YH( exten)HY(sions)YH( from GNU
  )SM(make)ES(. We believe, para)HY(phras)HY(ing)YH( a famous quote, that )I(those
  who do not under)HY(stand)YH( )SM(make)ES( are condemned to rein)HY(vent)YH( it,
  poorly.)ES( So our goal with )SM(build2)ES( was to rein)HY(vent)YH(
  )SM(make)ES( )I(well)ES( while handling the demands and complex)HY(ity)YH( of
  modern cross-plat)HY(form)YH( soft)HY(ware)YH( devel)HY(op)HY(ment)YH(.)EP(

  )0 P(Like )SM(make)ES(, )SM(build2)ES( is an )I("honest")ES( build
  system without magic or black boxes. You can expect to under)HY(stand)YH( what's
  going on under)HY(neath)YH( and be able to customize most of its behav)HY(ior)YH( to suit
  your needs. This is not to say that it's not an )I(opin)HY(ion)HY(ated)YH()ES( build
  system and if you find your)HY(self)YH( "fight)HY(ing)YH(" some of its funda)HY(men)HY(tal)YH( design
  choices, it would prob)HY(a)HY(bly)YH( be wiser to look for alter)HY(na)HY(tives)YH(.)EP(

  )0 P(We believe the impor)HY(tance)YH( and complex)HY(ity)YH( of the problem warranted the
  design of a new purpose-built language and will hope)HY(fully)YH( justify the time
  it takes for you to master it. In the end we hope )SM(build2)ES( will
  make creat)HY(ing)YH( and main)HY(tain)HY(ing)YH( build infras)HY(truc)HY(ture)YH( for your projects a
  pleas)HY(ant)YH( task.)EP(

  )0 P(Also note that )SM(build2)ES( is not specific to C/C++ or even to
  compiled languages; its build model is general enough to handle any
  DAG-based oper)HY(a)HY(tions)YH(. See the )0 35 1 A()SM(bash)ES(
  Module)35 0 TN TL()Ec /AF f D( for a good example.)EP(

  )0 P(While the build system is part of a larger, well-inte)HY(grated)YH( build
  toolchain that includes the package and project depen)HY(dency)YH( managers, it does
  not depend on them and its stan)HY(dalone)YH( usage is the only subject of this
  manual.)EP(

  )0 P(We begin with a tuto)HY(rial)YH( intro)HY(duc)HY(tion)YH( that aims to show the essen)HY(tial)YH(
  elements of the build system on real exam)HY(ples)YH( but without getting into too
  much detail. Specif)HY(i)HY(cally)YH(, we want to quickly get to the point where we can
  build useful executable and library projects.)EP(

  )0 2 2 H(1.1)WB 38 Sn()WB 4 Sn( Hello, World)EH(

  )0 P(Let's start with the custom)HY(ary)YH( )I("Hello, World")ES( example: a single
  source file from which we would like to build an executable:)EP(

  ) 12 44 PR($ tree hello/
hello/
`-- hello.cxx

$ cat hello/hello.cxx

#include <iostream>

int main \201\202
{
  std::cout << "Hello, World!" << std::endl;
})RP(

  )0 P(While this very basic program hardly resem)HY(bles)YH( what most soft)HY(ware)YH(
  projects look like today, it is useful for intro)HY(duc)HY(ing)YH( key build system
  concepts without getting over)HY(whelmed)YH(. In this spirit we will also use the
  )SM(build2)ES( )I(simple project)ES( struc)HY(ture)YH(, which, simi)HY(larly)YH(,
  should not be used for anything but quick sketches.)EP(

  )0 P(To turn our )SM(hello/)ES( direc)HY(tory)YH( into a simple project all we
  need to do is add a )SM(build)HY(file)YH()ES(:)EP(

  ) 10 26 PR($ tree hello/
hello/
|-- hello.cxx
`-- buildfile

$ cat hello/buildfile

using cxx

exe{hello}: cxx{hello.cxx})RP(

  )0 P(Let's start from the bottom: the second line is a )I(depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH()ES(. On the left hand side of )SM(:)ES( we have a
  )I(target)ES(, the )SM(hello)ES( executable, and on the right hand side
  \235 a )I(prereq)HY(ui)HY(site)YH()ES(, the )SM(hello.cxx)ES( source file. Those
  )SM(exe)ES( and )SM(cxx)ES( in )SM(exe{...})ES( and
  )SM(cxx{...})ES( are called )I(target types)ES(. In fact, for clarity,
  target type names are always mentioned with trail)HY(ing)YH( )SM({})ES(, for
  example, "the )SM(exe{})ES( target type denotes an executable".)EP(

  )0 P(Notice that the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( does not specify )I(how)ES( to
  build an executable from a C++ source file \235 this is the job of a
  )I(rule)ES(. When the build system needs to update a target, it tries to
  )I(match)ES( a suit)HY(able)YH( rule based on the types of the target and its
  prereq)HY(ui)HY(sites)YH(. The )SM(build2)ES( core has a number of prede)HY(fined)YH(
  funda)HY(men)HY(tal)YH( rules with the rest coming from )I(build system modules)ES(. For
  example, the )SM(cxx)ES( module defines a number of rules for compil)HY(ing)YH(
  C++ source code as well as linking executa)HY(bles)YH( and libraries.)EP(

  )0 P(It should now be easy to guess what the first line of our
  )SM(build)HY(file)YH()ES( does: it loads the )SM(cxx)ES( module which
  defines the rules neces)HY(sary)YH( to build our program \201it also regis)HY(ters)YH( the
  )SM(cxx{})ES( target type\202.)EP(

  )0 P(Let's now try to build and run our program \201)SM(b)ES( is the build
  system driver\202:)EP(

  ) 16 38 PR($ cd hello/  # Change to project root.

$ b
c++ cxx{hello}
ld exe{hello}

$ ls -1
buildfile
hello.cxx
hello
hello.d
hello.o
hello.o.d

$ ./hello
Hello, World!)RP(

  )0 P(Or, if we are on Windows and using Visual Studio, from the Visual Studio
  devel)HY(op)HY(ment)YH( command prompt:)EP(

  ) 16 15 PR(> cd hello

> b
c++ cxx{hello}
ld exe{hello}

> dir /b
buildfile
hello.cxx
hello.exe
hello.exe.d
hello.exe.obj
hello.exe.obj.d

> .\200hello.exe
Hello, World!)RP(

  )0 P(By default )SM(build2)ES( uses the same C++ compiler it was built
  with and without passing any extra options, such as debug or opti)HY(miza)HY(tion)YH(.
  To change these defaults we use )I(config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH()ES(. For example,
  to specify a differ)HY(ent)YH( C++ compiler we use )SM(config.cxx)ES(:)EP(

  ) 1 22 PR($ b config.cxx=clang++)RP(

  )0 P(And for addi)HY(tional)YH( compile options, such as debug infor)HY(ma)HY(tion)YH( or
  opti)HY(miza)HY(tion)YH( level, there is )SM(config.cxx.coptions)ES(. For
  example:)EP(

  ) 1 45 PR($ b config.cxx=clang++ config.cxx.coptions=-g)RP(

  )BR(
  )0 P(These and other config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( will be discussed in more detail
  later. We will also learn how to make our config)HY(u)HY(ra)HY(tion)YH( persis)HY(tent)YH( so that
  we don't have to repeat such long command lines on every build system
  invo)HY(ca)HY(tion)YH(.)EP(

  )0 P(Similar to )SM(config.cxx)ES(, there is also )SM(config.c)ES(
  for spec)HY(i)HY(fy)HY(ing)YH( the C compiler. Note, however, that if your project uses both
  C and C++, then you normally only need to specify one of them \235
  )SM(build2)ES( will deter)HY(mine)YH( the other auto)HY(mat)HY(i)HY(cally)YH(.)EP(
  )BR(

  )0 P(Let's discuss a few points about the build output. Firstly, to reduce the
  noise, the commands being executed are by default shown abbre)HY(vi)HY(ated)YH( and with
  the same target type nota)HY(tion)YH( as we used in the )SM(build)HY(file)YH()ES(. For
  example:)EP(

  ) 2 14 PR(c++ cxx{hello}
ld exe{hello})RP(

  )0 P(If, however, you would like to see the actual command lines, you can pass
  )SM(-v)ES( \201to see even more, there is the )SM(-V)ES( as well as
  )SM(--verbose)ES( options; see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details\202. For example:)EP(

  ) 3 27 PR($ b -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o)RP(

  )0 P(Most of the files produced by the build system should be
  self-explana)HY(tory)YH(: we have the object file \201)SM(hello.o)ES(,
  )SM(hello.obj)ES(\202 and executable \201)SM(hello)ES(,
  )SM(hello.exe)ES(\202. For each of them we also have the corre)HY(spond)HY(ing)YH(
  )SM(.d)ES( files which store the )I(auxil)HY(iary)YH( depen)HY(dency)YH(
  infor)HY(ma)HY(tion)YH()ES(, things like compile options, header depen)HY(den)HY(cies)YH(, etc.)EP(

  )0 P(To remove the build system output we use the )SM(clean)ES(
  )I(oper)HY(a)HY(tion)YH()ES( \201if no oper)HY(a)HY(tion)YH( is spec)HY(i)HY(fied)YH(, the default is
  )SM(update)ES(\202:)EP(

  ) 7 14 PR($ b clean
rm exe{hello}
rm obje{hello}

$ ls -1
buildfile
hello.cxx)RP(

  )0 P(One of the main reasons behind the )I(target type)ES( concept is the
  plat)HY(form)YH(/compiler-spec)HY(i)HY(fied)YH( vari)HY(ances)YH( in file names as illus)HY(trated)YH( by the
  above list)HY(ings)YH(. In our )SM(build)HY(file)YH()ES( we refer to the executable
  target as )SM(exe{hello})ES(, not as )SM(hello.exe)ES( or
  )SM(hello$EXT)ES(. The actual file exten)HY(sion)YH(, if any, will be
  deter)HY(mined)YH( based on the compiler's target plat)HY(form)YH( by the rule doing the
  linking. In this sense, target types are a plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( replace)HY(ment)YH(
  of file exten)HY(sions)YH( \201though they do have other bene)HY(fits)YH(, such as allow)HY(ing)YH(
  non-file targets as well as being hier)HY(ar)HY(chi)HY(cal)YH(\202.)EP(

  )0 P(Let's revisit the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( line from our
  )SM(build)HY(file)YH()ES(:)EP(

  ) 1 26 PR(exe{hello}: cxx{hello.cxx})RP(

  )0 P(In light of target types replac)HY(ing)YH( file exten)HY(sions)YH( this looks
  tauto)HY(log)HY(i)HY(cal)YH(: why do we need to specify both the )SM(cxx{})ES( target
  type )I(and)ES( the )SM(.cxx)ES( file exten)HY(sion)YH(? In fact, we don't have
  to if we specify the default file exten)HY(sion)YH( for the )SM(cxx{})ES(
  target type. Here is our updated )SM(build)HY(file)YH()ES( in its entirety:)EP(

  ) 5 23 PR(using cxx

cxx{*}: extension = cxx

exe{hello}: cxx{hello})RP(

  )0 P(Let's unpack the new line. What we have here is a )I(target
  type/pattern-specific vari)HY(able)YH()ES(. It only applies to targets of the
  )SM(cxx{})ES( type whose names match the )SM(*)ES( wild)HY(card)YH(
  pattern. The )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( name is reserved by the
  )SM(build2)ES( core for spec)HY(i)HY(fy)HY(ing)YH( target type exten)HY(sions)YH(.)EP(

  )0 P(Let's see how all these pieces fit together. When the build system needs
  to update )SM(exe{hello})ES(, it searches for a suit)HY(able)YH( rule. A rule
  from the )SM(cxx)ES( module matches since it knows how to build a
  target of type )SM(exe{})ES( from a prereq)HY(ui)HY(site)YH( of type
  )SM(cxx{})ES(. When the matched rule is )I(applied)ES(, it searches for
  a target for the )SM(cxx{hello})ES( prereq)HY(ui)HY(site)YH(. During this search,
  the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( is looked up and its value is used to
  end up with the )SM(hello.cxx)ES( file.)EP(

  )0 P(Here is our new depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( again:)EP(

  ) 1 22 PR(exe{hello}: cxx{hello})RP(

  )0 P(It has the canon)HY(i)HY(cal)YH( form: no exten)HY(sions)YH(, only target types. Some)HY(times)YH(
  explicit exten)HY(sion)YH( spec)HY(i)HY(fi)HY(ca)HY(tion)YH( is still neces)HY(sary)YH(, for example, if your
  project uses multi)HY(ple)YH( exten)HY(sions)YH( for the same file type. But if unnec)HY(es)HY(sary)YH(,
  it should be omitted for brevity.)EP(

  )BR(
  )0 P(If you prefer the )SM(.cpp)ES( file exten)HY(sion)YH( and your source file
  is called )SM(hello.cpp)ES(, then the only line in our
  )SM(build)HY(file)YH()ES( that needs chang)HY(ing)YH( is the )SM(exten)HY(sion)YH()ES(
  vari)HY(able)YH( assign)HY(ment)YH(:)EP(

  ) 1 23 PR(cxx{*}: extension = cpp)RP(
  )BR(

  )0 P(Let's say our )SM(hello)ES( program got compli)HY(cated)YH( enough to
  warrant moving some func)HY(tion)HY(al)HY(ity)YH( into a sepa)HY(rate)YH( source/header module \201or a
  real C++ module\202. For example:)EP(

  ) 6 15 PR($ tree hello/
hello/
|-- hello.cxx
|-- utility.hxx
|-- utility.cxx
`-- buildfile)RP(

  )0 P(This is what our updated )SM(build)HY(file)YH()ES( could look like:)EP(

  ) 6 48 PR(using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx

exe{hello}: cxx{hello} hxx{utility} cxx{utility})RP(

  )0 P(Nothing really new here: we've spec)HY(i)HY(fied)YH( the default exten)HY(sion)YH( for the
  )SM(hxx{})ES( target type and listed the new header and source files as
  prereq)HY(ui)HY(sites)YH(. If you have expe)HY(ri)HY(ence)YH( with other build systems, then
  explic)HY(itly)YH( listing headers might seem strange to you. As will be discussed
  later, in )SM(build2)ES( we have to explic)HY(itly)YH( list all the
  prereq)HY(ui)HY(sites)YH( of a target that should end up in a distri)HY(bu)HY(tion)YH( of our
  project.)EP(

  )BR(
  )0 P(You don't have to list )I(all)ES( headers that you include, only the ones
  belong)HY(ing)YH( to your project. Like all modern C/C++ build systems,
  )SM(build2)ES( performs auto)HY(matic)YH( header depen)HY(dency)YH( extrac)HY(tion)YH(.)EP(
  )BR(

  )0 P(In real projects with a substan)HY(tial)YH( number of source files, repeat)HY(ing)YH(
  target types and names will quickly become noisy. To tidy things up we can
  use )I(name gener)HY(a)HY(tion)YH()ES(. Here are a few exam)HY(ples)YH( of depen)HY(dency)YH(
  decla)HY(ra)HY(tions)YH( equiv)HY(a)HY(lent)YH( to the above:)EP(

  ) 2 43 PR(exe{hello}: cxx{hello utility} hxx{utility}
exe{hello}: cxx{hello} {hxx cxx}{utility})RP(

  )0 P(The last form is prob)HY(a)HY(bly)YH( the best choice if your project contains a
  large number of header/source pairs. Here is a more real)HY(is)HY(tic)YH( example:)EP(

  ) 3 44 PR(exe{hello}: {    cxx}{hello}               \200
            {hxx    }{forward types}       \200
            {hxx cxx}{format print utility})RP(

  )0 P(Manu)HY(ally)YH( listing a prereq)HY(ui)HY(site)YH( every time we add a new source file to
  our project is both tedious and error prone. Instead, we can auto)HY(mate)YH( our
  depen)HY(dency)YH( decla)HY(ra)HY(tions)YH( with )I(wild)HY(card)YH( name patterns)ES(. For example:)EP(

  ) 1 24 PR(exe{hello}: {hxx cxx}{*})RP(

  )0 P(Based on the previ)HY(ous)YH( discus)HY(sion)YH( of default exten)HY(sions)YH(, you can prob)HY(a)HY(bly)YH(
  guess how this works: for each target type the value of the
  )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( is added to the pattern and files match)HY(ing)YH(
  the result become prereq)HY(ui)HY(sites)YH(. So, in our case, we will end up with files
  match)HY(ing)YH( the )SM(*.hxx)ES( and )SM(*.cxx)ES( wild)HY(card)YH(
  patterns.)EP(

  )0 P(In more complex projects it is often conve)HY(nient)YH( to orga)HY(nize)YH( source code
  into subdi)HY(rec)HY(to)HY(ries)YH(. To handle such projects we can use the recur)HY(sive)YH(
  wild)HY(card)YH(:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  )BR(
  )0 P(Using wild)HY(cards)YH( is some)HY(what)YH( contro)HY(ver)HY(sial)YH(. Patterns defi)HY(nitely)YH( make
  devel)HY(op)HY(ment)YH( more pleas)HY(ant)YH( and less error prone: you don't need to update
  your )SM(build)HY(file)YH()ES( every time you add, remove, or rename a source
  file and you won't forget to explic)HY(itly)YH( list headers, a mistake that is
  often only detected when trying to build a distri)HY(bu)HY(tion)YH( of a project. On the
  other hand, there is the possi)HY(bil)HY(ity)YH( of includ)HY(ing)YH( stray source files into
  your build without notic)HY(ing)YH(. And, for more complex projects, name patterns
  can become fairly complex \201see )0 21 1 A(Name Patterns)21 0 TN TL()Ec /AF f D(
  for details\202. Note also that on modern hard)HY(ware)YH( the perfor)HY(mance)YH( of wild)HY(card)YH(
  searches hardly warrants a consid)HY(er)HY(a)HY(tion)YH(.)EP(

  )0 P(In our expe)HY(ri)HY(ence)YH(, when combined with modern version control systems like
  )SM(git\2011\202)ES(, stray source files are rarely an issue and gener)HY(ally)YH(
  the bene)HY(fits)YH( of wild)HY(cards)YH( outweigh their draw)HY(backs)YH(. But, in the end, whether
  to use them or not is a personal choice and, as shown above,
  )SM(build2)ES( supports both approaches.)EP(
  )BR(

  )0 P(And that's about all there is to our )SM(hello)ES( example. To
  summa)HY(rize)YH(, we've seen that to build a simple project we need a single
  )SM(build)HY(file)YH()ES( which itself doesn't contain much more than a
  depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( for what we want to build. But we've also mentioned
  that simple projects are only really meant for quick sketches. So let's
  convert our )SM(hello)ES( example to the )I(stan)HY(dard)YH( project)ES(
  struc)HY(ture)YH( which is what we will be using for most of our real
  devel)HY(op)HY(ment)YH(.)EP(

  )BR(
  )0 P(Simple projects have so many restric)HY(tions)YH( and limi)HY(ta)HY(tions)YH( that they are
  hardly usable for anything but, well, )I(really)ES( simple projects.
  Specif)HY(i)HY(cally)YH(, such projects cannot be imported by other projects nor can
  they use build system modules that require boot)HY(strap)HY(ping)YH(. This includes
  )SM(test)ES(, )SM(install)ES(, )SM(dist)ES(, and
  )SM(config)ES( modules. And without the )SM(config)ES( module
  there is no support for persis)HY(tent)YH( config)HY(u)HY(ra)HY(tions)YH(. As a result, you should
  only use a simple project if you are happy to always build in the source
  direc)HY(tory)YH( and with the default build config)HY(u)HY(ra)HY(tion)YH( or willing to specify the
  output direc)HY(tory)YH( and/or custom config)HY(u)HY(ra)HY(tion)YH( on every invo)HY(ca)HY(tion)YH(.)EP(
  )BR(

  )0 2 3 H(1.2)WB 39 Sn()WB 5 Sn( Project Struc)HY(ture)YH()EH(

  )0 P(A )SM(build2)ES( )I(stan)HY(dard)YH( project)ES( has the follow)HY(ing)YH( overall
  layout:)EP(

  ) 6 23 PR(hello/
|-- build/
|   |-- bootstrap.build
|   `-- root.build
|-- ...
`-- buildfile)RP(

  )0 P(Specif)HY(i)HY(cally)YH(, the project's root direc)HY(tory)YH( should contain the
  )SM(build/)ES( subdi)HY(rec)HY(tory)YH( as well as the root )SM(build)HY(file)YH()ES(.
  The )SM(build/)ES( subdi)HY(rec)HY(tory)YH( contains project-wide build system
  infor)HY(ma)HY(tion)YH(.)EP(

  )BR(
  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command is an easy way to create the stan)HY(dard)YH( layout executable
  \201)SM(-t\240exe)ES(\202 and library \201)SM(-t\240lib)ES(\202 projects.
  To change the C++ file exten)HY(sions)YH( to )SM(.hpp/.cpp)ES(, pass )SM(-l
  c++,cpp)ES(. For example:)EP(

  ) 1 44 PR($ bdep new --no-init -t exe -l c++,cpp hello)RP(
  )BR(

  )BR(
  )0 P(It is also possi)HY(ble)YH( to use an alter)HY(na)HY(tive)YH( build file/direc)HY(tory)YH( naming
  scheme where every instance of the word )I(build)ES( is replaced with
  )I(build2)ES(, for example:)EP(

  ) 6 24 PR(hello/
|-- build2/
|   |-- bootstrap.build2
|   `-- root.build2
|-- ...
`-- build2file)RP(

  )0 P(Note that the naming must be consis)HY(tent)YH( within a project with all the
  filesys)HY(tem)YH( entries either follow)HY(ing)YH( )I(build)ES( or )I(build2)ES( scheme. In
  other words, we cannot call the direc)HY(tory)YH( )SM(build2/)ES( while still
  using )SM(build)HY(file)YH()ES(.)EP(

  )0 P(The alter)HY(na)HY(tive)YH( naming scheme is primar)HY(ily)YH( useful when adding
  )SM(build2)ES( support to an exist)HY(ing)YH( project along with other build
  systems. In this case, the fairly generic stan)HY(dard)YH( names might already be in
  use. For example, it is custom)HY(ary)YH( to have )SM(build/)ES( in
  )SM(.gitig)HY(nore)YH()ES(. Plus more specific naming will make it easier to
  iden)HY(tify)YH( files and direc)HY(to)HY(ries)YH( as belong)HY(ing)YH( to the )SM(build2)ES(
  support. For new projects as well as for exist)HY(ing)YH( projects that are
  switch)HY(ing)YH( exclu)HY(sively)YH( to )SM(build2)ES( the stan)HY(dard)YH( naming scheme is
  recom)HY(mended)YH(.)EP(

  )0 P(To create a project with the alter)HY(na)HY(tive)YH( naming using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  pass the )SM(alt-naming)ES( project type sub-option. For example:)EP(

  ) 1 32 PR($ bdep new -t exe,alt-naming ...)RP(
  )BR(

  )0 P(To support lazy loading of subpro)HY(jects)YH( \201discussed later\202, reading of the
  project's build infor)HY(ma)HY(tion)YH( is split into two phases: boot)HY(strap)HY(ping)YH( and
  loading. During boot)HY(strap)HY(ping)YH( the project's
  )SM(build/boot)HY(strap)YH(.build)ES( file is read. Then, when \201and if\202 the
  project is loaded completely, its )SM(build/root.build)ES( file is read
  followed by the )SM(build)HY(file)YH()ES( \201normally from the project root but
  possi)HY(bly)YH( from a subdi)HY(rec)HY(tory)YH(\202.)EP(

  )0 P(The )SM(boot)HY(strap)YH(.build)ES( file is required. Let's see what it
  would look like for a typical project using our )SM(hello)ES( as an
  example:)EP(

  ) 7 15 PR(project = hello

using version
using config
using test
using install
using dist)RP(

  )0 P(The first non-comment line in )SM(boot)HY(strap)YH(.build)ES( should be the
  assign)HY(ment)YH( of the project name to the )SM(project)ES( vari)HY(able)YH(. After
  that, a typical )SM(boot)HY(strap)YH(.build)ES( file loads a number of build
  system modules. While most modules can be loaded during the project load
  phase in )SM(root.build)ES(, certain modules have to be loaded early,
  while boot)HY(strap)HY(ping)YH( \201for example, because they define new oper)HY(a)HY(tions)YH(\202.)EP(

  )0 P(Let's examine briefly the modules loaded by our
  )SM(boot)HY(strap)YH(.build)ES(: The )0 24 1 A()SM(version)ES()24 0 TN TL()Ec /AF f D( module helps with manag)HY(ing)YH(
  our project version)HY(ing)YH(. With this module we only main)HY(tain)YH( the version in a
  single place \201project's )SM(mani)HY(fest)YH()ES( file\202 and it is auto)HY(mat)HY(i)HY(cally)YH(
  made avail)HY(able)YH( in various conve)HY(nient)YH( forms through)HY(out)YH( our project
  \201)SM(build)HY(files)YH()ES(, header files, etc\202. The )SM(version)ES(
  module also auto)HY(mates)YH( version)HY(ing)YH( of snap)HY(shots)YH( between releases.)EP(

  )0 P(The )SM(mani)HY(fest)YH()ES( file is what makes our build system project a
  )I(package)ES(. It contains all the meta)HY(data)YH( that a user of a package might
  need to know: name, version, depen)HY(den)HY(cies)YH(, etc., all in one place. However,
  even if you don't plan to package your project, it is a good idea to create
  a basic )SM(mani)HY(fest)YH()ES( if only to take advan)HY(tage)YH( of the version
  manage)HY(ment)YH( offered by the )SM(version)ES( module. So let's go ahead and
  add it next to our root )SM(build)HY(file)YH()ES(:)EP(

  ) 13 29 PR($ tree hello/
hello/
|-- build/
|   `-- ...
|-- ...
|-- buildfile
`-- manifest

$ cat hello/manifest
: 1
name: hello
version: 0.1.0
summary: hello C++ executable)RP(

  )0 P(The )SM(config)ES( module provides support for persis)HY(tent)YH(
  config)HY(u)HY(ra)HY(tions)YH(. While project config)HY(u)HY(ra)HY(tion)YH( is a large topic that we will
  discuss in detail later, in a nutshell )SM(build2)ES( support for
  config)HY(u)HY(ra)HY(tion)YH( is an inte)HY(gral)YH( part of the build system with the same
  mech)HY(a)HY(nisms)YH( avail)HY(able)YH( to the build system core, modules, and your projects.
  However, without )SM(config)ES(, the config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( is
  )I(tran)HY(sient)YH()ES(. That is, what)HY(ever)YH( config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( was
  auto)HY(mat)HY(i)HY(cally)YH( discov)HY(ered)YH( or that you have supplied on the command line is
  discarded after each build system invo)HY(ca)HY(tion)YH(. With the )SM(config)ES(
  module, however, we can )I(config)HY(ure)YH()ES( a project to make the config)HY(u)HY(ra)HY(tion)YH(
  )I(persis)HY(tent)YH()ES(. We will see an example of this shortly.)EP(

  )0 P(Next up are the )SM(test)ES(, )SM(install)ES(, and
  )SM(dist)ES( modules. As their names suggest, they provide support for
  testing, instal)HY(la)HY(tion)YH( and prepa)HY(ra)HY(tion)YH( of distri)HY(bu)HY(tions)YH(. Specif)HY(i)HY(cally)YH(, the
  )SM(test)ES( module defines the )SM(test)ES( oper)HY(a)HY(tion)YH(, the
  )SM(install)ES( module defines the )SM(install)ES( and
  )SM(unin)HY(stall)YH()ES( oper)HY(a)HY(tions)YH(, and the )SM(dist)ES( module defines
  the )SM(dist)ES( \201meta-\202oper)HY(a)HY(tion)YH(. Again, we will try them out in a
  moment.)EP(

  )0 P(Moving on, the )SM(root.build)ES( file is optional though most
  projects will have it. This is the place where we normally estab)HY(lish)YH(
  project-wide settings as well as load build system modules that provide
  support for the languages/tools that we use. Here is what it could look like
  for our )SM(hello)ES( example:)EP(

  ) 6 23 PR(cxx.std = latest

using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx)RP(

  )0 P(As you can see, we've moved the loading of the )SM(cxx)ES( modules
  and setting of the default file exten)HY(sions)YH( from the root
  )SM(build)HY(file)YH()ES( in our simple project to )SM(root.build)ES( when
  using the stan)HY(dard)YH( layout. We've also set the )SM(cxx.std)ES( vari)HY(able)YH(
  to tell the )SM(cxx)ES( module to select the latest C++ stan)HY(dard)YH(
  avail)HY(able)YH( in any partic)HY(u)HY(lar)YH( C++ compiler this project might be built
  with.)EP(

  )BR(
  )0 P(Select)HY(ing)YH( the C++ stan)HY(dard)YH( for our project is a messy issue. If we don't
  specify the stan)HY(dard)YH( explic)HY(itly)YH( with )SM(cxx.std)ES(, then the default
  stan)HY(dard)YH( in each compiler will be used, which, currently, can range from
  C++98 to C++14. So unless you care)HY(fully)YH( write your code to work with any
  stan)HY(dard)YH(, this is prob)HY(a)HY(bly)YH( not a good idea.)EP(

  )0 P(Fixing the stan)HY(dard)YH( \201for example, to )SM(c++11)ES(,
  )SM(c++14)ES(, etc\202 should work theo)HY(ret)HY(i)HY(cally)YH(. In prac)HY(tice)YH(, however,
  compil)HY(ers)YH( add support for new stan)HY(dards)YH( incre)HY(men)HY(tally)YH( and many versions,
  while perfectly usable, are not feature-complete. As a result, a better
  prac)HY(ti)HY(cal)YH( strat)HY(egy)YH( is to specify the set of minimum supported compiler
  versions rather than the C++ stan)HY(dard)YH(.)EP(

  )0 P(There is also the issue of using libraries that require newer stan)HY(dard)YH( in
  older code. For example, headers from a library that relies on C++14
  features will not compile when included in a project that is built as C++11.
   And, even if the headers compile \201that is, C++14 features are only used in
  the imple)HY(men)HY(ta)HY(tion)YH(\202, strictly speak)HY(ing)YH(, there is no guar)HY(an)HY(tee)YH( that code)HY(bases)YH(
  compiled with differ)HY(ent)YH( C++ stan)HY(dards)YH( are ABI compat)HY(i)HY(ble)YH( \201in fact, some
  changes to the C++ language leave the imple)HY(men)HY(ta)HY(tions)YH( no choice but to break
  the ABI\202.)EP(

  )0 P(As result, our recom)HY(men)HY(da)HY(tion)YH( is to set the stan)HY(dard)YH( to
  )SM(latest)ES( and specify the minimum supported compil)HY(ers)YH( and versions
  in your project's docu)HY(men)HY(ta)HY(tion)YH( \201see package mani)HY(fest)YH( )0 2 A()SM(requires)ES()EA(
  value for one possi)HY(ble)YH( place\202. Prac)HY(ti)HY(cally)YH(, this should allow you to include
  and link any library, regard)HY(less)YH( of the C++ stan)HY(dard)YH( that it uses.)EP(
  )BR(

  )0 P(Let's now take a look at the root )SM(build)HY(file)YH()ES(:)EP(

  ) 1 16 PR(./: {*/ -build/})RP(

  )0 P(In plain English, this )SM(build)HY(file)YH()ES( declares that build)HY(ing)YH( this
  direc)HY(tory)YH( \201and, since it's the root of our project, build)HY(ing)YH( this entire
  project\202 means build)HY(ing)YH( all its subdi)HY(rec)HY(to)HY(ries)YH( exclud)HY(ing)YH(
  )SM(build/)ES(. Let's now try to under)HY(stand)YH( how this is actu)HY(ally)YH(
  achieved.)EP(

  )0 P(We already know this is a depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(, )SM(./)ES( is the
  target, and what's after )SM(:)ES( are its prereq)HY(ui)HY(sites)YH(, which seem to
  be gener)HY(ated)YH( with some kind of a name pattern \201the wild)HY(card)YH( char)HY(ac)HY(ter)YH( in
  )SM(*/)ES( should be the give)HY(away)YH(\202. What's unusual about this
  decla)HY(ra)HY(tion)YH(, however, is the lack of any target types plus that
  strange-looking )SM(./)ES(.)EP(

  )0 P(Let's start with the missing target types. In fact, the above
  )SM(build)HY(file)YH()ES( can be rewrit)HY(ten)YH( as:)EP(

  ) 1 21 PR(dir{.}: dir{* -build})RP(

  )0 P(So the trail)HY(ing)YH( slash \201always forward, even on Windows\202 is a special
  short)HY(hand)YH( nota)HY(tion)YH( for )SM(dir{})ES(. As we will see shortly, it fits
  natu)HY(rally)YH( with other uses of direc)HY(to)HY(ries)YH( in )SM(build)HY(files)YH()ES( \201for
  example, in scopes\202.)EP(

  )0 P(The )SM(dir{})ES( target type is an )I(alias)ES( \201and, in fact, is
  derived from more general )SM(alias{})ES(\202. Build)HY(ing)YH( it means build)HY(ing)YH(
  all its prereq)HY(ui)HY(sites)YH(.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with )SM(make)ES(, then you can prob)HY(a)HY(bly)YH( see the
  simi)HY(lar)HY(ity)YH( with the ubiq)HY(ui)HY(tous)YH( )SM(all)ES( pseudo-target. In
  )SM(build2)ES( we instead use direc)HY(tory)YH( names as more natural aliases
  for the "build every)HY(thing)YH( in this direc)HY(tory)YH(" seman)HY(tics)YH(.)EP(

  )0 P(Note also that )SM(dir{})ES( is purely an alias and doesn't have
  anything to do with the filesys)HY(tem)YH(. In partic)HY(u)HY(lar)YH(, it does not create any
  direc)HY(to)HY(ries)YH(. If you do want explicit direc)HY(tory)YH( creation \201which should be
  rarely needed\202, use the )SM(fsdir{)ES(} target type instead.)EP(
  )BR(

  )0 P(The )SM(./)ES( target is a special )I(default target)ES(. If we run
  the build system without spec)HY(i)HY(fy)HY(ing)YH( the target explic)HY(itly)YH(, then this target
  is built by default. Every )SM(build)HY(file)YH()ES( has the )SM(./)ES(
  target. If we don't declare it explic)HY(itly)YH(, then its decla)HY(ra)HY(tion)YH( is implied
  with the first target in the )SM(build)HY(file)YH()ES( as its prereq)HY(ui)HY(site)YH(.
  Recall our )SM(build)HY(file)YH()ES( from the simple )SM(hello)ES(
  project:)EP(

  ) 1 22 PR(exe{hello}: cxx{hello})RP(

  )0 P(It is equiv)HY(a)HY(lent)YH( to:)EP(

  ) 2 22 PR(./: exe{hello}
exe{hello}: cxx{hello})RP(

  )0 P(If, however, we had several targets in the same direc)HY(tory)YH( that we wanted
  built by default, then we would need to explic)HY(itly)YH( list them as
  prereq)HY(ui)HY(sites)YH( of the default target. For example:)EP(

  ) 5 24 PR(./: exe{hello}
exe{hello}: cxx{hello}

./: exe{goodby}
exe{goodby}: cxx{goodby})RP(

  )0 P(While straight)HY(for)HY(ward)YH(, this is some)HY(what)YH( inel)HY(e)HY(gant)YH( in its repet)HY(i)HY(tive)HY(ness)YH(.
  To tidy things up we can use )I(depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( chains)ES( that allow
  us to chain together several target-prereq)HY(ui)HY(site)YH( decla)HY(ra)HY(tions)YH( in a single
  line. For example:)EP(

  ) 3 28 PR(./: exe{hello}: cxx{hello}

./: exe{goodby}: cxx{goodby})RP(

  )0 P(With depen)HY(dency)YH( chains a prereq)HY(ui)HY(site)YH( of the preced)HY(ing)YH( target becomes a
  target itself for the follow)HY(ing)YH( prereq)HY(ui)HY(sites)YH(.)EP(

  )0 P(Let's get back to our root )SM(build)HY(file)YH()ES(:)EP(

  ) 1 16 PR(./: {*/ -build/})RP(

  )0 P(The last unex)HY(plained)YH( bit is the )SM({*/\240-build/})ES( name
  pattern. All it does is exclude )SM(build/)ES( from the subdi)HY(rec)HY(to)HY(ries)YH(
  to build. See )0 21 1 A(Name Patterns)21 0 TN TL()Ec /AF f D( for details.)EP(

  )0 P(Let's take a look at a slightly more real)HY(is)HY(tic)YH( root
  )SM(build)HY(file)YH()ES(:)EP(

  ) 1 48 PR(./: {*/ -build/} doc{README.md LICENSE} manifest)RP(

  )0 P(Here we have the custom)HY(ary)YH( )SM(README.md)ES( and
  )SM(LICENSE)ES( files as well as the package )SM(mani)HY(fest)YH()ES(.
  Listing them as prereq)HY(ui)HY(sites)YH( achieves two things: they will be installed
  if/when our project is installed and, as mentioned earlier, they will be
  included into the project distri)HY(bu)HY(tion)YH(.)EP(

  )0 P(The )SM(README.md)ES( and )SM(LICENSE)ES( files use the
  )SM(doc{})ES( target type. We could have used the generic
  )SM(file{})ES( but using the more precise )SM(doc{})ES( makes sure
  that they are installed into the appro)HY(pri)HY(ate)YH( docu)HY(men)HY(ta)HY(tion)YH( direc)HY(tory)YH(. The
  )SM(mani)HY(fest)YH()ES( file doesn't need an explicit target type since it has
  a fixed name \201)SM(mani)HY(fest)YH({mani)HY(fest)YH(})ES( is valid but redun)HY(dant)YH(\202.)EP(

  )0 P(Stan)HY(dard)YH( project infras)HY(truc)HY(ture)YH( in place, where should we put our source
  code? While we could have every)HY(thing)YH( in the root direc)HY(tory)YH( of our project,
  just like we did with the simple layout, it is recom)HY(mended)YH( to instead place
  the source code into a subdi)HY(rec)HY(tory)YH( named the same as the project. For
  example:)EP(

  ) 9 17 PR(hello/
|-- build/
|   `-- ...
|-- hello/
|   |-- hello.cxx
|   `-- buildfile
|-- buildfile
|-- manifest
`-- README.md)RP(

  )BR(
  )0 P(There are several reasons for this layout: It imple)HY(ments)YH( the canon)HY(i)HY(cal)YH(
  inclu)HY(sion)YH( scheme where each header is prefixed with its project name. It
  also has a predictable name where users can expect to find our project's
  source code. Finally, this layout prevents clutter in the project's root
  direc)HY(tory)YH( which usually contains various other files. See )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( for more infor)HY(ma)HY(tion)YH(.)EP(

  )0 P(Note also that while we can name our header and source files however we
  like \201but, again, see )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( for some sensi)HY(ble)YH( guide)HY(lines)YH(\202, C++ module inter)HY(face)YH(
  files need to embed a suffi)HY(cient)YH( amount of the module name suffix in their
  names to unam)HY(bigu)HY(ously)YH( resolve all the modules within a project. See )0 29 1 A(Build)HY(ing)YH( Modules)29 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 P(The source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES( is iden)HY(ti)HY(cal)YH( to the simple
  project's minus the parts moved to )SM(root.build)ES(:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  )0 P(Let's now build our project and see where the build system output ends up
  in this new layout:)EP(

  ) 21 38 PR($ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello}
ld hello/exe{hello}

$ tree ./
./
|-- build/
|   `-- ...
|-- hello/
|   |-- hello.cxx
|   |-- hello
|   |-- hello.d
|   |-- hello.o
|   |-- hello.o.d
|   `-- buildfile
|-- buildfile
`-- manifest

$ hello/hello
Hello, World!)RP(

  )0 P(If we don't specify a target to build \201as we did above\202, then
  )SM(build2)ES( will build the current direc)HY(tory)YH( or, more precisely, the
  default target in the )SM(build)HY(file)YH()ES( in the current direc)HY(tory)YH(. We
  can also build a direc)HY(tory)YH( other than the current, for example:)EP(

  ) 1 10 PR($ b hello/)RP(

  )BR(
  )0 P(Note that the trail)HY(ing)YH( slash is required. In fact, )SM(hello/)ES( in
  the above command line is a target and is equiv)HY(a)HY(lent)YH( to
  )SM(dir{hello})ES(, just like in the )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(Or we can build a specific target:)EP(

  ) 1 20 PR($ b hello/exe{hello})RP(

  )0 P(Natu)HY(rally)YH(, nothing prevents us from build)HY(ing)YH( multi)HY(ple)YH( targets or even
  projects in the same build system invo)HY(ca)HY(tion)YH(. For example, if we had the
  )SM(libhello)ES( project next to our )SM(hello/)ES(, then we could
  build both at once:)EP(

  ) 5 20 PR($ ls -1
hello/
libhello/

$ b hello/ libhello/)RP(

  )0 P(Speak)HY(ing)YH( of libraries, let's see what the stan)HY(dard)YH( project struc)HY(ture)YH(
  looks like for one, using )SM(libhello)ES( created by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( as
  an example:)EP(

  ) 19 36 PR($ bdep new --no-init -t lib libhello

$ tree libhello/
libhello/
|-- build/
|   |-- bootstrap.build
|   |-- root.build
|   `-- export.build
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   |-- export.hxx
|   |-- version.hxx.in
|   `-- buildfile
|-- tests/
|   `--  ...
|-- buildfile
|-- manifest
`-- README.md)RP(

  )0 P(The overall layout \201)SM(build/)ES(, )SM(libhello/)ES( source
  direc)HY(tory)YH(\202 as well as the contents of the root files
  \201)SM(boot)HY(strap)YH(.build)ES(, )SM(root.build)ES(, root
  )SM(build)HY(file)YH()ES(\202 are exactly the same. There is, however, a new file,
  )SM(export.build)ES(, in )SM(build/)ES(, a new subdi)HY(rec)HY(tory)YH(,
  )SM(tests/)ES(, and the contents of the project's source subdi)HY(rec)HY(tory)YH(,
  )SM(libhello/)ES(, look quite a bit differ)HY(ent)YH(. We will examine all of
  these differ)HY(ences)YH( in the coming sections, as we learn more about the build
  system.)EP(

  )BR(
  )0 P(The stan)HY(dard)YH( project struc)HY(ture)YH( is not type \201executable, library, etc\202 or
  even language specific. In fact, the same project can contain multi)HY(ple)YH(
  executa)HY(bles)YH( and/or libraries \201for example, both )SM(hello)ES( and
  )SM(libhello)ES(\202. However, if you plan to package your projects, it is
  a good idea to keep them as sepa)HY(rate)YH( build system projects \201they can still
  reside in the same version control repos)HY(i)HY(tory)YH(, though\202.)EP(

  )0 P(Speak)HY(ing)YH( of projects, this term is unfor)HY(tu)HY(nately)YH( over)HY(loaded)YH( to mean two
  differ)HY(ent)YH( things at differ)HY(ent)YH( levels of soft)HY(ware)YH( orga)HY(ni)HY(za)HY(tion)YH(. At the bottom
  we have )I(build system projects)ES( which, if pack)HY(aged)YH(, become
  )I(pack)HY(ages)YH()ES(. And at the top, related pack)HY(ages)YH( are often grouped into
  what is also commonly referred to as )I(projects)ES(. At this point both
  usages are prob)HY(a)HY(bly)YH( too well estab)HY(lished)YH( to look for alter)HY(na)HY(tives)YH(.)EP(
  )BR(

  )0 P(And this completes the conver)HY(sion)YH( of our simple )SM(hello)ES(
  project to the stan)HY(dard)YH( struc)HY(ture)YH(. Earlier, when exam)HY(in)HY(ing)YH(
  )SM(boot)HY(strap)YH(.build)ES(, we mentioned that modules loaded in this file
  usually provide addi)HY(tional)YH( oper)HY(a)HY(tions)YH(. So we still need to discuss what
  exactly the term )I(build system oper)HY(a)HY(tion)YH()ES( means and see how to use
  oper)HY(a)HY(tions)YH( that are provided by the modules we have loaded. But before we do
  that, let's see how we can build our projects )I(out of source)ES( tree and
  learn about another corner)HY(stone)YH( )SM(build2)ES( concept:
  )I(scopes)ES(.)EP(

  )0 2 4 H(1.3)WB 40 Sn()WB 6 Sn( Output Direc)HY(to)HY(ries)YH( and Scopes)EH(

  )0 P(Two common require)HY(ments)YH( placed on modern build systems are the ability to
  build projects out of the source direc)HY(tory)YH( tree \201referred to as just )I(out
  of source)ES( vs )I(in source)ES(\202 as well as isola)HY(tion)YH( of
  )SM(build)HY(files)YH()ES( from each other when it comes to target and vari)HY(able)YH(
  names. In )SM(build2)ES( these mech)HY(a)HY(nisms)YH( are closely-related, inte)HY(gral)YH(
  parts of the build system.)EP(

  )BR(
  )0 P(This tight inte)HY(gra)HY(tion)YH( has advan)HY(tages)YH(, like being always avail)HY(able)YH( and
  working well with other build system mech)HY(a)HY(nisms)YH(, as well as disad)HY(van)HY(tages)YH(,
  like the inabil)HY(ity)YH( to imple)HY(ment)YH( a completely differ)HY(ent)YH( out of source
  arrange)HY(ment)YH( and/or isola)HY(tion)YH( model. In the end, if you find your)HY(self)YH(
  "fight)HY(ing)YH(" this aspect of )SM(build2)ES(, it will likely be easier to
  use a differ)HY(ent)YH( build system than subvert it.)EP(
  )BR(

  )0 P(Let's start with an example of an out of source build for our
  )SM(hello)ES( project. To recap, this is what we have:)EP(

  ) 11 13 PR($ ls -1
hello/

$ tree hello/
hello/
|-- build/
|   `-- ...
|-- hello/
|   `-- ...
|-- buildfile
`-- manifest)RP(

  )0 P(To start, let's build it in the )SM(hello-out/)ES( direc)HY(tory)YH( next to
  the project:)EP(

  ) 17 43 PR($ b hello/@hello-out/
mkdir fsdir{hello-out/}
mkdir hello-out/fsdir{hello/}
c++ hello/hello/cxx{hello}@hello-out/hello/
ld hello-out/hello/exe{hello}

$ ls -1
hello/
hello-out/

$ tree hello-out/
hello-out/
`-- hello/
    |-- hello
    |-- hello.d
    |-- hello.o
    `-- hello.o.d)RP(

  )0 P(This defi)HY(nitely)YH( requires some explain)HY(ing)YH(. Let's start from the bottom,
  with the )SM(hello-out/)ES( layout. It is )I(paral)HY(lel)YH()ES( to the source
  direc)HY(tory)YH(. This mirrored side-by-side listing \201of the rele)HY(vant)YH( parts\202 should
  illus)HY(trate)YH( this clearly:)EP(

  ) 3 39 PR(hello/             ~~>  hello-out/
`-- hello/         ~~>  `-- hello/
    `-- hello.cxx  ~~>      `-- hello.o)RP(

  )0 P(In fact, if we copy the contents of )SM(hello-out/)ES( over to
  )SM(hello/)ES(, we will end up with exactly the same result as in the
  in source build. And this is not acci)HY(den)HY(tal)YH(: an in source build is just a
  special case of an out of source build where the )I(out)ES( direc)HY(tory)YH( is the
  same as )I(src)ES(.)EP(

  )BR(
  )0 P(In )SM(build2)ES( this paral)HY(lel)YH( struc)HY(ture)YH( of the out and src
  direc)HY(to)HY(ries)YH( is a corner)HY(stone)YH( design deci)HY(sion)YH( and is non-nego)HY(tiable)YH(, so to
  speak. In partic)HY(u)HY(lar)YH(, out cannot be inside src. And while we can stash the
  build system output \201object files, executa)HY(bles)YH(, etc\202 into \201poten)HY(tially)YH(
  differ)HY(ent)YH(\202 subdi)HY(rec)HY(to)HY(ries)YH(, this is not recom)HY(mended)YH(. As will be shown later,
  )SM(build2)ES( offers better mech)HY(a)HY(nisms)YH( to achieve the same bene)HY(fits)YH(
  \201like reduced clutter, ability to run executa)HY(bles)YH(\202 but without the draw)HY(backs)YH(
  \201like name clashes\202.)EP(
  )BR(

  )0 P(Let's now examine how we invoked the build system to achieve this out of
  source build. Specif)HY(i)HY(cally)YH(, if we were build)HY(ing)YH( in source, our command line
  would have been:)EP(

  ) 1 10 PR($ b hello/)RP(

  )0 P(but for the out of source build, we have:)EP(

  ) 1 21 PR($ b hello/@hello-out/)RP(

  )0 P(In fact, that strange-looking construct, )SM(hello/@hello-out/)ES(
  is just a more elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( that explic)HY(itly)YH( spells out the
  target's src and out direc)HY(to)HY(ries)YH(. Let's add an explicit target type to make
  it clearer:)EP(

  ) 1 27 PR($ b hello/@hello-out/dir{.})RP(

  )0 P(What we have on the right of )SM(@)ES( is the target in the out
  direc)HY(tory)YH( and on the left \235 its src direc)HY(tory)YH(. In plain English, this
  command line says "build me the default target from )SM(hello/)ES( in
  the )SM(hello-out/)ES( direc)HY(tory)YH(".)EP(

  )0 P(As an example, if instead we wanted to build only the )SM(hello)ES(
  executable out of source, then the invo)HY(ca)HY(tion)YH( would have looked like
  this:)EP(

  ) 1 43 PR($ b hello/hello/@hello-out/hello/exe{hello})RP(

  )0 P(We could have also spec)HY(i)HY(fied)YH( out for an in source build, but that's
  redun)HY(dant)YH(:)EP(

  ) 1 17 PR($ b hello/@hello/)RP(

  )0 P(There is another example of this elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( in the
  build diag)HY(nos)HY(tics)YH(:)EP(

  ) 1 43 PR(c++ hello/hello/cxx{hello}@hello-out/hello/)RP(

  )0 P(Notice, however, that now the target \201)SM(cxx{hello})ES(\202 is on the
  left of )SM(@)ES(, that is, in the src direc)HY(tory)YH(. It does, however,
  make sense if you think about it: our )SM(hello.cxx)ES( is a )I(source
  file)ES(, it is not built and it resides in the project's source direc)HY(tory)YH(.
  This is in contrast, for example, to the )SM(exe{hello})ES( target
  which is the output of the build system and goes to the out direc)HY(tory)YH(. So in
  )SM(build2)ES( targets can be either in src or in out \201there can also
  be )I(out of any project)ES( targets, for example, installed files\202.)EP(

  )0 P(The elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( can also be used in
  )SM(build)HY(files)YH()ES(. We haven't encoun)HY(tered)YH( any so far because targets
  mentioned without explicit src/out default to out and, natu)HY(rally)YH(, most of
  the targets we mention in )SM(build)HY(files)YH()ES( are things we want built.
  One situ)HY(a)HY(tion)YH( where you may encounter an src target mentioned explic)HY(itly)YH( is
  when spec)HY(i)HY(fy)HY(ing)YH( its instal)HY(la)HY(bil)HY(ity)YH( \201discussed in the next section\202. For
  example, if our project includes the custom)HY(ary)YH( )SM(INSTALL)ES( file, it
  prob)HY(a)HY(bly)YH( doesn't make sense to install it. However, since it is a source
  file, we have to use the elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( when disabling its
  instal)HY(la)HY(tion)YH(:)EP(

  ) 1 32 PR(doc{INSTALL}@./: install = false)RP(

  )0 P(Note also that only targets and not prereq)HY(ui)HY(sites)YH( have this notion of
  src/out direc)HY(to)HY(ries)YH(. In a sense, prereq)HY(ui)HY(sites)YH( are rela)HY(tive)YH( to the target
  they are prereq)HY(ui)HY(sites)YH( of and are resolved to targets in a manner that is
  specific to their target types. For )SM(file{})ES(-based prereq)HY(ui)HY(sites)YH(
  the corre)HY(spond)HY(ing)YH( target in out is first looked up and if found used.
  Other)HY(wise)YH(, an exist)HY(ing)YH( file in src is searched for and if found the
  corre)HY(spond)HY(ing)YH( target \201now in src\202 is used. In partic)HY(u)HY(lar)YH(, this seman)HY(tics)YH(
  gives pref)HY(er)HY(ence)YH( to gener)HY(ated)YH( code over static.)EP(

  )BR(
  )0 P(More precisely, a prereq)HY(ui)HY(site)YH( is rela)HY(tive)YH( to the scope \201discussed below\202
  in which the depen)HY(dency)YH( is declared and not to the target that it is a
  prereq)HY(ui)HY(site)YH( of. However, in most prac)HY(ti)HY(cal)YH( cases, this means the same
  thing.)EP(
  )BR(

  )0 P(And this pretty much covers out of source builds. Let's summa)HY(rize)YH( the key
  points we have estab)HY(lished)YH( so far: Every build has two paral)HY(lel)YH( direc)HY(tory)YH(
  trees, src and out, with the in source build being just a special case where
  they are the same. Targets in a project can be either in the src or out
  direc)HY(tory)YH( though most of the time targets we mention in our
  )SM(build)HY(files)YH()ES( will be in out, which is the default. Prerequsites
  are rela)HY(tive)YH( to targets they are prereq)HY(ui)HY(sites)YH( of and
  )SM(file{)ES(}-based prereq)HY(ui)HY(sites)YH( are first searched for as declared
  targets in out and then as exist)HY(ing)YH( files in src.)EP(

  )0 P(Note also that we can have as many out of source builds as we want and we
  can place them anywhere we want \201but not inside src\202, say, on a RAM-backed
  disk/filesys)HY(tem)YH(. As an example, let's build our )SM(hello)ES( project
  with two differ)HY(ent)YH( compil)HY(ers)YH(:)EP(

  ) 2 43 PR($ b hello/@hello-gcc/    config.cxx=g++
$ b hello/@hello-clang/  config.cxx=clang++)RP(

  )0 P(In the next section we will see how to perma)HY(nently)YH( config)HY(ure)YH( our out of
  source builds so that we don't have to keep repeat)HY(ing)YH( these long command
  lines.)EP(

  )BR(
  )0 P(While tech)HY(ni)HY(cally)YH( you can have both in source and out of source builds at
  the same time, this is not recom)HY(mended)YH(. While it may work for basic
  projects, as soon as you start using gener)HY(ated)YH( source code \201which is fairly
  common in )SM(build2)ES(\202, it becomes diffi)HY(cult)YH( to predict where the
  compiler will pick gener)HY(ated)YH( headers. There is support for remap)HY(ping)YH(
  mis-picked headers but this may not always work with older C/C++ compil)HY(ers)YH(.
  Plus, as we will see in the next section, )SM(build2)ES( supports
  )I(forwarded config)HY(u)HY(ra)HY(tions)YH()ES( which provide most of the bene)HY(fits)YH( of an in
  source build but without the draw)HY(backs)YH(.)EP(
  )BR(

  )0 P(Let's now turn to )SM(build)HY(file)YH()ES( isola)HY(tion)YH(. It is a common,
  well-estab)HY(lished)YH( prac)HY(tice)YH( to orga)HY(nize)YH( complex soft)HY(ware)YH( projects in direc)HY(tory)YH(
  hier)HY(ar)HY(chies)YH(. One of the bene)HY(fits)YH( of this orga)HY(ni)HY(za)HY(tion)YH( is isola)HY(tion)YH(: we can
  use the same, short file names in differ)HY(ent)YH( subdi)HY(rec)HY(to)HY(ries)YH(. In
  )SM(build2)ES( the project's direc)HY(tory)YH( tree is used as a basis for its
  )I(scope)ES( hier)HY(ar)HY(chy)YH(. In a sense, scopes are like C++ names)HY(paces)YH( that
  auto)HY(mat)HY(i)HY(cally)YH( track the project's filesys)HY(tem)YH( struc)HY(ture)YH( and use direc)HY(to)HY(ries)YH(
  as their names. The follow)HY(ing)YH( listing illus)HY(trates)YH( the paral)HY(lel)YH( direc)HY(tory)YH( and
  scope hier)HY(ar)HY(chies)YH( for our )SM(hello)ES( project. The
  )SM(build/)ES( subdi)HY(rec)HY(tory)YH( is special and does not have a
  corre)HY(spond)HY(ing)YH( scope.)EP(

  ) 7 33 PR(hello/                   hello/
|                        {
`-- hello/                 hello/
    |                      {
    `-- ...                  ...
                           }
                         })RP(

  )0 P(Every )SM(build)HY(file)YH()ES( is loaded in its corre)HY(spond)HY(ing)YH( scope,
  vari)HY(ables)YH( set in a )SM(build)HY(file)YH()ES( are set in this scope and rela)HY(tive)YH(
  targets mentioned in a )SM(build)HY(file)YH()ES( are rela)HY(tive)YH( to this scope's
  direc)HY(tory)YH(. Let's "load" the )SM(build)HY(file)YH()ES( contents from our
  )SM(hello)ES( project to the above listing:)EP(

  ) 9 54 PR(hello/                   hello/
|                        {
|-- buildfile              ./: {*/ -build/}
|
`-- hello/                 hello/
    |                      {
    `-- buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         })RP(

  )0 P(In fact, to be abso)HY(lutely)YH( precise, we should also add the contents of
  )SM(boot)HY(strap)YH(.build)ES( and )SM(root.build)ES( to the project's
  root scope \201module loading is omitted for brevity\202:)EP(

  ) 16 54 PR(hello/                   hello/
|                        {
|-- build/
|   |-- bootstrap.build    project = hello
|   |
|   `-- root.build         cxx.std = latest
|                          hxx{*}: extension = hxx
|                          cxx{*}: extension = cxx
|
|-- buildfile              ./: {*/ -build/}
|
`-- hello/                 hello/
    |                      {
    `-- buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         })RP(

  )0 P(The above scope struc)HY(ture)YH( is very similar to what you will see \201besides a
  lot of other things\202 if you build with )SM(--dump\240match)ES(. With
  this option the build system driver dumps the build state after match)HY(ing)YH(
  rules to targets \201see )0 20 1 A(Diag)HY(nos)HY(tics)YH( and
  Debug)HY(ging)YH()20 0 TN TL()Ec /AF f D( for more infor)HY(ma)HY(tion)YH(\202. Here is an abbre)HY(vi)HY(ated)YH( output of
  bulding our )SM(hello)ES( with )SM(--dump)ES( \201assum)HY(ing)YH( an in
  source build in )SM(/tmp/hello)ES(\202:)EP(

  ) 55 52 PR($ b --dump match

/
{
  [target_triplet] build.host = x86_64-linux-gnu
  [string] build.host.class = linux
  [string] build.host.cpu = x86_64
  [string] build.host.system = linux-gnu

  /tmp/hello/
  {

    [dir_path] src_root = /tmp/hello/
    [dir_path] out_root = /tmp/hello/

    [dir_path] src_base = /tmp/hello/
    [dir_path] out_base = /tmp/hello/

    [project_name] project = hello
    [string] project.summary = hello executable
    [string] project.url = https://example.org/hello

    [string] version = 1.2.3
    [uint64] version.major = 1
    [uint64] version.minor = 2
    [uint64] version.patch = 3

    [string] cxx.std = latest

    [string] cxx.id = gcc
    [string] cxx.version = 8.1.0)WR(
    [uint64] cxx.version.major = 8
    [uint64] cxx.version.minor = 1
    [uint64] cxx.version.patch = 0

    [target_triplet] cxx.target = x86_64-w64-mingw32
    [string] cxx.target.class = windows
    [string] cxx.target.cpu = x86_64
    [string] cxx.target.system = mingw32

    hxx{*}: [string] extension = hxx
    cxx{*}: [string] extension = cxx

    hello/
    {
      [dir_path] src_base = /tmp/hello/hello/
      [dir_path] out_base = /tmp/hello/hello/

      dir{./}: exe{hello}
      exe{hello.}: cxx{hello.cxx}
    }

    dir{./}: dir{hello/} manifest{manifest}
  }
})RP(

  )0 P(This is prob)HY(a)HY(bly)YH( quite a bit more infor)HY(ma)HY(tion)YH( than what you've expected
  to see so let's explain a couple of things. Firstly, it appears there is
  another scope outer to our project's root. In fact, )SM(build2)ES(
  extends scoping outside of projects with the root of the filesys)HY(tem)YH( \201denoted
  by the special )SM(/)ES(\202 being the )I(global scope)ES(. This exten)HY(sion)YH(
  becomes useful when we try to build multi)HY(ple)YH( unre)HY(lated)YH( projects or import
  one project into another. In this model all projects are part of a single
  scope hier)HY(ar)HY(chy)YH( with the global scope at its root.)EP(

  )0 P(The global scope is read-only and contains a number of pre-defined
  )I(build-wide)ES( vari)HY(ables)YH( such as the build system version, host plat)HY(form)YH(
  \201shown in the above listing\202, etc.)EP(

  )0 P(Next, inside the global scope, we see our project's root scope
  \201)SM(/tmp/hello/)ES(\202. Besides the vari)HY(ables)YH( that we have set ourselves
  \201like )SM(project)ES(\202, it also contains a number of vari)HY(ables)YH( set by
  the build system core \201for example, )SM(out_base)ES(,
  )SM(src_root)ES(, etc\202 as well by build system modules \201for example,
  )SM(project.*)ES( and )SM(version.*)ES( vari)HY(ables)YH( set by the
  )SM(version)ES( module and )SM(cxx.*)ES( vari)HY(ables)YH( set by the
  )SM(cxx)ES( module\202.)EP(

  )0 P(The scope for our project's source direc)HY(tory)YH( \201)SM(hello/)ES(\202 should
  look famil)HY(iar)YH(. We again have a few special vari)HY(ables)YH( \201)SM(out_base)ES(,
  )SM(src_base)ES(\202. Notice also that the name patterns in prereq)HY(ui)HY(sites)YH(
  have been expanded to the actual files.)EP(

  )0 P(As you can prob)HY(a)HY(bly)YH( guess from their names, the )SM(src_*)ES( and
  )SM(out_*)ES( vari)HY(ables)YH( track the asso)HY(ci)HY(a)HY(tion)YH( between scopes and
  src/out direc)HY(to)HY(ries)YH(. They are main)HY(tained)YH( auto)HY(mat)HY(i)HY(cally)YH( by the build system
  core with the )SM(src/out_base)ES( pair set on each scope within the
  project and an addi)HY(tional)YH( )SM(src/out_root)ES( pair set on the
  project's root scope so that we can get the project's root direc)HY(to)HY(ries)YH( from
  anywhere in the project. Note that direc)HY(tory)YH( paths in these vari)HY(ables)YH( are
  always abso)HY(lute)YH( and normal)HY(ized)YH(.)EP(

  )0 P(In the above example the corre)HY(spond)HY(ing)YH( src/out vari)HY(able)YH( pairs have the
  same values because we were build)HY(ing)YH( in source. As an example, this is what
  the asso)HY(ci)HY(a)HY(tion)YH( will look like for an out of source build:)EP(

  ) 14 61 PR(hello/  ~~>      hello-out/                   <~~  hello-out/
|                {                                 |
|                  src_root = .../hello/           |
|                  out_root = .../hello-out/       |
|                                                  |
|                  src_base = .../hello/           |
|                  out_base = .../hello-out/       |
|                                                  |
`-- hello/  ~~>    hello/                     <~~  `-- hello/
                   {
                     src_base = .../hello/hello/
                     out_base = .../hello-out/hello/
                   }
                 })RP(

  )0 P(Now that we have some scopes and vari)HY(ables)YH( to play with, it's a good time
  to intro)HY(duce)YH( vari)HY(able)YH( expan)HY(sion)YH(. To get the value stored in a vari)HY(able)YH( we
  use )SM($)ES( followed by the vari)HY(able)YH('s name. The vari)HY(able)YH( is first
  looked up in the current scope \201that is, the scope in which the expan)HY(sion)YH(
  was encoun)HY(tered)YH(\202 and, if not found, in the outer scopes all the way to the
  global scope.)EP(

  )BR(
  )0 P(To be precise, this is for the default )I(vari)HY(able)YH( visi)HY(bil)HY(ity)YH()ES(.
  Vari)HY(ables)YH(, however, can have more limited visi)HY(bil)HY(i)HY(ties)YH(, such as
  )I(project)ES(, )I(scope)ES(, )I(target)ES(, or )I(prereq)HY(ui)HY(site)YH()ES(.)EP(
  )BR(

  )0 P(To illus)HY(trate)YH( the lookup seman)HY(tics)YH(, let's add the follow)HY(ing)YH( line to each
  )SM(build)HY(file)YH()ES( in our )SM(hello)ES( project:)EP(

  ) 9 38 PR($ cd hello/  # Change to project root.

$ cat buildfile
...
info "src_base: $src_base"

$ cat hello/buildfile
...
info "src_base: $src_base")RP(

  )0 P(And then build it:)EP(

  ) 3 54 PR($ b
buildfile:3:1: info: src_base: /tmp/hello/
hello/buildfile:8:1: info: src_base: /tmp/hello/hello/)RP(

  )0 P(In this case )SM(src_base)ES( is defined in each of the two scopes
  and we get their respec)HY(tive)YH( values. If, however, we change the above line to
  print )SM(src_root)ES( instead of )SM(src_base)ES(, we will get
  the same value from the root scope:)EP(

  ) 2 48 PR(buildfile:3:1: info: src_root: /tmp/hello/
hello/buildfile:8:1: info: src_root: /tmp/hello/)RP(

  )BR(
  )0 P(In this section we've only scratched the surface when it comes to
  vari)HY(ables)YH(. In partic)HY(u)HY(lar)YH(, vari)HY(ables)YH( and vari)HY(able)YH( values in
  )SM(build2)ES( are option)HY(ally)YH( typed \201those )SM([string])ES(,
  )SM([uint64])ES( we've seen in the build state dump\202. And in certain
  contexts the lookup seman)HY(tics)YH( actu)HY(ally)YH( starts from the target, not from the
  scope \201target-specific vari)HY(ables)YH(; there are also prereq)HY(ui)HY(site)YH(-specific\202.
  These and other vari)HY(able)YH(-related topics will be covered in subse)HY(quent)YH(
  sections.)EP(
  )BR(

  )0 P(One typical place to find )SM(src/out_root)ES( expan)HY(sions)YH( is in the
  include search path options. For example, the source direc)HY(tory)YH(
  )SM(build)HY(file)YH()ES( gener)HY(ated)YH( by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  an executable project actu)HY(ally)YH( looks like this \201)SM(poptions)ES( stands
  for )I(prepro)HY(ces)HY(sor)YH( options)ES(\202:)EP(

  ) 3 43 PR(exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )BR(
  )0 P(The strange-looking )SM(=+)ES( line is a )I(prepend)ES( vari)HY(able)YH(
  assign)HY(ment)YH(. It adds the value on the right hand side to the begin)HY(ning)YH( of the
  exist)HY(ing)YH( value. So, in the above example, the two header search paths will
  be added before any of the exist)HY(ing)YH( prepro)HY(ces)HY(sor)YH( options \201and thus will be
  consid)HY(ered)YH( first\202.)EP(

  )0 P(There are also the )I(append)ES( assign)HY(ment)YH(, )SM(+=)ES(, which adds
  the value on the right hand side to the end of the exist)HY(ing)YH( value, as well
  as, of course, the normal or )I(replace)ES( assign)HY(ment)YH(, )SM(=)ES(,
  which replaces the exist)HY(ing)YH( value with the right hand side. One way to
  remem)HY(ber)YH( where the exist)HY(ing)YH( and new values end up in the )SM(=+)ES( and
  )SM(+=)ES( results is to imagine the new value taking the posi)HY(tion)YH( of
  )SM(=)ES( and the exist)HY(ing)YH( value \235 of )SM(+)ES(.)EP(
  )BR(

  )0 P(The above )SM(build)HY(file)YH()ES( allows us to include our headers using
  the project's name as a prefix, inline with the )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( guide)HY(lines)YH(. For example, if we added the
  )SM(utility.hxx)ES( header to our )SM(hello)ES( project, we would
  include it like this:)EP(

  ) 8 28 PR(#include <iostream>

#include <hello/utility.hxx>

int main \201\202
{
...
})RP(

  )BR(
  )0 P(Besides )SM(poptions)ES(, there are also )SM(coptions)ES(
  \201compile options\202, )SM(loptions)ES( \201link options\202 and
  )SM(libs)ES( \201extra libraries to link\202. If you are famil)HY(iar)YH( with
  )SM(make)ES(, these are roughly equiv)HY(a)HY(lent)YH( to )SM(CPPFLAGS)ES(,
  )SM(CFLAGS)ES(/)SM(CXXFLAGS)ES(, )SM(LDFLAGS)ES(, and
  )SM(LIBS)ES(.)EP(

  )0 P(More specif)HY(i)HY(cally)YH(, there are three sets of these vari)HY(ables)YH(:
  )SM(cc.*)ES( \201stands for )I(C-common)ES(\202 which applies to all C-like
  languages as well as )SM(c.*)ES( and )SM(cxx.*)ES( which only
  apply during the C and C++ compi)HY(la)HY(tion)YH(, respec)HY(tively)YH(. We can use these
  vari)HY(ables)YH( in our )SM(build)HY(files)YH()ES( to adjust the compiler/linker
  behav)HY(ior)YH(. For example:)EP(

  ) 8 51 PR(if \201$cc.class == 'gcc'\202
{
  cc.coptions  += -fno-strict-aliasing  # C and C++
  cxx.coptions += -fno-exceptions       # only C++
}

if \201$c.target.class != 'windows'\202
  c.libs += -lpthread  # only C)RP(

  )0 P(Addi)HY(tion)HY(ally)YH(, as we will see in )0 8 1 A(Config)HY(u)HY(ra)HY(tion)YH()8 0 TN TL()Ec /AF f D(, there are also the
  )SM(config.cc.*)ES(, )SM(config.c.*)ES(, and
  )SM(config.cxx.*)ES( sets which are used by the users of our projects
  to provide exter)HY(nal)YH( config)HY(u)HY(ra)HY(tion)YH(. The initial values of the
  )SM(cc.*)ES(, )SM(c.*)ES(, and )SM(cxx.*)ES( vari)HY(ables)YH( are
  taken from the corre)HY(spond)HY(ing)YH( )SM(config.*.*)ES( values.)EP(

  )0 P(And, as we will learn in )0 13 1 A(Library Expor)HY(ta)HY(tion)YH()13 0 TN TL()Ec /AF f D(,
  there are also the )SM(cc.export.*)ES(, )SM(c.export.*)ES(, and
  )SM(cxx.export.*)ES( sets that are used to specify options that should
  be exported to the users of our library.)EP(

  )0 P(If we adjust the )SM(cc.*)ES(, )SM(c.*)ES(, and
  )SM(cxx.*)ES( vari)HY(ables)YH( at the scope level, as in the above frag)HY(ment)YH(,
  then the changes will apply when build)HY(ing)YH( every target in this scope \201as
  well as in the nested scopes, if any\202. Usually this is what we want but
  some)HY(times)YH( we may need to pass addi)HY(tional)YH( options only when compil)HY(ing)YH( certain
  source files or linking certain libraries or executa)HY(bles)YH(. For that we use
  the target-specific vari)HY(able)YH( assign)HY(ment)YH(. For example:)EP(

  ) 4 38 PR(exe{hello}: {hxx cxx}{**}

obj{utility}: cxx.poptions += -DNDEBUG
exe{hello}: cxx.loptions += -static)RP(

  )0 P(Note that we set these vari)HY(ables)YH( on targets which they affect. In
  partic)HY(u)HY(lar)YH(, those with a back)HY(ground)YH( in other build systems may, for example,
  erro)HY(neously)YH( expect that setting )SM(poptions)ES( on a library target
  will affect compi)HY(la)HY(tion)YH( of its prereq)HY(ui)HY(sites)YH(. For example, the follow)HY(ing)YH(
  does not work:)EP(

  ) 1 36 PR(exe{hello}: cxx.poptions += -DNDEBUG)RP(

  )0 P(The recom)HY(mended)YH( way to achieve this behav)HY(ior)YH( in )SM(build2)ES( is to
  orga)HY(nize)YH( your targets into subdi)HY(rec)HY(to)HY(ries)YH(, in which case we can just set the
  vari)HY(ables)YH( on the scope. And if this is impos)HY(si)HY(ble)YH( or unde)HY(sir)HY(able)YH(, then we
  can use target type/pattern-specific vari)HY(ables)YH( \201if there is a common
  pattern\202 or simply list the affected targets explic)HY(itly)YH(. For example:)EP(

  ) 2 43 PR(obj{*.test}: cxx.poptions += -DDEFINE_MAIN
obj{main utility}: cxx.poptions += -DNDEBUG)RP(

  )0 P(The first line covers compi)HY(la)HY(tion)YH( of source files that have the
  )SM(.test)ES( second-level exten)HY(sion)YH( \201see )0 19 1 A(Imple)HY(ment)HY(ing)YH( Unit Testing)19 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202 while
  the second simply lists the targets explic)HY(itly)YH(.)EP(

  )0 P(It is also possi)HY(ble)YH( to specify differ)HY(ent)YH( options when produc)HY(ing)YH( differ)HY(ent)YH(
  types of object files \201)SM(obje{})ES( \235 executable,
  )SM(obja{})ES( \235 static library, or )SM(objs{})ES( \235
  shared library\202 or when linking differ)HY(ent)YH( libraries \201)SM(liba{})ES(
  \235 static library or )SM(libs{})ES( \235 shared library\202. See
  )0 13 1 A(Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()13 0 TN TL()Ec /AF f D( for an
  example.)EP(
  )BR(

  )0 P(As mentioned above, each )SM(build)HY(file)YH()ES( in a project is loaded
  into its corre)HY(spond)HY(ing)YH( scope. As a result, we rarely need to open scopes
  explic)HY(itly)YH(. In the few cases that we do, we use the follow)HY(ing)YH( syntax:)EP(

  ) 4 12 PR(<directory>/
{
  ...
})RP(

  )0 P(If the scope direc)HY(tory)YH( is rela)HY(tive)YH(, then it is assumed to be rela)HY(tive)YH( to
  the current scope. As an exer)HY(cise)YH( for under)HY(stand)HY(ing)YH(, let's reim)HY(ple)HY(ment)YH( our
  )SM(hello)ES( project as a single )SM(build)HY(file)YH()ES(. That is, we
  move the contents of the source direc)HY(tory)YH( )SM(build)HY(file)YH()ES( into the
  root )SM(build)HY(file)YH()ES(:)EP(

  ) 16 31 PR($ tree hello/
hello/
|-- build/
|   `-- ...
|-- hello/
|   `-- hello.cxx
`-- buildfile

$ cat hello/buildfile

./: hello/

hello/
{
  ./: exe{hello}: {hxx cxx}{**}
})RP(

  )BR(
  )0 P(While this single )SM(build)HY(file)YH()ES( setup is not recom)HY(mended)YH( for new
  projects, it can be useful for non-intru)HY(sive)YH( conver)HY(sion)YH( of exist)HY(ing)YH( projects
  to )SM(build2)ES(. One approach is to place the unmod)HY(i)HY(fied)YH( orig)HY(i)HY(nal)YH(
  project into a subdi)HY(rec)HY(tory)YH( \201poten)HY(tially)YH( automat)HY(ing)YH( this with a mech)HY(a)HY(nism)YH(
  such as )SM(git\2011\202)ES( submod)HY(ules)YH(\202 then adding the )SM(build/)ES(
  subdi)HY(rec)HY(tory)YH( and the root )SM(build)HY(file)YH()ES( which explic)HY(itly)YH( opens
  scopes to define the build over the upstream project's subdi)HY(rec)HY(tory)YH(
  struc)HY(ture)YH(.)EP(
  )BR(

  )0 P(Seeing this merged )SM(build)HY(file)YH()ES( may make you wonder what
  exactly caused the loading of the source direc)HY(tory)YH( )SM(build)HY(file)YH()ES( in
  our normal setup. In other words, when we build our )SM(hello)ES( from
  the project root, who and why loads )SM(hello/build)HY(file)YH()ES(?)EP(

  )0 P(Actu)HY(ally)YH(, in the earlier days of )SM(build2)ES(, we had to
  explic)HY(itly)YH( load )SM(build)HY(files)YH()ES( that define targets we depend on
  with the )SM(include)ES( direc)HY(tive)YH(. In fact, we still can \201and have to
  if we are depend)HY(ing)YH( on targets other than direc)HY(to)HY(ries)YH(\202. For example:)EP(

  ) 3 23 PR(./: hello/

include hello/buildfile)RP(

  )0 P(We can also omit )SM(build)HY(file)YH()ES( for brevity and have just:)EP(

  ) 1 14 PR(include hello/)RP(

  )0 P(This explicit inclu)HY(sion)YH(, however, quickly becomes tire)HY(some)YH( as the number
  of direc)HY(to)HY(ries)YH( grows. It also makes using wild)HY(card)YH( patterns for subdi)HY(rec)HY(tory)YH(
  prereq)HY(ui)HY(sites)YH( a lot less appeal)HY(ing)YH(.)EP(

  )0 P(To over)HY(come)YH( this the )SM(dir{})ES( target type imple)HY(ments)YH( an
  inter)HY(est)HY(ing)YH( prereq)HY(ui)HY(site)YH( to target reso)HY(lu)HY(tion)YH( seman)HY(tics)YH(: if there is no
  exist)HY(ing)YH( target with this name, a )SM(build)HY(file)YH()ES( that \201presum)HY(ably)YH(\202
  defines this target is auto)HY(mat)HY(i)HY(cally)YH( loaded from the corre)HY(spond)HY(ing)YH(
  direc)HY(tory)YH(. In fact, this mech)HY(a)HY(nism)YH( goes a step further and, if the
  )SM(build)HY(file)YH()ES( does not exist, then it assumes one with the
  follow)HY(ing)YH( contents was implied:)EP(

  ) 1 6 PR(./: */)RP(

  )0 P(That is, it simply builds all the subdi)HY(rec)HY(to)HY(ries)YH(. This is espe)HY(cially)YH(
  handy when orga)HY(niz)HY(ing)YH( related tests into direc)HY(tory)YH( hier)HY(ar)HY(chies)YH(.)EP(

  )BR(
  )0 P(As mentioned above, this auto)HY(matic)YH( inclu)HY(sion)YH( is only trig)HY(gered)YH( if the
  target we depend on is )SM(dir{})ES( and we still have to explic)HY(itly)YH(
  include the neces)HY(sary)YH( )SM(build)HY(files)YH()ES( for other targets. One common
  example is a project consist)HY(ing)YH( of a library and an executable that links
  it, each resid)HY(ing)YH( in a sepa)HY(rate)YH( direc)HY(tory)YH( next to each other \201as noted
  earlier, this is not recom)HY(mended)YH( for projects that you plan to package\202. For
  example:)EP(

  ) 11 17 PR(hello/
|-- build/
|   `-- ...
|-- hello/
|   |-- main.cxx
|   `-- buildfile
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   `-- buildfile
`-- buildfile)RP(

  )0 P(In this case the executable )SM(build)HY(file)YH()ES( would look along these
  lines:)EP(

  ) 3 42 PR(include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} lib{hello})RP(

  )0 P(Note also that )SM(build)HY(file)YH()ES( inclu)HY(sion)YH( should only be used for
  access)HY(ing)YH( targets within the same project. For cross-project refer)HY(ences)YH( we
  use )0 12 1 A(Target Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 2 5 H(1.4)WB 41 Sn()WB 7 Sn( Oper)HY(a)HY(tions)YH()EH(

  )0 P(Modern build systems have to perform oper)HY(a)HY(tions)YH( other than just build)HY(ing)YH(:
  clean)HY(ing)YH( the build output, running tests, installing/unin)HY(stalling)YH( the build
  results, prepar)HY(ing)YH( source distri)HY(bu)HY(tions)YH(, and so on. And, if the build system
  has inte)HY(grated)YH( config)HY(u)HY(ra)HY(tion)YH( support, config)HY(ur)HY(ing)YH( the project would
  natu)HY(rally)YH( belong to this list as well.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with )SM(make)ES(, you should recog)HY(nize)YH( the
  paral)HY(lel)YH( with the common )SM(clean)ES( )SM(test)ES(,
  )SM(install)ES(, and )SM(dist)ES(, "oper)HY(a)HY(tion)YH(" pseudo-targets.)EP(
  )BR(

  )0 P(In )SM(build2)ES( we have the concept of a )I(build system
  oper)HY(a)HY(tion)YH()ES( performed on a target. The two pre-defined oper)HY(a)HY(tions)YH( are
  )SM(update)ES( and )SM(clean)ES( with other oper)HY(a)HY(tions)YH( provided by
  build system modules.)EP(

  )0 P(Oper)HY(a)HY(tions)YH( to be performed and targets to perform them on are spec)HY(i)HY(fied)YH(
  on the command line. As discussed earlier, )SM(update)ES( is the
  default oper)HY(a)HY(tion)YH( and )SM(./)ES( in the current direc)HY(tory)YH( is the
  default target if no oper)HY(a)HY(tion)YH( and/or target is spec)HY(i)HY(fied)YH( explic)HY(itly)YH(. And,
  similar to targets, we can specify multi)HY(ple)YH( oper)HY(a)HY(tions)YH( \201not neces)HY(sar)HY(ily)YH( on
  the same target\202 in a single build system invo)HY(ca)HY(tion)YH(. The list of oper)HY(a)HY(tions)YH(
  to perform and targets to perform them on is called a )I(build
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH()ES( or )I(build)HY(spec)YH()ES( for short \201see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details\202. Here are a few
  exam)HY(ples)YH(:)EP(

  ) 13 55 PR($ cd hello        # Change to project root.

$ b               # Update current directory.
$ b ./            # Same as above.
$ b update        # Same as above.
$ b update: ./    # Same as above.

$ b clean update  # Rebuild.

$ b clean:  hello/             # Clean specific target.
$ b update: hello/exe{hello}   # Update specific target

$ b update: libhello/ tests/   # Update two targets.)RP(

  )0 P(Let's revisit )SM(build/boot)HY(strap)YH(.build)ES( from our
  )SM(hello)ES( project:)EP(

  ) 7 15 PR(project = hello

using version
using config
using test
using install
using dist)RP(

  )0 P(Other than )SM(version)ES(, all the modules we load define new
  oper)HY(a)HY(tions)YH(. Let's examine each of them start)HY(ing)YH( with
  )SM(config)ES(.)EP(

  )0 3 6 H(1.4.1)WB 42 Sn()WB 8 Sn( Config)HY(u)HY(ra)HY(tion)YH()EH(

  )0 P(As mentioned briefly earlier, the )SM(config)ES( module provides
  support for persist)HY(ing)YH( config)HY(u)HY(ra)HY(tions)YH( by having us )I(config)HY(ure)YH()ES( our
  projects. At first it may feel natural to call )SM(config)HY(ure)YH()ES(
  another oper)HY(a)HY(tion)YH(. There is, however, a concep)HY(tual)YH( problem: we don't really
  config)HY(ure)YH( a target. And, perhaps after some medi)HY(ta)HY(tion)YH(, it should become
  clear that what we are really doing is config)HY(ur)HY(ing)YH( oper)HY(a)HY(tions)YH( on targets.
  For example, config)HY(ur)HY(ing)YH( updat)HY(ing)YH( a C++ project might involve detect)HY(ing)YH( and
  saving infor)HY(ma)HY(tion)YH( about the C++ compiler while config)HY(ur)HY(ing)YH( installing it
  may require spec)HY(i)HY(fy)HY(ing)YH( the instal)HY(la)HY(tion)YH( direc)HY(tory)YH(.)EP(

  )0 P(In other words, )SM(config)HY(ure)YH()ES( is an oper)HY(a)HY(tion)YH( on oper)HY(a)HY(tion)YH( on
  targets \235 a meta-oper)HY(a)HY(tion)YH(.  And so in )SM(build2)ES( we have the
  concept of a )I(build system meta-oper)HY(a)HY(tion)YH()ES(.  If not spec)HY(i)HY(fied)YH(
  explic)HY(itly)YH( \201as part of the build)HY(spec)YH(\202, the default is )SM(perform)ES(,
  which is to simply perform the oper)HY(a)HY(tion)YH(.)EP(

  )0 P(Back to )SM(config)ES(, this module provides two meta-oper)HY(a)HY(tions)YH(:
  )SM(config)HY(ure)YH()ES( which saves the config)HY(u)HY(ra)HY(tion)YH( of a project into the
  )SM(build/config.build)ES( file as well as )SM(disfig)HY(ure)YH()ES( which
  removes it.)EP(

  )BR(
  )0 P(While the common meaning of the word )I(disfig)HY(ure)YH()ES( is some)HY(what)YH(
  differ)HY(ent)YH( to what we make it mean in this context, we still prefer it over
  the commonly suggested alter)HY(na)HY(tive)YH( \201)I(decon)HY(fig)HY(ure)YH()ES(\202 for the symme)HY(try)YH( of
  their Latin )I(con-)ES( \201"together"\202 and )I(dis-)ES( \201"apart"\202 prefixes.)EP(
  )BR(

  )0 P(Let's say for the in source build of our )SM(hello)ES( project we
  want to use )SM(Clang)ES( and enable debug infor)HY(ma)HY(tion)YH(. Without
  persis)HY(tence)YH( we would have to repeat this config)HY(u)HY(ra)HY(tion)YH( on every build system
  invo)HY(ca)HY(tion)YH(:)EP(

  ) 3 45 PR($ cd hello/  # Change to project root.

$ b config.cxx=clang++ config.cxx.coptions=-g)RP(

  )0 P(Instead, we can config)HY(ure)YH( our project with this infor)HY(ma)HY(tion)YH( once and from
  then on invoke the build system without any argu)HY(ments)YH(:)EP(

  ) 13 55 PR($ b configure config.cxx=clang++ config.cxx.coptions=-g

$ tree ./
./
|-- build/
|   |-- ...
|   `-- config.build
`-- ...

$ b
$ b clean
$ b
...)RP(

  )0 P(Let's take a look at )SM(config.build)ES(:)EP(

  ) 8 28 PR($ cat build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]
...)RP(

  )0 P(As you can see, it's just a build)HY(file)YH( with a bunch of vari)HY(able)YH(
  assign)HY(ments)YH(. In partic)HY(u)HY(lar)YH(, this means you can tweak your build
  config)HY(u)HY(ra)HY(tion)YH( by modi)HY(fy)HY(ing)YH( this file with your favorite editor. Or,
  alter)HY(na)HY(tively)YH(, you can adjust the config)HY(u)HY(ra)HY(tion)YH( by recon)HY(fig)HY(ur)HY(ing)YH( the
  project:)EP(

  ) 10 28 PR($ b configure config.cxx=g++

$ cat build/config.build

config.cxx = g++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]
...)RP(

  )0 P(Any vari)HY(able)YH( value spec)HY(i)HY(fied)YH( on the command line over)HY(rides)YH( those
  spec)HY(i)HY(fied)YH( in the )SM(build)HY(files)YH()ES(. As a result,
  )SM(config.cxx)ES( was updated while the value of
  )SM(config.cxx.coptions)ES( was preserved.)EP(

  )0 P(Command line vari)HY(able)YH( over)HY(rides)YH( are also handy to adjust the
  config)HY(u)HY(ra)HY(tion)YH( for a single build system invo)HY(ca)HY(tion)YH(. For example, let's say
  we want to quickly check that our project builds with opti)HY(miza)HY(tion)YH( but
  without perma)HY(nently)YH( chang)HY(ing)YH( the config)HY(u)HY(ra)HY(tion)YH(:)EP(

  ) 2 48 PR($ b config.cxx.coptions=-O3  # Rebuild with -O3.
$ b                          # Rebuild with -g.)RP(

  )0 P(We can also config)HY(ure)YH( out of source builds of our projects. In this case,
  besides )SM(config.build)ES(, )SM(config)HY(ure)YH()ES( also saves the
  loca)HY(tion)YH( of the source direc)HY(tory)YH( so that we don't have to repeat that
  either. Remem)HY(ber)YH(, this is how we used to build our )SM(hello)ES( out of
  source:)EP(

  ) 2 42 PR($ b hello/@hello-gcc/   config.cxx=g++
$ b hello/@hello-clang/ config.cxx=clang++)RP(

  )0 P(And now we can do:)EP(

  ) 13 53 PR($ b configure: hello/@hello-gcc/   config.cxx=g++
$ b configure: hello/@hello-clang/ config.cxx=clang++

$ hello-clang/
hello-clang/
`-- build/
    |-- bootstrap/
    |   `-- src-root.build
    `-- config.build

$ b hello-gcc/
$ b hello-clang/
$ b hello-gcc/ hello-clang/)RP(

  )0 P(One major benefit of an in source build is the ability to run executa)HY(bles)YH(
  as well as examine build and test output \201test results, gener)HY(ated)YH( source
  code, docu)HY(men)HY(ta)HY(tion)YH(, etc\202 without leaving the source direc)HY(tory)YH(.
  Unfor)HY(tu)HY(nately)YH(, we cannot have multi)HY(ple)YH( in source builds and as was discussed
  earlier, mixing in and out of source builds is not recom)HY(mended)YH(.)EP(

  )0 P(To over)HY(come)YH( this limi)HY(ta)HY(tion)YH( )SM(build2)ES( has a notion of
  )I(forwarded config)HY(u)HY(ra)HY(tions)YH()ES(. As the name suggests, we can config)HY(ure)YH( a
  project's source direc)HY(tory)YH( to forward to one of its out of source builds.
  Once done, when)HY(ever)YH( we run the build system from the source direc)HY(tory)YH(, it
  will auto)HY(mat)HY(i)HY(cally)YH( build in the corre)HY(sponded)YH( forwarded output direc)HY(tory)YH(.
  Addi)HY(tion)HY(ally)YH(, it will )I(back)HY(link)YH()ES( \201using symlinks or another suit)HY(able)YH(
  mech)HY(a)HY(nism)YH(\202 certain "inter)HY(est)HY(ing)YH(" targets \201)SM(exe{})ES(,
  )SM(doc{})ES(\202 to the source direc)HY(tory)YH( for easy access. As an example,
  let's config)HY(ure)YH( our )SM(hello/)ES( source direc)HY(tory)YH( to forward to the
  )SM(hello-gcc/)ES( build:)EP(

  ) 7 42 PR($ b configure: hello/@hello-gcc/,forward

$ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello}@../hello-gcc/hello/
ld ../hello-gcc/hello/exe{hello}
ln ../hello-gcc/hello/exe{hello} -> hello/)RP(

  )0 P(Notice the last line in the above listing: it indi)HY(cates)YH( that
  )SM(exe{hello)ES(} from the out direc)HY(tory)YH( was back)HY(linked)YH( in our
  project's source subdi)HY(rec)HY(tory)YH(:)EP(

  ) 13 45 PR($ tree ./
./
|-- build/
|   |-- bootstrap/
|   |   `-- out-root.build
|   `-- ...
|-- hello/
|   |-- ...
|   `-- hello -> ../../hello-gcc/hello/hello*
`-- ...

$ ./hello/hello
Hello World!)RP(

  )BR(
  )0 P(By default only )SM(exe{})ES( and )SM(doc{})ES( targets are
  back)HY(linked)YH(. This, however, can be customized with the )SM(back)HY(link)YH()ES(
  target-specific vari)HY(able)YH(.)EP(
  )BR(

  )0 3 7 H(1.4.2)WB 43 Sn()WB 9 Sn( Testing)EH(

  )0 P(The next module we load in )SM(boot)HY(strap)YH(.build)ES( is
  )SM(test)ES( which defines the )SM(test)ES( oper)HY(a)HY(tion)YH(. As the name
  suggests, this module provides support for running tests.)EP(

  )0 P(There are two types of tests that we can run with the )SM(test)ES(
  module: simple and scripted.)EP(

  )0 P(A simple test is just an executable target with the )SM(test)ES(
  target-specific vari)HY(able)YH( set to )SM(true)ES(. For example:)EP(

  ) 1 23 PR(exe{hello}: test = true)RP(

  )0 P(A simple test is executed once and in its most basic form \201typical for
  unit testing\202 doesn't take any inputs nor produce any output, indi)HY(cat)HY(ing)YH(
  success via the zero exit status. If we test our )SM(hello)ES( project
  with the above addi)HY(tion)YH( to the )SM(build)HY(file)YH()ES(, then we will see the
  follow)HY(ing)YH( output:)EP(

  ) 3 21 PR($ b test
test hello/exe{hello}
Hello, World!)RP(

  )0 P(While the test passes \201since it exited with zero status\202, we prob)HY(a)HY(bly)YH(
  don't want to see that )SM(Hello, World!)ES( every time we run it \201this
  can, however, be quite useful when running exam)HY(ples)YH(\202. More impor)HY(tantly)YH(, we
  don't really test its func)HY(tion)HY(al)HY(ity)YH( and if tomor)HY(row)YH( our )SM(hello)ES(
  starts swear)HY(ing)YH( rather than greet)HY(ing)YH(, the test will still pass.)EP(

  )0 P(Besides check)HY(ing)YH( its exit status we can also supply some basic
  infor)HY(ma)HY(tion)YH( to a simple test \201more common for inte)HY(gra)HY(tion)YH( testing\202.
  Specif)HY(i)HY(cally)YH(, we can pass command line options \201)SM(test.options)ES(\202
  and argu)HY(ments)YH( \201)SM(test.argu)HY(ments)YH()ES(\202 as well as input
  \201)SM(test.stdin)ES(, used to supply test's )SM(stdin)ES(\202 and
  output \201)SM(test.stdout)ES(, used to compare to test's
  )SM(stdout)ES(\202.)EP(

  )0 P(Let's see how we can use this to fix our )SM(hello)ES( test by
  making sure our program prints the expected greet)HY(ing)YH(. First, we need to add
  a file that will contain the expected output, let's call it
  )SM(test.out)ES(:)EP(

  ) 7 20 PR($ ls -1 hello/
hello.cxx
test.out
buildfile

$ cat hello/test.out
Hello, World!)RP(

  )0 P(Next, we arrange for it to be compared to our test's )SM(stdout)ES(.
  Here is the new )SM(hello/build)HY(file)YH()ES(:)EP(

  ) 2 46 PR(exe{hello}: {hxx cxx}{**}
exe{hello}: file{test.out}: test.stdout = true)RP(

  )0 P(The last line looks new. What we have here is a )I(prereq)HY(ui)HY(site)YH(-specific
  vari)HY(able)YH()ES( assign)HY(ment)YH(. By setting )SM(test.stdout)ES( for the
  )SM(file{test.out})ES( prereq)HY(ui)HY(site)YH( of target )SM(exe{hello})ES(
  we mark it as expected )SM(stdout)ES( output of )I(this)ES( target
  \201theo)HY(ret)HY(i)HY(cally)YH(, we could have marked it as )SM(test.input)ES( for
  another target\202. Notice also that we no longer need the )SM(test)ES(
  target-specific vari)HY(able)YH(; it's unnec)HY(es)HY(sary)YH( if one of the other
  )SM(test.*)ES( vari)HY(ables)YH( is spec)HY(i)HY(fied)YH(.)EP(

  )0 P(Now, if we run our test, we won't see any output:)EP(

  ) 2 21 PR($ b test
test hello/exe{hello})RP(

  )0 P(And if we try to change the greet)HY(ing)YH( in )SM(hello.cxx)ES( but not in
  )SM(test.out)ES(, our test will fail print)HY(ing)YH( the )SM(diff\2011\202)ES(
  compar)HY(i)HY(son)YH( of the expected and actual output:)EP(

  ) 10 35 PR($ b test
c++ hello/cxx{hello}
ld hello/exe{hello}
test hello/exe{hello}
--- test.out
+++ -
@@ -1 +1 @@
-Hello, World!
+Hi, World!
error: test hello/exe{hello} failed)RP(

  )0 P(Notice another inter)HY(est)HY(ing)YH( thing: we have modi)HY(fied)YH( )SM(hello.cxx)ES(
  to change the greet)HY(ing)YH( and our test executable was auto)HY(mat)HY(i)HY(cally)YH( rebuilt
  before testing. This happened because the )SM(test)ES( oper)HY(a)HY(tion)YH(
  performs )SM(update)ES( as its )I(pre-oper)HY(a)HY(tion)YH()ES( on all the targets
  to be tested.)EP(

  )0 P(Let's make our )SM(hello)ES( program more flex)HY(i)HY(ble)YH( by accept)HY(ing)YH( the
  name to greet on the command line:)EP(

  ) 12 56 PR(#include <iostream>

int main \201int argc, char* argv[]\202
{
  if \201argc < 2\202
  {
    std::cerr << "error: missing name" << std::endl;
    return 1;
  }

  std::cout << "Hello, " << argv[1] << '!' << std::endl;
})RP(

  )0 P(We can exer)HY(cise)YH( its success)HY(ful)YH( execu)HY(tion)YH( path with a simple test fairly
  easily:)EP(

  ) 2 46 PR(exe{hello}: test.arguments = 'World'
exe{hello}: file{test.out}: test.stdout = true)RP(

  )0 P(What if we also wanted to test its error handling? Since simple tests are
  single-run, this won't be easy. Even if we could over)HY(come)YH( this, having
  expected output for each test in a sepa)HY(rate)YH( file will quickly become untidy.
  And this is where script-based tests come in. Testscript is
  )SM(build2)ES('s portable language for running tests. It vaguely
  resem)HY(bles)YH( Bash and is opti)HY(mized)YH( for concise test imple)HY(men)HY(ta)HY(tion)YH( and fast,
  paral)HY(lel)YH( execu)HY(tion)YH(.)EP(

  )0 P(Just to give you an idea \201see )0 2 A(Testscript Intro)HY(duc)HY(tion)YH()EA( for
  a proper intro)HY(duc)HY(tion)YH(\202, here is what testing our )SM(hello)ES( program
  with Testscript would look like:)EP(

  ) 8 36 PR($ ls -1 hello/
hello.cxx
testscript
buildfile

$ cat hello/buildfile

exe{hello}: {hxx cxx}{**} testscript)RP(

  )0 P(And this is the contents of )SM(hello/testscript)ES(:)EP(

  ) 9 27 PR(: basics
:
$* 'World' >'Hello, World!'

: missing-name
:
$* 2>>EOE != 0
error: missing name
EOE)RP(

  )0 P(A couple of key points: The )SM(test.out)ES( file is gone with all
  the test inputs and expected outputs incor)HY(po)HY(rated)YH( into
  )SM(testscript)ES(. To test an executable with Testscript, all we have
  to do is list the corre)HY(spond)HY(ing)YH( )SM(testscript)ES( file as its
  prereq)HY(ui)HY(site)YH( \201and which, being a fixed name, doesn't need an explicit target
  type, similar to )SM(mani)HY(fest)YH()ES(\202.)EP(

  )0 P(To see Testscript in action, let's say we've made our program more
  forgiv)HY(ing)YH( by falling back to a default name if one wasn't spec)HY(i)HY(fied)YH(:)EP(

  ) 7 50 PR(#include <iostream>

int main \201int argc, char* argv[]\202
{
  const char* n \201argc > 1 ? argv[1] : "World"\202;
  std::cout << "Hello, " << n << '!' << std::endl;
})RP(

  )0 P(If we forget to adjust the )SM(missing-name)ES( test, then this is
  what we could expect to see when running the tests:)EP(

  ) 6 57 PR(b test
c++ hello/cxx{hello}
ld hello/exe{hello}
test hello/testscript{testscript} hello/exe{hello}
hello/testscript:7:1: error: hello/hello exit code 0 == 0
  info: stdout: hello/test-hello/missing-name/stdout)RP(

  )0 P(Testscript-based inte)HY(gra)HY(tion)YH( testing is the default setup for executable
  \201)SM(-t\240exe)ES(\202 projects created by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(.
  Here is the recap of the overall layout:)EP(

  ) 9 18 PR(hello/
|-- build/
|   `-- ...
|-- hello/
|   |-- hello.cxx
|   |-- testscript
|   `-- buildfile
|-- buildfile
`-- manifest)RP(

  )0 P(For libraries \201)SM(-t\240lib)ES(\202, however, the inte)HY(gra)HY(tion)YH(
  testing setup is a bit differ)HY(ent)YH(. Here are the rele)HY(vant)YH( parts of the
  layout:)EP(

  ) 19 27 PR(libhello/
|-- build/
|   `-- ...
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   |-- export.hxx
|   |-- version.hxx.in
|   `-- buildfile
|-- tests/
|   |-- build/
|   |   |-- bootstrap.build
|   |   `-- root.build
|   |-- basics/
|   |   |-- driver.cxx
|   |   `-- buildfile
|   `-- buildfile
|-- buildfile
`-- manifest)RP(

  )0 P(Specif)HY(i)HY(cally)YH(, there is no )SM(testscript)ES( in
  )SM(libhello/)ES(, the project's source direc)HY(tory)YH(. Instead, we have the
  )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( which itself looks like a project: it
  contains the )SM(build/)ES( subdi)HY(rec)HY(tory)YH( with all the famil)HY(iar)YH( files,
  etc. In fact, )SM(tests)ES( is a )I(subpro)HY(ject)YH()ES( of our
  )SM(libhello)ES( project.)EP(

  )0 P(While we will be exam)HY(in)HY(ing)YH( )SM(tests)ES( in greater detail later, in
  a nutshell, the reason it is a subpro)HY(ject)YH( is to be able to test an installed
  version of our library. By default, when )SM(tests)ES( is built as part
  of its parent project \201called )I(amal)HY(ga)HY(ma)HY(tion)YH()ES(\202, the locally built
  )SM(libhello)ES( library will be auto)HY(mat)HY(i)HY(cally)YH( imported. However, we
  can also config)HY(ure)YH( a build of )SM(tests)ES( out of its amal)HY(ga)HY(ma)HY(tion)YH(, in
  which case we can import an installed version of )SM(libhello)ES(. We
  will learn how to do all that as well as the under)HY(ly)HY(ing)YH( concepts
  \201)I(subpro)HY(ject)YH()ES(/)I(amal)HY(ga)HY(ma)HY(tion)YH()ES(, )I(import)ES(, etc\202 in the coming
  sections.)EP(

  )0 P(Inside )SM(tests/)ES( we have the )SM(basics/)ES( subdi)HY(rec)HY(tory)YH(
  which contains a simple test for our library's API. By default it doesn't
  use Testscript but if you want to, you can. You can also rename
  )SM(basics/)ES( to some)HY(thing)YH( more mean)HY(ing)HY(ful)YH( and add more tests next to
  it. For example, if we were creat)HY(ing)YH( an XML parsing and seri)HY(al)HY(iza)HY(tion)YH(
  library, then our )SM(tests/)ES( could have the follow)HY(ing)YH( layout:)EP(

  ) 8 15 PR(tests/
|-- build/
|   `-- ...
|-- parser/
|   `-- ...
|-- serializer/
|   `-- ...
`-- buildfile)RP(

  )BR(
  )0 P(Nothing prevents us from having the )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( for
  executable projects. And it can be just a subdi)HY(rec)HY(tory)YH( or a subpro)HY(ject)YH(, the
  same as for libraries. Making it a subpro)HY(ject)YH( makes sense if your program
  has complex instal)HY(la)HY(tion)YH(, for example, if its execu)HY(tion)YH( requires
  config)HY(u)HY(ra)HY(tion)YH( and/or data files that need to be found, etc. For simple
  programs, however, testing the executable before installing it is usually
  suffi)HY(cient)YH(.)EP(

  )0 P(For a general discus)HY(sion)YH( of func)HY(tional)YH(/inte)HY(gra)HY(tion)YH( and unit testing refer
  to the )0 2 A(Tests)EA(
  section in the toolchain intro)HY(duc)HY(tion)YH(. For details on the unit test support
  imple)HY(men)HY(ta)HY(tion)YH( see )0 19 1 A(Imple)HY(ment)HY(ing)YH( Unit
  Testing)19 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 3 8 H(1.4.3)WB 44 Sn()WB 10 Sn( Instal)HY(la)HY(tion)YH()EH(

  )0 P(The )SM(install)ES( module defines the )SM(install)ES( and
  )SM(unin)HY(stall)YH()ES( oper)HY(a)HY(tions)YH(. As the name suggests, this module
  provides support for project instal)HY(la)HY(tion)YH(.)EP(

  )BR(
  )0 P(Instal)HY(la)HY(tion)YH( in )SM(build2)ES( is modeled after UNIX-like oper)HY(a)HY(tion)YH(
  systems though the instal)HY(la)HY(tion)YH( direc)HY(tory)YH( layout is highly customiz)HY(able)YH(.
  While )SM(build2)ES( projects can import )SM(build2)ES( libraries
  directly, instal)HY(la)HY(tion)YH( is often a way to "export" them in a form usable by
  other build systems.)EP(
  )BR(

  )0 P(The root instal)HY(la)HY(tion)YH( direc)HY(tory)YH( is spec)HY(i)HY(fied)YH( with the
  )SM(config.install.root)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. Let's install our
  )SM(hello)ES( program into )SM(/tmp/install)ES(:)EP(

  ) 3 45 PR($ cd hello/  # Change to project root.

$ b install config.install.root=/tmp/install/)RP(

  )0 P(And see what we've got \201executa)HY(bles)YH( are marked with )SM(*)ES(\202:)EP(

  ) 9 24 PR($ tree /tmp/install/

/tmp/install/
|-- bin/
|   `-- *hello
`-- share/
    `-- doc/
        `-- hello/
            `-- manifest)RP(

  )0 P(Similar to the )SM(test)ES( oper)HY(a)HY(tion)YH(, )SM(install)ES( performs
  )SM(update)ES( as a pre-oper)HY(a)HY(tion)YH( for targets that it installs.)EP(

  )BR(
  )0 P(We can also config)HY(ure)YH( our project with the desired
  )SM(config.install.*)ES( values so that we don't have to repeat them on
  every install/unin)HY(stall)YH(. For example:)EP(

  ) 3 47 PR($ b configure config.install.root=/tmp/install/
$ b install
$ b uninstall)RP(
  )BR(

  )0 P(Now let's try the same for )SM(libhello)ES( \201symbolic link targets
  are shown with )SM(->)ES( and actual static/shared library names may
  differ on your oper)HY(at)HY(ing)YH( system\202:)EP(

  ) 25 45 PR($ rm -r /tmp/install

$ cd libhello/  # Change to project root.

$ b install config.install.root=/tmp/install/

$ tree /tmp/install/

/tmp/install/
|-- include/
|   `-- libhello/
|       |-- hello.hxx
|       |-- export.hxx
|       `-- version.hxx
|-- lib/
|   |-- pkgconfig/
|   |   |-- libhello.shared.pc
|   |   `-- libhello.static.pc
|   |-- libhello.a
|   |-- libhello.so -> libhello-0.1.so
|   `-- libhello-0.1.so
`-- share/
    `-- doc/
        `-- libhello/
            `-- manifest)RP(

  )0 P(As you can see, the library headers go into the custom)HY(ary)YH(
  )SM(include/)ES( subdi)HY(rec)HY(tory)YH( while static and shared libraries \201and
  their )SM(pkg-config\2011\202)ES( files\202 \235 into )SM(lib/)ES(.
  Using this instal)HY(la)HY(tion)YH( we should be able to import this library from other
  build systems or even use it in a manual build:)EP(

  ) 1 65 PR($ g++ -I/tmp/install/include -L/tmp/install/lib greet.cxx -lhello)RP(

  )0 P(If we want to install into a system-wide loca)HY(tion)YH( like )SM(/usr)ES(
  or )SM(/usr/local)ES(, then we most likely will need to specify the
  )SM(sudo\2011\202)ES( program:)EP(

  ) 1 60 PR($ b config.install.root=/usr/local/ config.install.sudo=sudo)RP(

  )BR(
  )0 P(In )SM(build2)ES( only actual install/unin)HY(stall)YH( commands are
  executed with )SM(sudo\2011\202)ES(. And while on the topic of sensi)HY(ble)YH(
  imple)HY(men)HY(ta)HY(tions)YH(, )SM(unin)HY(stall)YH()ES( can be gener)HY(ally)YH( trusted to work
  reli)HY(ably)YH(.)EP(
  )BR(

  )0 P(The default instal)HY(la)HY(bil)HY(ity)YH( of a target as well as where it is installed
  is deter)HY(mined)YH( by its target type. For example, )SM(exe{})ES( is by
  default installed into )SM(bin/)ES(, )SM(doc{})ES( \235 into
  )SM(share/doc/<project>/)ES(, and )SM(file{})ES( is not
  installed.)EP(

  )0 P(We can, however, over)HY(ride)YH( these defaults with the )SM(install)ES(
  target-specific vari)HY(able)YH(.  Its value should be either special
  )SM(false)ES( indi)HY(cat)HY(ing)YH( that the target should not be installed or the
  direc)HY(tory)YH( to install the target to. As an example, here is what the root
  )SM(build)HY(file)YH()ES( from our )SM(libhello)ES( project looks
  like:)EP(

  ) 3 25 PR(./: {*/ -build/} manifest

tests/: install = false)RP(

  )0 P(The first line we have already seen and the purpose of the second line
  should now be clear: it makes sure we don't try to install anything in the
  )SM(tests/)ES( subdi)HY(rec)HY(tory)YH(.)EP(

  )0 P(If the value of the )SM(install)ES( vari)HY(able)YH( is not
  )SM(false)ES(, then it is normally a rela)HY(tive)YH( path with the first path
  compo)HY(nent)YH( being one of these names:)EP(

  ) 19 68 PR(name        default                         override
----        -------                         --------
root                                        config.install.root

data_root   root/                           config.install.data_root
exec_root   root/                           config.install.exec_root

bin         exec_root/bin/                  config.install.bin
sbin        exec_root/sbin/                 config.install.sbin
lib         exec_root/lib/                  config.install.lib
libexec     exec_root/libexec/<project>/    config.install.libexec
pkgconfig   lib/pkgconfig/                  config.install.pkgconfig

data        data_root/share/<project>/      config.install.data
include     data_root/include/              config.install.include

doc         data_root/share/doc/<project>/  config.install.doc
man         data_root/share/man/            config.install.man
man<N>      man/man<N>/                     config.install.man<N>)RP(

  )0 P(Let's see what's going on here: The default install direc)HY(tory)YH( tree is
  derived from the )SM(config.install.root)ES( value but the loca)HY(tion)YH( of
  each node in this tree can be over)HY(rid)HY(den)YH( by the user that installs our
  project using the corre)HY(spond)HY(ing)YH( )SM(config.install.*)ES( vari)HY(ables)YH(. In
  our )SM(build)HY(files)YH()ES(, in turn, we use the node names instead of
  actual direc)HY(to)HY(ries)YH(. As an example, here is a )SM(build)HY(file)YH()ES( frag)HY(ment)YH(
  from the source direc)HY(tory)YH( of our )SM(libhello)ES( project:)EP(

  ) 5 37 PR(hxx{*}:
{
  install         = include/libhello/
  install.subdirs = true
})RP(

  )0 P(Here we set the instal)HY(la)HY(tion)YH( loca)HY(tion)YH( for headers to be the
  )SM(libhello/)ES( subdi)HY(rec)HY(tory)YH( of the )SM(include)ES( instal)HY(la)HY(tion)YH(
  loca)HY(tion)YH(. Assum)HY(ing)YH( )SM(config.install.root)ES( is )SM(/usr/)ES(,
  the )SM(install)ES( module will perform the follow)HY(ing)YH( steps to resolve
  this rela)HY(tive)YH( path to the actual, abso)HY(lute)YH( instal)HY(la)HY(tion)YH( direc)HY(tory)YH(:)EP(

  ) 4 27 PR(include/libhello/
data_root/include/libhello/
root/include/libhello/
/usr/include/libhello/)RP(

  )0 P(In the above )SM(build)HY(file)YH()ES( frag)HY(ment)YH( we also see the use of the
  )SM(install.subdirs)ES( vari)HY(able)YH(. Setting it to )SM(true)ES(
  instructs the )SM(install)ES( module to recre)HY(ate)YH( subdi)HY(rec)HY(to)HY(ries)YH(
  start)HY(ing)YH( from this point in the project's direc)HY(tory)YH( hier)HY(ar)HY(chy)YH(.  For example,
  if our )SM(libhello/)ES( source direc)HY(tory)YH( had the )SM(details/)ES(
  subdi)HY(rec)HY(tory)YH( with the )SM(utility.hxx)ES( header, then this header
  would have been installed as
  )SM(.../include/libhello/details/utility.hxx)ES(.)EP(

  )0 3 9 H(1.4.4)WB 45 Sn()WB 11 Sn( Distri)HY(bu)HY(tion)YH()EH(

  )0 P(The last module that we load in our )SM(boot)HY(strap)YH(.build)ES( is
  )SM(dist)ES( which provides support for the prepa)HY(ra)HY(tion)YH( of
  distri)HY(bu)HY(tions)YH( and defines the )SM(dist)ES( meta-oper)HY(a)HY(tion)YH(. Similar to
  )SM(config)HY(ure)YH()ES(, )SM(dist)ES( is a meta-oper)HY(a)HY(tion)YH( rather than an
  oper)HY(a)HY(tion)YH( because, concep)HY(tu)HY(ally)YH(, we are prepar)HY(ing)YH( a distri)HY(bu)HY(tion)YH( for
  perform)HY(ing)YH( oper)HY(a)HY(tions)YH( \201like )SM(update)ES(, )SM(test)ES(\202 on
  targets rather than targets them)HY(selves)YH(.)EP(

  )0 P(The prepa)HY(ra)HY(tion)YH( of a correct distri)HY(bu)HY(tion)YH( requires that all the neces)HY(sary)YH(
  project files \201sources, docu)HY(men)HY(ta)HY(tion)YH(, etc\202 be listed as prereq)HY(ui)HY(sites)YH( in
  the project's )SM(build)HY(files)YH()ES(.)EP(

  )BR(
  )0 P(You may wonder why not just use the export support offered by many
  version control systems? The main reason is that in most real-world projects
  version control repos)HY(i)HY(to)HY(ries)YH( contain a lot more than what needs to be
  distributed. In fact, it is not uncom)HY(mon)YH( to host multi)HY(ple)YH( build system
  projects/pack)HY(ages)YH( in a single repos)HY(i)HY(tory)YH(. As a result, with this approach we
  seem to inevitably end up main)HY(tain)HY(ing)YH( an exclu)HY(sion)YH( list, which feels
  back)HY(wards)YH(: why specify all the things we don't want in a new list instead of
  making sure the already exist)HY(ing)YH( list of things that we do want is complete?
  Also, once we have the complete list, it can be put to good use by other
  tools, such as editors, IDEs, etc.)EP(
  )BR(

  )0 P(The prepa)HY(ra)HY(tion)YH( of a distri)HY(bu)HY(tion)YH( also requires an out of source build.
  This allows the )SM(dist)ES( module to distin)HY(guish)YH( between source and
  output targets. By default, targets found in src are included into the
  distri)HY(bu)HY(tion)YH( while those in out are excluded. However, we can customize this
  with the )SM(dist)ES( target-specific vari)HY(able)YH(.)EP(

  )0 P(As an example, let's prepare a distri)HY(bu)HY(tion)YH( of our )SM(hello)ES(
  project using the out of source build config)HY(ured)YH( in )SM(hello-out/)ES(.
  We use )SM(config.dist.root)ES( to specify the direc)HY(tory)YH( to write the
  distri)HY(bu)HY(tion)YH( to:)EP(

  ) 16 47 PR($ b dist: hello-out/ config.dist.root=/tmp/dist

$ ls -1 /tmp/dist
hello-0.1.0/

$ tree /tmp/dist/hello-0.1.0/
/tmp/dist/hello-0.1.0/
|-- build/
|   |-- bootstrap.build
|   `-- root.build
|-- hello/
|   |-- hello.cxx
|   |-- testscript
|   `-- buildfile
|-- buildfile
`-- manifest)RP(

  )0 P(As we can see, the distri)HY(bu)HY(tion)YH( direc)HY(tory)YH( includes the project version
  \201comes from the )SM(version)ES( vari)HY(able)YH( which, in our case, is
  extracted from )SM(mani)HY(fest)YH()ES( by the )SM(version)ES( module\202.
  Inside the distri)HY(bu)HY(tion)YH( direc)HY(tory)YH( we have our project's source files \201but,
  for example, without any )SM(.gitig)HY(nore)YH()ES( files that we may have had
  in )SM(hello/)ES(\202.)EP(

  )0 P(We can also ask the )SM(dist)ES( module to package the distri)HY(bu)HY(tion)YH(
  direc)HY(tory)YH( into one or more archives and gener)HY(ate)YH( their check)HY(sum)YH( files for
  us. For example:)EP(

  ) 11 37 PR($ b dist: hello-out/ \200
  config.dist.root=/tmp/dist \200
  config.dist.archives="tar.gz zip" \200
  config.dist.checksums=sha256

$ ls -1 /tmp/dist
hello-0.1.0/
hello-0.1.0.tar.gz
hello-0.1.0.tar.gz.sha256
hello-0.1.0.zip
hello-0.1.0.zip.sha256)RP(

  )BR(
  )0 P(We can also config)HY(ure)YH( our project with the desired
  )SM(config.dist.*)ES( values so we don't have to repeat them every
  time. For example:)EP(

  ) 2 56 PR($ b configure: hello-out/ config.dist.root=/tmp/dist ...
$ b dist)RP(
  )BR(

  )0 P(Let's now take a look at an example of customiz)HY(ing)YH( what gets distributed.
  Most of the time you will be using this mech)HY(a)HY(nism)YH( to include certain targets
  from out. Here is a frag)HY(ment)YH( from the )SM(libhello)ES( source direc)HY(tory)YH(
  )SM(build)HY(file)YH()ES(:)EP(

  ) 4 44 PR(hxx{version}: in{version} $src_root/manifest
{
  dist = true
})RP(

  )0 P(Our library provides the )SM(version.hxx)ES( header that the users
  can include to obtain its version. This header is gener)HY(ated)YH( by the
  )SM(version)ES( module from the )SM(version.hxx.in)ES( template.
  In essence, the )SM(version)ES( module takes the version value from our
  )SM(mani)HY(fest)YH()ES(, splits it into various compo)HY(nents)YH( \201major, minor,
  patch, etc\202 and then prepro)HY(cesses)YH( the )SM(in{})ES( file substi)HY(tut)HY(ing)YH(
  these values \201see )0 24 1 A()SM(version)ES( Module)24 0 TN TL()Ec /AF f D(
  for details\202. The end result is an auto)HY(mat)HY(i)HY(cally)YH( main)HY(tained)YH( version
  header.)EP(

  )0 P(One problem with auto-gener)HY(ated)YH( headers is that if one does not yet
  exist, then the compiler may still find it some)HY(where)YH( else. For example, we
  may have an older version of a library installed some)HY(where)YH( where the
  compiler searches for headers by default \201for example,
  )SM(/usr/local/include/)ES(\202. To over)HY(come)YH( this problem it is a good
  idea to ship pre-gener)HY(ated)YH( headers in our distri)HY(bu)HY(tions)YH(.  But since they are
  output targets, we have to explic)HY(itly)YH( request this with
  )SM(dist=true)ES(.)EP(

  )0 2 10 H(1.5)WB 46 Sn()WB 12 Sn( Target Impor)HY(ta)HY(tion)YH()EH(

  )0 P(Recall that if we need to depend on a target defined in another
  )SM(build)HY(file)YH()ES( within our project, then we simply include said
  )SM(build)HY(file)YH()ES( and refer)HY(ence)YH( the target.  For example, if our
  )SM(hello)ES( included both an executable and a library in sepa)HY(rate)YH(
  subdi)HY(rec)HY(to)HY(ries)YH( next to each other:)EP(

  ) 9 17 PR(hello/
|-- build/
|   `-- ...
|-- hello/
|   |-- ...
|   `-- buildfile
`-- libhello/
    |-- ...
    `-- buildfile)RP(

  )0 P(Then our executable )SM(build)HY(file)YH()ES( could look like this:)EP(

  ) 3 42 PR(include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} lib{hello})RP(

  )0 P(What if instead )SM(libhello)ES( were a sepa)HY(rate)YH( project? The
  inclu)HY(sion)YH( approach would no longer work for two reasons: we don't know the
  path to )SM(libhello)ES( \201after all, it's an inde)HY(pen)HY(dent)YH( project and
  can reside anywhere\202 and we can't assume the path to the
  )SM(lib{hello})ES( target within )SM(libhello)ES( \201the project
  direc)HY(tory)YH( layout can change\202.)EP(

  )0 P(To depend on a target from a sepa)HY(rate)YH( project we use )I(impor)HY(ta)HY(tion)YH()ES(
  instead of inclu)HY(sion)YH(. This mech)HY(a)HY(nism)YH( is also used to depend on targets that
  are not part of any project, for example, installed libraries.)EP(

  )0 P(The import)HY(ing)YH( project's side is pretty simple. This is what the above
  )SM(build)HY(file)YH()ES( will look like if )SM(libhello)ES( were a
  sepa)HY(rate)YH( project:)EP(

  ) 3 33 PR(import libs = libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs)RP(

  )0 P(The )SM(import)ES( direc)HY(tive)YH( is a kind of vari)HY(able)YH( assign)HY(ment)YH( that
  resolves a )I(project-qual)HY(i)HY(fied)YH()ES( rela)HY(tive)YH( target
  \201)SM(libhello%lib{hello})ES(\202 to an unqual)HY(i)HY(fied)YH( abso)HY(lute)YH( target and
  stores it in the vari)HY(able)YH( \201)SM(libs)ES( in our case\202. We can then
  expand the vari)HY(able)YH( \201)SM($libs)ES(\202, normally in the depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH(, to get the imported target.)EP(

  )0 P(If we needed to import several libraries, then we simply repeat the
  )SM(import)ES( direc)HY(tive)YH(, usually accu)HY(mu)HY(lat)HY(ing)YH( the result in the same
  vari)HY(able)YH(, for example:)EP(

  ) 5 36 PR(import libs  = libformat%lib{format}
import libs += libprint%lib{print}
import libs += libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs)RP(

  )0 P(Let's now try to build our )SM(hello)ES( project that uses imported
  )SM(libhello)ES(:)EP(

  ) 4 67 PR($ b hello/
error: unable to import target libhello%lib{hello}
  info: use config.import.libhello command line variable to specify
        its project out_root)RP(

  )0 P(While that didn't work out well, it does make sense: the build system
  cannot know the loca)HY(tion)YH( of )SM(libhello)ES( or which of its builds we
  want to use. Though it does help)HY(fully)YH( suggest that we use
  )SM(config.import.libhello)ES( to specify its out direc)HY(tory)YH(
  \201)SM(out_root)ES(\202. Let's point it to )SM(libhello)ES( source
  direc)HY(tory)YH( to use its in source build
  \201)SM(out_root\240==\240src_root)ES(\202:)EP(

  ) 5 43 PR($ b hello/ config.import.libhello=libhello/
c++ libhello/libhello/cxx{hello}
ld libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello}
ld hello/hello/exe{hello})RP(

  )0 P(And it works. Natu)HY(rally)YH(, the impor)HY(ta)HY(tion)YH( mech)HY(a)HY(nism)YH( works the same for out
  of source builds and we can persist the )SM(config.import.*)ES(
  vari)HY(ables)YH( in the project's config)HY(u)HY(ra)HY(tion)YH(. As an example, let's config)HY(ure)YH(
  Clang builds of the two projects out of source:)EP(

  ) 9 59 PR($ b configure: libhello/@libhello-clang/ config.cxx=clang++
$ b configure: hello/@hello-clang/ config.cxx=clang++ \200
  config.import.libhello=libhello-clang/

$ b hello-clang/
c++ libhello/libhello/cxx{hello}@libhello-clang/libhello/
ld libhello-clang/libhello/libs{hello}
c++ hello/hello/cxx{hello}@hello-clang/hello/
ld hello-clang/hello/exe{hello})RP(

  )0 P(If the corre)HY(spond)HY(ing)YH( )SM(config.import.*)ES( vari)HY(able)YH( is not
  spec)HY(i)HY(fied)YH(, )SM(import)ES( searches for a project in a couple of other
  places. First, it looks in the list of subpro)HY(jects)YH( start)HY(ing)YH( from the
  import)HY(ing)YH( project itself and then contin)HY(u)HY(ing)YH( with its outer amal)HY(ga)HY(ma)HY(tions)YH(
  and their subpro)HY(jects)YH( \201see )0 14 1 A(Subpro)HY(jects)YH( and
  Amal)HY(ga)HY(ma)HY(tions)YH()14 0 TN TL()Ec /AF f D( for details on this subject\202.)EP(

  )BR(
  )0 P(We've actu)HY(ally)YH( seen an example of this search step in action: the
  )SM(tests)ES( subpro)HY(ject)YH( in )SM(libhello)ES(. The test imports
  )SM(libhello)ES( which is auto)HY(mat)HY(i)HY(cally)YH( found as an amal)HY(ga)HY(ma)HY(tion)YH(
  contain)HY(ing)YH( this subpro)HY(ject)YH(.)EP(
  )BR(

  )0 P(If the project being imported cannot be located using any of these
  methods, then )SM(import)ES( falls back to the rule-specific search.
  That is, a rule that matches the target may provide support for import)HY(ing)YH(
  certain target types based on rule-specific knowl)HY(edge)YH(. Support for import)HY(ing)YH(
  installed libraries by the C++ link rule is a good example of this.
  Inter)HY(nally)YH(, the )SM(cxx)ES( module extracts the compiler's library
  search paths \201that is, paths that would be used to resolve
  )SM(-lfoo)ES(\202 and then the link rule uses them to search for installed
  libraries. This allows us to use the same )SM(import)ES( direc)HY(tive)YH(
  regard)HY(less)YH( of whether we import a library from a sepa)HY(rate)YH( build, from a
  subpro)HY(ject)YH(, or from an instal)HY(la)HY(tion)YH( direc)HY(tory)YH(.)EP(

  )BR(
  )0 P(Impor)HY(ta)HY(tion)YH( of an installed library will work even if it is not a
  )SM(build2)ES( project. Besides finding the library itself, the link
  rule will also try to locate its )SM(pkg-config\2011\202)ES( file and, if
  present, extract addi)HY(tional)YH( compile/link flags from it. The link rule also
  auto)HY(mat)HY(i)HY(cally)YH( produces )SM(pkg-config\2011\202)ES( files for libraries that
  it installs.)EP(
  )BR(

  )0 P(Let's now examine the export)HY(ing)YH( side of the impor)HY(ta)HY(tion)YH( mech)HY(a)HY(nism)YH(. While
  a project doesn't need to do anything special to be found by
  )SM(import)ES(, it does need to handle locat)HY(ing)YH( the exported target \201or
  targets; there could be several\202 within the project as well as loading their
  )SM(build)HY(files)YH()ES(. And this is the job of an )I(export stub)ES(, the
  )SM(build/export.build)ES( file that you might have noticed in the
  )SM(libhello)ES( project:)EP(

  ) 4 20 PR(libhello
|-- build/
|   `-- export.build
`-- ...)RP(

  )0 P(Let's take a look inside:)EP(

  ) 6 40 PR($out_root/
{
  include libhello/
}

export $out_root/libhello/$import.target)RP(

  )0 P(An export stub is a special kind of )SM(build)HY(file)YH()ES( that bridges
  from the import)HY(ing)YH( project into export)HY(ing)YH(. It is loaded in a special
  tempo)HY(rary)YH( scope out of any project, in a "no man's land" so to speak. The
  only vari)HY(ables)YH( set on the tempo)HY(rary)YH( scope are )SM(src_root)ES( and
  )SM(out_root)ES( of the project being imported as well as
  )SM(import.target)ES( contain)HY(ing)YH( the name of the target being imported
  \201without project qual)HY(i)HY(fi)HY(ca)HY(tion)YH(; that is, )SM(lib{hello})ES( in our
  example\202.)EP(

  )0 P(Typi)HY(cally)YH(, an export stub will open the scope of the export)HY(ing)YH( project,
  load the )SM(build)HY(file)YH()ES( that defines the target being exported and
  finally "return" the abso)HY(lute)YH( target name to the import)HY(ing)YH( project using the
  )SM(export)ES( direc)HY(tive)YH(. And this is exactly what the export stub in
  our )SM(libhello)ES( does.)EP(

  )0 P(We now have all the pieces of the impor)HY(ta)HY(tion)YH( puzzle in place and you can
  prob)HY(a)HY(bly)YH( see how they all fit together. To summa)HY(rize)YH(, when the build system
  sees the )SM(import)ES( direc)HY(tive)YH(, it looks for a project with the
  spec)HY(i)HY(fied)YH( name. If found, it creates a tempo)HY(rary)YH( scope, sets the
  )SM(src/out_root)ES( vari)HY(ables)YH( to point to the project and
  )SM(import.target)ES( \235 to the target name spec)HY(i)HY(fied)YH( in the
  )SM(import)ES( direc)HY(tive)YH(. And then it load the project's export stub in
  this scope. Inside the export stub we switch to the project's root scope,
  load its )SM(build)HY(file)YH()ES( and then use the )SM(export)ES(
  direc)HY(tive)YH( to return the exported target. Once the export stub is processed,
  the build system obtains the exported target and assigns it to the vari)HY(able)YH(
  spec)HY(i)HY(fied)YH( in the )SM(import)ES( direc)HY(tive)YH(.)EP(

  )BR(
  )0 P(Our export stub is quite "loose" in that it allows import)HY(ing)YH( any target
  defined in the project's source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES(. While
  we found it to be a good balance between strict)HY(ness)YH( and flex)HY(i)HY(bil)HY(ity)YH(, if you
  would like to "tighten" your export stubs, you can. For example:)EP(

  ) 2 42 PR(if \201$import.target == lib{hello}\202
  export $out_root/libhello/$import.target)RP(

  )0 P(If no )SM(export)ES( direc)HY(tive)YH( is executed in an export stub then
  the build system assumes that the target is not exported by the project and
  issues appro)HY(pri)HY(ate)YH( diag)HY(nos)HY(tics)YH(.)EP(
  )BR(

  )0 2 11 H(1.6)WB 47 Sn()WB 13 Sn( Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()EH(

  )0 P(By now we have exam)HY(ined)YH( and explained every line of every
  )SM(build)HY(file)YH()ES( in our )SM(hello)ES( executable project. There
  are, however, still a few lines to be covered in the source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(file)YH()ES( in )SM(libhello)ES(. Here it is in its
  entirety:)EP(

  ) 51 70 PR(int_libs = # Interface dependencies.
imp_libs = # Implementation dependencies.

lib{hello}: {hxx ixx txx cxx}{** -version} hxx{version} \200
  $imp_libs $int_libs

# Include the generated version header into the distribution \201so that
# we don't pick up an installed one\202 and don't remove it when cleaning
# in src \201so that clean results in a state identical to distributed\202.
#
hxx{version}: in{version} $src_root/manifest
{
  dist  = true
  clean = \201$src_root != $out_root\202
}

# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

obja{*}: cxx.poptions += -DLIBHELLO_STATIC_BUILD
objs{*}: cxx.poptions += -DLIBHELLO_SHARED_BUILD

# Export options.
#
lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $int_libs
}
)WR(
liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor"

# Install into the libhello/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libhello/
  install.subdirs = true
})RP(

  )0 P(Let's start with all those )SM(cxx.export.*)ES( vari)HY(ables)YH(. It turns
  out that merely export)HY(ing)YH( a library target is not enough for the importers
  of the library to be able to use it. They also need to know where to find
  its headers, which other libraries to link, etc. This infor)HY(ma)HY(tion)YH( is carried
  in a set of target-specific )SM(cxx.export.*)ES( vari)HY(ables)YH( that
  paral)HY(lel)YH( the )SM(cxx.*)ES( set and that together with the library's
  prereq)HY(ui)HY(sites)YH( consti)HY(tute)YH( the )I(library meta-infor)HY(ma)HY(tion)YH( proto)HY(col)YH()ES(. Every
  time a source file that depends on a library is compiled or a binary is
  linked, this infor)HY(ma)HY(tion)YH( is auto)HY(mat)HY(i)HY(cally)YH( extracted by the compile and link
  rules from the library depen)HY(dency)YH( chain, recur)HY(sively)YH(. And when the library
  is installed, this infor)HY(ma)HY(tion)YH( is carried over to its
  )SM(pkg-config\2011\202)ES( file.)EP(

  )BR(
  )0 P(Similar to the )SM(c.*)ES( and )SM(cc.*)ES( sets discussed
  earlier, there are also )SM(c.export.*)ES( and )SM(cc.export.*)ES(
  sets.)EP(
  )BR(

  )0 P(Here are the parts rele)HY(vant)YH( to the library meta-infor)HY(ma)HY(tion)YH( proto)HY(col)YH( in
  the above )SM(build)HY(file)YH()ES(:)EP(

  ) 13 53 PR(int_libs = # Interface dependencies.
imp_libs = # Implementation dependencies.

lib{hello}: ... $imp_libs $int_libs

lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $int_libs
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED)RP(

  )0 P(As a first step we clas)HY(sify)YH( all our library depen)HY(den)HY(cies)YH( into
  )I(inter)HY(face)YH( depen)HY(den)HY(cies)YH()ES( and )I(imple)HY(men)HY(ta)HY(tion)YH( depen)HY(den)HY(cies)YH()ES(. A
  library is an inter)HY(face)YH( depen)HY(dency)YH( if it is refer)HY(enced)YH( from our inter)HY(face)YH(,
  for example, by includ)HY(ing)YH( \201import)HY(ing)YH(\202 one of its headers \201modules\202 from one
  of our \201public\202 headers \201modules\202 or if one of its func)HY(tions)YH( is called from
  our inline or template func)HY(tions)YH(. Other)HY(wise)YH(, it is an imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(dency)YH(.)EP(

  )0 P(To illus)HY(trate)YH( the distinc)HY(tion)YH( between inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(den)HY(cies)YH(, let's say we've reim)HY(ple)HY(mented)YH( our )SM(libhello)ES( to use
  )SM(libfor)HY(mat)YH()ES( to format the greet)HY(ing)YH( and )SM(libprint)ES( to
  print it.  Here is our new header \201)SM(hello.hxx)ES(\202:)EP(

  ) 13 66 PR(#include <libformat/format.hxx>

namespace hello
{
  void
  say_hello_formatted \201std::ostream&, const std::string& hello\202;

  inline void
  say_hello \201std::ostream& o, const std::string& name\202
  {
    say_hello_formatted \201o, format::format_hello \201"Hello", name\202\202;
  }
})RP(

  )0 P(And this is the new source file \201)SM(hello.cxx)ES(\202:)EP(

  ) 10 51 PR(#include <libprint/print.hxx>

namespace hello
{
  void
  say_hello_formatted \201ostream& o, const string& h\202
  {
    print::print_hello \201o, h\202;
  }
})RP(

  )0 P(In this case, )SM(libfor)HY(mat)YH()ES( is our inter)HY(face)YH( depen)HY(dency)YH( since we
  both include its header in our inter)HY(face)YH( and call it from one of our inline
  func)HY(tions)YH(. In contrast, )SM(libprint)ES( is only included and used in
  the source file and so we can safely treat it as an imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(dency)YH(. The corre)HY(spond)HY(ing)YH( )SM(import)ES( direc)HY(tives)YH( in our
  )SM(build)HY(file)YH()ES( will there)HY(fore)YH( look like this:)EP(

  ) 2 39 PR(import int_libs = libformat%lib{format}
import imp_libs = libprint%lib{print})RP(

  )0 P(The prepro)HY(ces)HY(sor)YH( options \201)SM(poptions)ES(\202 of an inter)HY(face)YH(
  depen)HY(dency)YH( must be made avail)HY(able)YH( to our library's users. The library itself
  should also be explic)HY(itly)YH( linked when)HY(ever)YH( our library is linked. All this is
  achieved by listing the inter)HY(face)YH( depen)HY(den)HY(cies)YH( in the
  )SM(cxx.export.libs)ES( vari)HY(able)YH(:)EP(

  ) 4 29 PR(lib{hello}:
{
  cxx.export.libs = $int_libs
})RP(

  )BR(
  )0 P(More precisely, the inter)HY(face)YH( depen)HY(dency)YH( should be explic)HY(itly)YH( linked if a
  user of our library may end up with a direct call to the depen)HY(dency)YH( in one
  of their object files. Not linking such a library is called
  )I(under)HY(link)HY(ing)YH()ES( while linking a library unnec)HY(es)HY(sar)HY(ily)YH( \201which can happen
  because we've included its header but are not actu)HY(ally)YH( calling any of its
  non-inline/template func)HY(tions)YH(\202 is called )I(over)HY(link)HY(ing)YH()ES(. Under)HY(link)HY(ing)YH( is
  an error on some plat)HY(forms)YH( while over)HY(link)HY(ing)YH( may slow down the process
  startup and/or waste its memory.)EP(

  )0 P(Note also that this only applies to shared libraries. In case of static
  libraries, both inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH( depen)HY(den)HY(cies)YH( are always linked,
  recur)HY(sively)YH(.)EP(
  )BR(

  )0 P(The remain)HY(ing)YH( lines in the library meta-infor)HY(ma)HY(tion)YH( frag)HY(ment)YH( are:)EP(

  ) 7 53 PR(lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED)RP(

  )0 P(The first line makes sure the users of our library can locate its headers
  by export)HY(ing)YH( the rele)HY(vant)YH( )SM(-I)ES( options. The last two lines define
  the library type macros that are relied upon by the )SM(export.hxx)ES(
  header to prop)HY(erly)YH( setup symbol export)HY(ing)YH(.)EP(

  )BR(
  )0 P(The )SM(liba{})ES( and )SM(libs{})ES( target types corre)HY(spond)YH(
  to the static and shared libraries, respec)HY(tively)YH(. And )SM(lib{})ES( is
  actu)HY(ally)YH( a target group that can contain one, the other, or both as its
  members.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, when we build a )SM(lib{})ES( target, which members
  will be built is deter)HY(mined)YH( by the )SM(config.bin.lib)ES( vari)HY(able)YH( with
  the )SM(static)ES(, )SM(shared)ES(, and )SM(both)ES(
  \201default\202 possi)HY(ble)YH( values. So to only build a shared library we can run:)EP(

  ) 1 25 PR($ b config.bin.lib=shared)RP(

  )0 P(When it comes to linking )SM(lib{})ES( prereq)HY(ui)HY(sites)YH(, which member
  is picked is controlled by the )SM(config.bin.{exe,liba,libs}.lib)ES(
  vari)HY(ables)YH( for the executable, static library, and shared library targets,
  respec)HY(tively)YH(. Each contains a list of )SM(shared)ES( and
  )SM(static)ES( values that deter)HY(mine)YH( the linking pref)HY(er)HY(ences)YH(. For
  example, to build both shared and static libraries but to link executable to
  static libraries we can run:)EP(

  ) 1 49 PR($ b config.bin.lib=both config.bin.exe.lib=static)RP(

  )0 P(See )0 25 1 A()SM(bin)ES( Module)25 0 TN TL()Ec /AF f D( for more
  infor)HY(ma)HY(tion)YH(.)EP(
  )BR(

  )0 P(Note also that we don't need to change anything in the above
  )SM(build)HY(file)YH()ES( if our library is header-only. In )SM(build2)ES(
  this is handled dynam)HY(i)HY(cally)YH( and auto)HY(mat)HY(i)HY(cally)YH( based on the absence of source
  file prereq)HY(ui)HY(sites)YH(. In fact, the same library can be header-only on some
  plat)HY(forms)YH( or in some config)HY(u)HY(ra)HY(tion)YH( and "source-full" in others.)EP(

  )BR(
  )0 P(In )SM(build2)ES( a header-only library \201or a module inter)HY(face)YH(-only
  library\202 is not a differ)HY(ent)YH( kind of library compared to static/shared
  libraries but is rather a binary-less, or )I(binless)ES( for short, static
  or shared library. So, theo)HY(ret)HY(i)HY(cally)YH(, it is possi)HY(ble)YH( to have a library that
  has a binless static and a binary-full \201)I(binfull)ES(\202 shared vari)HY(ants)YH(.
  Note also that binless libraries can depend on binfull libraries and are
  fully supported where the )SM(pkg-config\2011\202)ES( func)HY(tion)HY(al)HY(ity)YH( is
  concerned.)EP(

  )0 P(If you are creat)HY(ing)YH( a new library with )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( and
  are certain that it will always be binless and in all config)HY(u)HY(ra)HY(tions)YH(, then
  you can produce a simpli)HY(fied)YH( )SM(build)HY(file)YH()ES( by spec)HY(i)HY(fy)HY(ing)YH( the
  )SM(binless)ES( option, for example:)EP(

  ) 1 47 PR($ bdep new -t lib -l c++,binless libheader-only)RP(
  )BR(

  )0 P(Let's now turn to the second subject of this section and the last
  unex)HY(plained)YH( bit in our )SM(build)HY(file)YH()ES(: shared library version)HY(ing)YH(.
  Here is the rele)HY(vant)YH( frag)HY(ment)YH(:)EP(

  ) 4 65 PR(if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor")RP(

  )0 P(Shared library version)HY(ing)YH( is a murky, plat)HY(form)YH(-specific area. Instead of
  trying to come up with a unified version)HY(ing)YH( scheme that few are likely to
  compre)HY(hend)YH( \201similar to )SM(auto)HY(conf)YH()ES(\202, )SM(build2)ES( provides
  a plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version)HY(ing)YH( scheme as well as the ability to specify
  plat)HY(form)YH(-specific versions in a native format.)EP(

  )0 P(The library version is spec)HY(i)HY(fied)YH( with the )SM(bin.lib.version)ES(
  target-specific vari)HY(able)YH(. Its value should be a sequence of
  )SM(@)ES(-pairs with the left hand side \201key\202 being the plat)HY(form)YH( name
  and the right hand side \201value\202 being the version. An empty key signi)HY(fies)YH(
  the plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version \201see )0 25 1 A()SM(bin)ES(
  Module)25 0 TN TL()Ec /AF f D( for the exact seman)HY(tics)YH(\202. For example:)EP(

  ) 1 43 PR(lib{hello}: bin.lib.version = @-1.2 linux@3)RP(

  )0 P(While the inter)HY(face)YH( for plat)HY(form)YH(-specific versions is
  defined, their support is not yet imple)HY(mented)YH( by the C/C++ link and install
  rules.)EP(

  )0 P(A plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version is embed)HY(ded)YH( as a suffix into the library
  name \201and into its )SM(soname)ES( on rele)HY(vant)YH( plat)HY(forms)YH(\202 while
  plat)HY(form)YH(-specific versions are handled accord)HY(ing)YH( to the plat)HY(form)YH(. Contin)HY(u)HY(ing)YH(
  with the above example, these would be the result)HY(ing)YH( shared library names on
  select plat)HY(forms)YH(:)EP(

  ) 3 29 PR(libhello.so.3       # Linux
libhello-1.2.dll    # Windows
libhello-1.2.dylib  # Mac OS)RP(

  )0 P(With this back)HY(ground)YH( we can now explain what's going in our
  )SM(build)HY(file)YH()ES(:)EP(

  ) 4 65 PR(if $version.pre_release
  lib{hello}: bin.lib.version = @"-$version.project_id"
else
  lib{hello}: bin.lib.version = @"-$version.major.$version.minor")RP(

  )0 P(Here we only use plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( library version)HY(ing)YH(. For releases we
  embed both major and minor version compo)HY(nents)YH( assum)HY(ing)YH( that patch releases
  are binary compat)HY(i)HY(ble)YH(. For pre-releases, however, we use the complete
  version to make sure it cannot be used in place of another pre-release or
  the final version.)EP(

  )BR(
  )0 P(The )SM(version.project_id)ES( vari)HY(able)YH( contains the project's \201as
  opposed to package's\202, short)HY(est)YH( "version id". See the )0 24 1 A()SM(version)ES( Module)24 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 2 12 H(1.7)WB 48 Sn()WB 14 Sn( Subpro)HY(jects)YH( and Amal)HY(ga)HY(ma)HY(tions)YH()EH(

  )0 P(In )SM(build2)ES( projects can contain other projects, recur)HY(sively)YH(.
  In this arrange)HY(ment)YH( the outer project is called an )I(amal)HY(ga)HY(ma)HY(tion)YH()ES( and
  the inner \235 )I(subpro)HY(jects)YH()ES(. In contrast to impor)HY(ta)HY(tion)YH( where we
  merely refer)HY(ence)YH( a project some)HY(where)YH( else, amal)HY(ga)HY(ma)HY(tion)YH( is phys)HY(i)HY(cal)YH(
  contain)HY(ment)YH(. It can be )I(strong)ES( where the src direc)HY(tory)YH( of a subpro)HY(ject)YH(
  is within the amal)HY(ga)HY(mat)HY(ing)YH( project or )I(weak)ES( where only the out
  direc)HY(tory)YH( is contained.)EP(

  )0 P(There are several distinct use cases for amal)HY(ga)HY(ma)HY(tions)YH(. We've already
  discussed the )SM(tests/)ES( subpro)HY(ject)YH( in )SM(libhello)ES(. To
  recap, tradi)HY(tion)HY(ally)YH(, it is made a subpro)HY(ject)YH( rather than a subdi)HY(rec)HY(tory)YH( to
  support build)HY(ing)YH( it as a stan)HY(dalone)YH( project in order to test library
  instal)HY(la)HY(tions)YH(.)EP(

  )0 P(As discussed in )0 12 1 A(Target Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(,
  subpro)HY(jects)YH( and amal)HY(ga)HY(ma)HY(tions)YH( \201as well as their subpro)HY(jects)YH(, recur)HY(sively)YH(\202
  are auto)HY(mat)HY(i)HY(cally)YH( consid)HY(ered)YH( when resolv)HY(ing)YH( imports. As a result,
  amal)HY(ga)HY(ma)HY(tion)YH( can be used to )I(bundle)ES( depen)HY(den)HY(cies)YH( to produce an
  exter)HY(nal)YH( depen)HY(dency)YH(-free distri)HY(bu)HY(tion)YH(. For example, if our
  )SM(hello)ES( project imports )SM(libhello)ES(, then we could copy
  the )SM(libhello)ES( project into )SM(hello)ES(, for example:)EP(

  ) 24 38 PR($ tree hello/
hello/
|-- build/
|   `-- ...
|-- hello/
|   |-- hello.cxx
|   `-- ...
|-- libhello/
|   |-- build/
|   |   `-- ...
|   |-- libhello/
|   |   |-- hello.hxx
|   |   |-- hello.cxx
|   |   `-- ...
|   |-- tests/
|   |   `-- ...
|   `-- buildfile
`-- buildfile

$ b hello/
c++ hello/libhello/libhello/cxx{hello}
ld hello/libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello}
ld hello/hello/exe{hello})RP(

  )0 P(Note, however, that while project bundling can be useful in certain
  cases, it does not scale as a general depen)HY(dency)YH( manage)HY(ment)YH( solu)HY(tion)YH(. For
  that, inde)HY(pen)HY(dent)YH( pack)HY(ag)HY(ing)YH( and proper depen)HY(dency)YH( manage)HY(ment)YH( are the
  appro)HY(pri)HY(ate)YH( mech)HY(a)HY(nisms)YH(.)EP(

  )BR(
  )0 P(By default )SM(build2)ES( looks for subpro)HY(jects)YH( only in the root
  direc)HY(tory)YH( of a project. That is, every root subdi)HY(rec)HY(tory)YH( is exam)HY(ined)YH( to see
  if it itself is a project root. If you need to place a subpro)HY(ject)YH( some)HY(where)YH(
  else in your project's direc)HY(tory)YH( hier)HY(ar)HY(chy)YH(, then you will need to specify
  its loca)HY(tion)YH( \201and of all other subpro)HY(jects)YH(\202 explic)HY(itly)YH( with the
  )SM(subpro)HY(jects)YH()ES( vari)HY(able)YH( in )SM(boot)HY(strap)YH(.build)ES(. For
  example, if above we placed )SM(libhello)ES( into the
  )SM(extras/)ES( subdi)HY(rec)HY(tory)YH( of )SM(hello)ES(, then our
  )SM(boot)HY(strap)YH(.build)ES( would need to start like this:)EP(

  ) 3 30 PR(project = hello
subprojects = extras/libhello/
...)RP(

  )0 P(Note also that while impor)HY(ta)HY(tion)YH( of specific targets from subpro)HY(jects)YH( is
  always performed, whether they are loaded and built as part of the overall
  project build is controlled using the stan)HY(dard)YH( subdi)HY(rec)HY(to)HY(ries)YH( inclu)HY(sion)YH( and
  depen)HY(dency)YH( mech)HY(a)HY(nisms)YH(. Contin)HY(u)HY(ing)YH( with the above example, if we adjust the
  root )SM(build)HY(file)YH()ES( in )SM(hello)ES( to exclude the
  )SM(extras/)ES( subdi)HY(rec)HY(tory)YH( from the build:)EP(

  ) 1 25 PR(./: {*/ -build/ -extras/})RP(

  )0 P(Then while we can still import )SM(libhello)ES( from any
  )SM(build)HY(file)YH()ES( in our project, the entire )SM(libhello)ES( \201for
  example, its tests\202 will never be built as part of the )SM(hello)ES(
  build.)EP(

  )0 P(Similar to subpro)HY(jects)YH( we can also explic)HY(itly)YH( specify the project's
  amal)HY(ga)HY(ma)HY(tion)YH( with the )SM(amal)HY(ga)HY(ma)HY(tion)YH()ES( vari)HY(able)YH( \201again, in
  )SM(boot)HY(strap)YH(.build)ES(\202. This is rarely neces)HY(sary)YH( except if you want
  to prevent the project from being amal)HY(ga)HY(mated)YH(, in which case you should set
  it to the empty value.)EP(

  )0 P(If either of these vari)HY(ables)YH( is not explic)HY(itly)YH( set, then they will
  contain the auto)HY(mat)HY(i)HY(cally)YH( discov)HY(ered)YH( values.)EP(
  )BR(

  )0 P(Besides affect)HY(ing)YH( impor)HY(ta)HY(tion)YH(, another central prop)HY(erty)YH( of amal)HY(ga)HY(ma)HY(tion)YH(
  is config)HY(u)HY(ra)HY(tion)YH( inher)HY(i)HY(tance)YH(. As an example, let's config)HY(ure)YH( the above
  bundled )SM(hello)ES( project in its src direc)HY(tory)YH(:)EP(

  ) 13 63 PR($ b configure: hello/ config.cxx=clang++ config.cxx.coptions=-g

$ b tree
hello/
|-- build/
|   |-- config.build
|   `-- ...
|-- libhello/
|   |-- build/
|   |   |-- config.build
|   |   `-- ...
|   `-- ...
`-- ...)RP(

  )0 P(As you can see, we now have the )SM(config.build)ES( files in both
  project's )SM(build/)ES( subdi)HY(rec)HY(to)HY(ries)YH(. If we examine the
  amal)HY(ga)HY(ma)HY(tion)YH('s )SM(config.build)ES(, we will see the famil)HY(iar)YH(
  picture:)EP(

  ) 9 30 PR($ cat hello/build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.libs = [null]

...)RP(

  )0 P(The subpro)HY(ject)YH('s )SM(config.build)ES(, however, is pretty much
  empty:)EP(

  ) 3 39 PR($ cat hello/libhello/build/config.build

# Base configuration inherited from ../)RP(

  )0 P(As the comment suggests, the base config)HY(u)HY(ra)HY(tion)YH( is inher)HY(ited)YH( from the
  outer project. We can, however, over)HY(ride)YH( some values if we need to. For
  example \201note that we are re-config)HY(ur)HY(ing)YH( the )SM(libhello)ES(
  subpro)HY(ject)YH(\202:)EP(

  ) 7 54 PR($ b configure: hello/libhello/ config.cxx.coptions=-O2

$ cat hello/libhello/build/config.build

# Base configuration inherited from ../

config.cxx.coptions = -O2)RP(

  )0 P(This config)HY(u)HY(ra)HY(tion)YH( inher)HY(i)HY(tance)YH( combined with import reso)HY(lu)HY(tion)YH( is behind
  the most common use of amal)HY(ga)HY(ma)HY(tions)YH( in )SM(build2)ES( \235 shared
  build config)HY(u)HY(ra)HY(tions)YH(. Let's say we are devel)HY(op)HY(ing)YH( multi)HY(ple)YH( projects, for
  example, )SM(hello)ES( and )SM(libhello)ES( that it imports:)EP(

  ) 3 9 PR($ ls -1
hello/
libhello/)RP(

  )0 P(And we want to build them with several compil)HY(ers)YH(, let's say GCC and
  Clang. As we have already seen in )0 8 1 A(Config)HY(u)HY(ra)HY(tion)YH()8 0 TN TL()Ec /AF f D(, we can config)HY(ure)YH( several
  out of source builds for each compiler, for example:)EP(

  ) 17 59 PR($ b configure: libhello/@libhello-gcc/   config.cxx=g++
$ b configure: libhello/@libhello-clang/ config.cxx=clang++

$ b configure: hello/@hello-gcc/   \200
               config.cxx=g++      \200
               config.import.libhello=libhello-gcc/
$ b configure: hello/@hello-clang/ \200
               config.cxx=clang++  \200
               config.import.libhello=libhello-clang/

$ ls -l
hello/
hello-gcc/
hello-clang/
libhello/
libhello-gcc/
libhello-clang/)RP(

  )0 P(Need)HY(less)YH( to say, this is a lot of repet)HY(i)HY(tive)YH( typing. Another problem is
  future changes to the config)HY(u)HY(ra)HY(tions)YH(. If, for example, we need to adjust
  compile options in the GCC config)HY(u)HY(ra)HY(tion)YH(, then we will have to \201remem)HY(ber)YH( to\202
  do it in both places.)EP(

  )0 P(You can prob)HY(a)HY(bly)YH( sense where this is going: why not create a shared build
  config)HY(u)HY(ra)HY(tion)YH( \201that is, an amal)HY(ga)HY(ma)HY(tion)YH(\202 for GCC and Clang where we build
  both of our projects \201as its subpro)HY(jects)YH(\202? This is how we can do that:)EP(

  ) 14 46 PR($ b create: build-gcc/,cc   config.cxx=g++
$ b create: build-clang/,cc config.cxx=clang++

$ b configure: libhello/@build-gcc/libhello/
$ b configure: hello/@build-gcc/hello/

$ b configure: libhello/@build-clang/libhello/
$ b configure: hello/@build-clang/hello/

$ ls -l
hello/
libhello/
build-gcc/
build-clang/)RP(

  )0 P(Let's explain what's going on here. First, we create two build
  config)HY(u)HY(ra)HY(tions)YH( using the )SM(create)ES( meta-oper)HY(a)HY(tion)YH(. These are real
  )SM(build2)ES( projects just tailored for housing other projects as
  subpro)HY(jects)YH(. In )SM(create)ES(, after the direc)HY(tory)YH( name, we specify
  the list of modules to load in the project's )SM(root.build)ES(. In our
  case we specify )SM(cc)ES( which is a common module for C-based
  languages \201see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details on
  )SM(create)ES( and its param)HY(e)HY(ters)YH(\202.)EP(

  )BR(
  )0 P(When creat)HY(ing)YH( build config)HY(u)HY(ra)HY(tions)YH( it is a good idea to get into the
  habit of using the )SM(cc)ES( module instead of )SM(c)ES( or
  )SM(cxx)ES( since with more complex depen)HY(dency)YH( chains we may not know
  whether every project we build only uses C or C++. In fact, it is not
  uncom)HY(mon)YH( for a C++ project to have C imple)HY(men)HY(ta)HY(tion)YH( details and even the
  other way around \201yes, really, there are C libraries with C++
  imple)HY(men)HY(ta)HY(tions)YH(\202.)EP(
  )BR(

  )0 P(Once the config)HY(u)HY(ra)HY(tions)YH( are ready we simply config)HY(ure)YH( our
  )SM(libhello)ES( and )SM(hello)ES( as subpro)HY(jects)YH( in each of them.
  Note that now we neither need to specify )SM(config.cxx)ES(, because it
  will be inher)HY(ited)YH( from the amal)HY(ga)HY(ma)HY(tion)YH(, nor )SM(config.import.*)ES(,
  because the import will be auto)HY(mat)HY(i)HY(cally)YH( resolved to a subpro)HY(ject)YH(.)EP(

  )0 P(Now, to build a specific project in a partic)HY(u)HY(lar)YH( config)HY(u)HY(ra)HY(tion)YH( we simply
  build the corre)HY(spond)HY(ing)YH( subdi)HY(rec)HY(tory)YH(. We can also build the entire build
  config)HY(u)HY(ra)HY(tion)YH( if we want to. For example:)EP(

  ) 3 20 PR($ b build-gcc/hello/

$ b build-clang/)RP(

  )BR(
  )0 P(In case you've already looked into )0 2 A()SM()BD(bpkg\2011\202)ES()ES()EA( and/or )0 2 A()SM()BD(bdep\2011\202)ES()ES()EA(, their
  build config)HY(u)HY(ra)HY(tions)YH( are actu)HY(ally)YH( these same amal)HY(ga)HY(ma)HY(tions)YH( \201created
  under)HY(neath)YH( with the )SM(create)ES( meta-oper)HY(a)HY(tion)YH(\202 and their pack)HY(ages)YH(
  are just subpro)HY(jects)YH(. And with this under)HY(stand)HY(ing)YH( you are free to inter)HY(act)YH(
  with them directly using the build system inter)HY(face)YH(.)EP(
  )BR(

  )0 2 13 H(1.8)WB 49 Sn()WB 15 Sn( Build)HY(file)YH( Language)EH(

  )0 P(By now we should have a good overall sense of what writing
  )SM(build)HY(files)YH()ES( feels like. In this section we will examine the
  language in slightly more detail and with more preci)HY(sion)YH(.)EP(

  )0 P(Build)HY(file)YH( is primar)HY(ily)YH( a declar)HY(a)HY(tive)YH( language with support for vari)HY(ables)YH(,
  pure func)HY(tions)YH(, repe)HY(ti)HY(tion)YH( \201)SM(for)ES(-loop\202, and condi)HY(tional)YH(
  inclu)HY(sion)YH(/exclu)HY(sion)YH( \201)SM(if-else)ES(\202.)EP(

  )0 P(Build)HY(file)YH( is a line-oriented language. That is, every construct ends at
  the end of the line unless escaped with line contin)HY(u)HY(a)HY(tion)YH( \201trail)HY(ing)YH(
  )SM(\200)ES(\202. For example:)EP(

  ) 2 27 PR(exe{hello}: {hxx cxx}{**} \200
  $libs)RP(

  )0 P(Some lines may start a )I(block)ES( if followed by )SM({)ES( on the
  next line. Such a block ends with a closing )SM(})ES( on a sepa)HY(rate)YH(
  line. Some types of blocks can nest. For example:)EP(

  ) 7 37 PR(if \201$cxx.target.class == 'windows'\202
{
  if \201$cxx.target.system == 'ming32'\202
  {
    ...
  }
})RP(

  )0 P(A comment starts with )SM(#)ES( and every)HY(thing)YH( from this char)HY(ac)HY(ter)YH(
  and until the end of the line is ignored. A multi-line comment starts with
  )SM(#\200)ES( on a sepa)HY(rate)YH( line and ends with the same char)HY(ac)HY(ter)YH(
  sequence, again on a sepa)HY(rate)YH( line. For example:)EP(

  ) 9 40 PR(# Single line comment.

info 'Hello, World!' # Trailing comment.

#\200
Multi-
line
comment.
#\200)RP(

  )0 P(The three primary Build)HY(file)YH( constructs are depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(,
  direc)HY(tive)YH(, and vari)HY(able)YH( assign)HY(ment)YH(. We've already used all three but let's
  see another example:)EP(

  ) 5 69 PR(include ../libhello/                  # Directive.

exe{hello}: {hxx cxx}{**} lib{hello}  # Dependency declaration.

cxx.poptions += -DNDEBUG              # Variable assignment \201append\202.)RP(

  )0 P(There is also the scope opening \201we've seen one in
  )SM(export.build)ES(\202 as well as target-specific and
  prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH( assign)HY(ment)YH( blocks. The latter two are used to
  assign several entity-specific vari)HY(ables)YH( at once. For example:)EP(

  ) 16 57 PR(details/                          # scope
{
  hxx{*}: install = false
}

hxx{version}:                     # target-specific
{
  dist  = true
  clean = \201$src_root != $out_root\202
}

exe{test}: file{test.roundtrip}:  # prerequisite-specific
{
  test.stdin  = true
  test.stdout = true
})RP(

  )0 P(Vari)HY(able)YH( assign)HY(ment)YH( blocks can be combined with depen)HY(dency)YH( decla)HY(ra)HY(tions)YH(,
  for example:)EP(

  ) 8 34 PR(h{config}: in{config}
{
  in.symbol = '@'
  in.substitution = lax

  SYSTEM_NAME = $c.target.system
  SYSTEM_PROCESSOR = $c.target.cpu
})RP(

  )0 P(In case of a depen)HY(dency)YH( chain, the block applies to the set of
  prereq)HY(ui)HY(sites)YH( \201note: )I(not targets)ES(\202 before last )SM(:)ES(. For
  example:)EP(

  ) 4 63 PR(./: exe{test}: libue{test}: cxx{test}
{
  bin.whole = false  # Applies to the libue{test} prerequisite.
})RP(

  )BR(
  )0 P(All prereq)HY(ui)HY(site)YH(-specific vari)HY(ables)YH( must be assigned at once as part of
  the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( since repeat)HY(ing)YH( the same depen)HY(dency)YH( again
  dupli)HY(cates)YH( the prereq)HY(ui)HY(site)YH( rather than refer)HY(ences)YH( the already exist)HY(ing)YH(
  one.)EP(

  )0 P(There is also the target type/pattern-specific vari)HY(able)YH( assign)HY(ment)YH( block,
  for example:)EP(

  ) 5 17 PR(exe{*.test}:
{
  test = true
  install = false
})RP(

  )0 P(See )0 22 1 A(Vari)HY(ables)YH()22 0 TN TL()Ec /AF f D( for more infor)HY(ma)HY(tion)YH(.)EP(
  )BR(

  )0 P(Each )SM(build)HY(file)YH()ES( is processed linearly with direc)HY(tives)YH(
  executed and vari)HY(ables)YH( expanded as they are encoun)HY(tered)YH(. However, certain
  vari)HY(ables)YH(, for example, )SM(cxx.poptions)ES( are also expanded by rules
  during execu)HY(tion)YH( in which case they will "see" the final value set in the
  )SM(build)HY(file)YH()ES(.)EP(

  )BR(
  )0 P(Unlike GNU )SM(make\2011\202)ES(, which has deferred \201)SM(=)ES(\202 and
  imme)HY(di)HY(ate)YH( \201)SM(:=)ES(\202 vari)HY(able)YH( assign)HY(ments)YH(, all assign)HY(ments)YH( in
  )SM(build2)ES( are imme)HY(di)HY(ate)YH(. For example:)EP(

  ) 4 30 PR(x = x
y = $x
x = X
info $y # Prints 'x', not 'X'.)RP(
  )BR(

  )0 3 14 H(1.8.1)WB 50 Sn()WB 16 Sn( Expan)HY(sion)YH( and Quoting)EH(

  )0 P(While we've discussed vari)HY(able)YH( expan)HY(sion)YH( and lookup earlier, to recap, to
  get the vari)HY(able)YH('s value we use )SM($)ES( followed by its name. The
  vari)HY(able)YH( name is first looked up in the current scope \201that is, the scope in
  which the expan)HY(sion)YH( was encoun)HY(tered)YH(\202 and, if not found, in the outer scopes,
  recur)HY(sively)YH(.)EP(

  )0 P(There are two other kinds of expan)HY(sions)YH(: func)HY(tion)YH( calls and eval)HY(u)HY(a)HY(tion)YH(
  contexts, or )I(eval contexts)ES( for short. Let's start with the latter
  since func)HY(tion)YH( calls are built on top of eval contexts.)EP(

  )0 P(An eval context is essen)HY(tially)YH( a frag)HY(ment)YH( of a line with addi)HY(tional)YH(
  inter)HY(pre)HY(ta)HY(tions)YH( of certain char)HY(ac)HY(ters)YH( to support value compar)HY(i)HY(son)YH(, logical
  oper)HY(a)HY(tors)YH(, and a few other constructs. Eval contexts begin with
  )SM(\201)ES(, end with )SM(\202)ES(, and can nest. Here are a few
  exam)HY(ples)YH(:)EP(

  ) 8 69 PR(info \201$src_root != $out_root\202                 # Prints true or false.
info \201$src_root == $out_root ? 'in' : 'out'\202  # Prints in or out.

macos = \201$cxx.target.class == 'macos'\202  # Assigns true or false.
linux = \201$cxx.target.class == 'linux'\202  # Assigns true or false.

if \201$macos || $linux\202  # Also eval context.
  ...)RP(

  )BR(
  )0 P(Below is the eval context grammar that shows supported oper)HY(a)HY(tors)YH( and
  their prece)HY(dence)YH(.)EP(

  ) 10 68 PR(eval:         '\201' \201eval-comma | eval-qual\202? '\202'
eval-comma:   eval-ternary \201',' eval-ternary\202*
eval-ternary: eval-or \201'?' eval-ternary ':' eval-ternary\202?
eval-or:      eval-and \201'||' eval-and\202*
eval-and:     eval-comp \201'&&' eval-comp\202*
eval-comp:    eval-value \201\201'=='|'!='|'<'|'>'|'<='|'>='\202 eval-value\202*
eval-value:   value-attributes? \201<value> | eval | '!' eval-value\202
eval-qual:    <name> ':' <name>

value-attributes: '[' <key-value-pairs> ']')RP(

  )0 P(Note that )SM(?:)ES( \201ternary oper)HY(a)HY(tor)YH(\202 and )SM(!)ES( \201logical
  not\202 are right-asso)HY(cia)HY(tive)YH(. Unlike C++, all the compar)HY(i)HY(son)YH( oper)HY(a)HY(tors)YH( have
  the same prece)HY(dence)YH(. A qual)HY(i)HY(fied)YH( name cannot be combined with any other
  oper)HY(a)HY(tor)YH( \201includ)HY(ing)YH( ternary\202 unless enclosed in paren)HY(the)HY(ses)YH(. The
  )SM(eval)ES( option in the )SM(eval-value)ES( produc)HY(tion)YH( shall
  contain a single value only \201no commas\202.)EP(
  )BR(

  )0 P(A func)HY(tion)YH( call starts with )SM($)ES( followed by its name and an
  eval context listing its argu)HY(ments)YH(. Note that there is no space between the
  name and )SM(\201)ES(. For example:)EP(

  ) 14 51 PR(x =
y = Y

info $empty\201$x\202  # true
info $empty\201$y\202  # false

if $regex.match\201$y, '[A-Z]'\202
  ...

p = $src_base/foo.txt

info $path.leaf\201$src_base\202              # foo.txt
info $path.directory\201$src_base\202         # $src_base
info $path.base\201$path.leaf\201$src_base\202\202  # foo)RP(

  )0 P(Note that func)HY(tions)YH( in )SM(build2)ES( are )I(pure)ES( in a sense
  that they do not alter the build state in any way.)EP(

  )BR(
  )0 P(Func)HY(tions)YH( in )SM(build2)ES( are currently defined either by the
  build system core or build system modules and are imple)HY(mented)YH( in C++. In the
  future it will be possi)HY(ble)YH( to define custom func)HY(tions)YH( in
  )SM(build)HY(files)YH()ES( \201also in C++\202.)EP(
  )BR(

  )0 P(Vari)HY(able)YH( and func)HY(tion)YH( names follow the C iden)HY(ti)HY(fier)YH( rules. We can also
  group vari)HY(ables)YH( into names)HY(paces)YH( and func)HY(tions)YH( into fami)HY(lies)YH( by combin)HY(ing)YH(
  multi)HY(ple)YH( iden)HY(ti)HY(fiers)YH( with )SM(.)ES(. These rules are used to deter)HY(mine)YH(
  the end of the vari)HY(able)YH( name in expan)HY(sions)YH(. If, however, a name is
  recog)HY(nized)YH( as being longer than desired, then we can use the eval context to
  explic)HY(itly)YH( specify its bound)HY(aries)YH(. For example:)EP(

  ) 2 18 PR(base = foo
name = $\201base\202.txt)RP(

  )0 P(What is the struc)HY(ture)YH( of a vari)HY(able)YH( value? Consider this assign)HY(ment)YH(:)EP(

  ) 1 11 PR(x = foo bar)RP(

  )0 P(The value of )SM(x)ES( could be a string, a list of two strings, or
  some)HY(thing)YH( else entirely. In )SM(build2)ES( the funda)HY(men)HY(tal)YH(, untyped
  value is a )I(list of names)ES(. A value can be typed to some)HY(thing)YH( else
  later but it always starts as a list of names. So in the above example we
  have a list of two names, )SM(foo)ES( and )SM(bar)ES(, the same as
  in this example \201notice the extra spaces\202:)EP(

  ) 1 14 PR(x = foo    bar)RP(

  )BR(
  )0 P(The moti)HY(va)HY(tion)YH( behind going with a list of names instead of a string or a
  list of strings is that at its core we are dealing with targets and their
  prereq)HY(ui)HY(sites)YH( and it would be natural to make the repre)HY(sen)HY(ta)HY(tion)YH( of their
  names \201that is, the way we refer to them\202 the default. Consider the
  follow)HY(ing)YH( two exam)HY(ples)YH(; it would be natural for them to mean the same
  thing:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  ) 2 23 PR(prereqs = {hxx cxx}{**}
exe{hello}: $prereqs)RP(

  )0 P(Note also that the name seman)HY(tics)YH( was care)HY(fully)YH( tuned to be
  )I(reversible)ES( to its syntac)HY(tic)YH( repre)HY(sen)HY(ta)HY(tion)YH( for common non-name
  values, such as paths, command line options, etc., that are usually found in
  )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(Names are split into a list at whites)HY(pace)YH( bound)HY(aries)YH( with certain other
  char)HY(ac)HY(ters)YH( treated as syntax rather than as part of the value. Here are a
  few example:)EP(

  ) 6 33 PR(x = $y          # expansion
x = \201a == b\202    # eval context
x = {foo bar}   # name generation
x = [null]      # attributes
x = name@value  # pairs
x = # comments)RP(

  )0 P(The complete set of syntax char)HY(ac)HY(ters)YH( is )SM($\201\202{}[]@#)ES( plus
  space and tab. Addi)HY(tion)HY(ally)YH(, )SM(*?)ES( will be treated as wild)HY(cards)YH( in
  a name pattern. If instead we need these char)HY(ac)HY(ters)YH( to appear liter)HY(ally)YH( as
  part of the value, then we either have to )I(escape)ES( or )I(quote)ES(
  them.)EP(

  )0 P(To escape a special char)HY(ac)HY(ter)YH(, we prefix it with a back)HY(slash)YH(
  \201)SM(\200)ES(; to specify a literal back)HY(slash)YH( double it\202. For example:)EP(

  ) 2 22 PR(x = \200$
y = C:\200\200Program\200 Files)RP(

  )0 P(Similar to UNIX shells, )SM(build2)ES( supports single
  \201)SM('')ES(\202 and double \201)SM("")ES(\202 quoting with roughly the same
  seman)HY(tics)YH(. Specif)HY(i)HY(cally)YH(, expan)HY(sions)YH( \201vari)HY(able)YH(, func)HY(tion)YH( call, and eval
  context\202 and escap)HY(ing)YH( are performed inside double-quoted strings but not in
  single-quoted. Note also that quoted strings can span multi)HY(ple)YH( lines with
  newlines treated liter)HY(ally)YH( \201unless escaped in double-quoted strings\202. For
  example:)EP(

  ) 9 26 PR(x = "\201a != b\202"  # true
y = '\201a != b\202'  # \201a != b\202

x = "C:\200\200Program Files"
y = 'C:\200Program Files'

t = 'line one
line two
line three')RP(

  )0 P(Since quote char)HY(ac)HY(ters)YH( are now also part of the syntax, if you need to
  specify them liter)HY(ally)YH( in the value, then they will either have to be
  escaped or quoted. For example:)EP(

  ) 2 40 PR(cxx.poptions += -DOUTPUT='"debug"'
cxx.poptions += -DTARGET=\200"$cxx.target\200")RP(

  )0 P(An expan)HY(sion)YH( can be one of two kinds: )I(spliced)ES( or
  )I(concate)HY(nated)YH()ES(. In a spliced expan)HY(sion)YH( the vari)HY(able)YH(, func)HY(tion)YH(, or eval
  context is sepa)HY(rated)YH( from other text with whites)HY(paces)YH(. In this case, as the
  name suggests, the result)HY(ing)YH( list of names is spliced into the value. For
  example:)EP(

  ) 2 53 PR(x = 'foo fox'
y = bar $x baz  # Three names: 'bar' 'foo fox' 'baz'.)RP(

  )BR(
  )0 P(This is an impor)HY(tant)YH( differ)HY(ence)YH( compared to the seman)HY(tics)YH( of UNIX shells
  where the result of expan)HY(sion)YH( is re-parsed. In partic)HY(u)HY(lar)YH(, this is the
  reason why you won't see quoted expan)HY(sions)YH( in )SM(build)HY(files)YH()ES( as
  often as in \201well-written\202 shell scripts.)EP(
  )BR(

  )0 P(In a concate)HY(nated)YH( expan)HY(sion)YH( the vari)HY(able)YH(, func)HY(tion)YH(, or eval context are
  combined with unsep)HY(a)HY(rated)YH( text before and/or after the expan)HY(sion)YH(. For
  example:)EP(

  ) 2 46 PR(x = 'foo fox'
y = bar$\201x\202foz  # Single name: 'barfoo foxbaz')RP(

  )0 P(A concate)HY(nated)YH( expan)HY(sion)YH( is typed unless it is quoted. In a typed
  concate)HY(nated)YH( expan)HY(sion)YH( the parts are combined in a type-aware manner while
  in an untyped \235 liter)HY(ally)YH(, as string. To illus)HY(trate)YH( the differ)HY(ence)YH(,
  consider this )SM(build)HY(file)YH()ES( frag)HY(ment)YH(:)EP(

  ) 2 24 PR(info $src_root/foo.txt
info "$src_root/foo.txt")RP(

  )0 P(If we run it on a UNIX-like oper)HY(at)HY(ing)YH( system, we will see two iden)HY(ti)HY(cal)YH(
  lines, along these lines:)EP(

  ) 2 17 PR(/tmp/test/foo.txt
/tmp/test/foo.txt)RP(

  )0 P(However, if we run it on Windows \201which uses back)HY(slashes)YH( as direc)HY(tory)YH(
  sepa)HY(ra)HY(tors)YH(\202, we will see the output along these lines:)EP(

  ) 2 15 PR(C:\200test\200foo.txt
C:\200test/foo.txt)RP(

  )0 P(The typed concate)HY(na)HY(tion)YH( resulted in a native direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH( because
  )SM(dir_path)ES( \201the )SM(src_root)ES( type\202 did the right
  thing.)EP(

  )0 P(Not every typed concate)HY(na)HY(tion)YH( is well defined and in certain situ)HY(a)HY(tions)YH(
  we may need to force untyped concate)HY(na)HY(tion)YH( with quoting. Options spec)HY(i)HY(fy)HY(ing)YH(
  header search paths \201)SM(-I)ES(\202 are a typical case, for example:)EP(

  ) 1 43 PR(cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )0 P(If we were to remove the quotes, we would see the follow)HY(ing)YH( error:)EP(

  ) 2 70 PR(buildfile:6:20: error: no typed concatenation of <untyped> to dir_path
  info: use quoting to force untyped concatenation)RP(

  )0 3 15 H(1.8.2)WB 51 Sn()WB 17 Sn( Condi)HY(tions)YH( \201)SM(if-else)ES(\202)EH(

  )0 P(The )SM(if)ES( direc)HY(tive)YH( can be used to condi)HY(tion)HY(ally)YH( exclude
  )SM(build)HY(file)YH()ES( frag)HY(ments)YH( from being processed. The condi)HY(tional)YH(
  frag)HY(ment)YH( can be a single \201sepa)HY(rate)YH(\202 line or a block with the initial
  )SM(if)ES( option)HY(ally)YH( followed by a number of )SM(elif)ES(
  direc)HY(tives)YH( and a final )SM(else)ES(, which together form the
  )SM(if-else)ES( chain. An )SM(if-else)ES( block can contain nested
  )SM(if-else)ES( chains. For example:)EP(

  ) 13 43 PR(if \201$cxx.target.class == 'linux'\202
  info 'linux'
elif \201$cxx.target.class == 'windows'\202
{
  if \201$cxx.target.system == 'mingw32'\202
    info 'windows-mingw'
  elif \201$cxx.target.system == 'win32-msvc'\202
    info 'windows-msvc'
  else
    info 'windows-other'
}
else
  info 'other')RP(

  )0 P(The )SM(if)ES( and )SM(elif)ES( direc)HY(tive)YH( names must be
  followed by some)HY(thing)YH( that expands to a single, literal )SM(true)ES( or
  )SM(false)ES(. This can be a vari)HY(able)YH( expan)HY(sion)YH(, a func)HY(tion)YH( call, an
  eval context, or a literal value. For example:)EP(

  ) 17 45 PR(if $version.pre_release
  ...

if $regex.match\201$x, '[A-Z]'\202
  ...

if \201$cxx.target.class == 'linux'\202
  ...

if false
{
  # disabled fragment
}

x = X
if $x  # Error, must expand to true or false.
  ...)RP(

  )0 P(There are also )SM(if!)ES( and )SM(elif!)ES( direc)HY(tives)YH( which
  negate the condi)HY(tion)YH( that follows \201note that there is no space before
  )SM(!)ES(\202. For example:)EP(

  ) 4 31 PR(if! $version.pre_release
  ...
elif! $regex.match\201$x, '[A-Z]'\202
  ...)RP(

  )0 P(Note also that there is no notion of vari)HY(able)YH( local)HY(ity)YH( in
  )SM(if-else)ES( blocks and any value set inside is visible outside. For
  example:)EP(

  ) 6 22 PR(if true
{
  x = X
}

info $x  # Prints 'X'.)RP(

  )0 P(The )SM(if-else)ES( chains should not be used for condi)HY(tional)YH(
  depen)HY(dency)YH( decla)HY(ra)HY(tions)YH( since this would violate the expec)HY(ta)HY(tion)YH( that all of
  the project's source files are listed as prereq)HY(ui)HY(sites)YH(, irre)HY(spec)HY(tive)YH( of the
  config)HY(u)HY(ra)HY(tion)YH(.  Instead, use the special )SM(include)ES(
  prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH( to condi)HY(tion)HY(ally)YH( include prereq)HY(ui)HY(sites)YH( into
  the build. For example:)EP(

  ) 11 72 PR(# Incorrect.
#
if \201$cxx.target.class == 'linux'\202
  exe{hello}: cxx{hello-linux}
elif \201$cxx.target.class == 'windows'\202
  exe{hello}: cxx{hello-win32}

# Correct.
#
exe{hello}: cxx{hello-linux}: include = \201$cxx.target.class == 'linux'\202
exe{hello}: cxx{hello-win32}: include = \201$cxx.target.class == 'windows'\202)RP(

  )0 3 16 H(1.8.3)WB 52 Sn()WB 18 Sn( Repe)HY(ti)HY(tions)YH( \201)SM(for)ES(\202)EH(

  )0 P(The )SM(for)ES( direc)HY(tive)YH( can be used to repeat the same
  )SM(build)HY(file)YH()ES( frag)HY(ment)YH( multi)HY(ple)YH( times, once for each element of a
  list. The frag)HY(ment)YH( to repeat can be a single \201sepa)HY(rate)YH(\202 line or a block,
  which together form the )SM(for)ES( loop. A )SM(for)ES( block can
  contain nested )SM(for)ES( loops. For example:)EP(

  ) 4 18 PR(for n: foo bar baz
{
  exe{$n}: cxx{$n}
})RP(

  )0 P(The )SM(for)ES( direc)HY(tive)YH( name must be followed by the vari)HY(able)YH( name
  \201called )I(loop vari)HY(able)YH()ES(\202 that on each iter)HY(a)HY(tion)YH( will be assigned the
  corre)HY(spond)HY(ing)YH( element, )SM(:)ES(, and some)HY(thing)YH( that expands to a
  poten)HY(tially)YH( empty list of values. This can be a vari)HY(able)YH( expan)HY(sion)YH(, a
  func)HY(tion)YH( call, an eval context, or a literal list as in the above frag)HY(ment)YH(.
  Here is a some)HY(what)YH( more real)HY(is)HY(tic)YH( example that splits a space-sepa)HY(rated)YH(
  envi)HY(ron)HY(ment)YH( vari)HY(able)YH( value into names and then gener)HY(ates)YH( a depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH( for each of them:)EP(

  ) 4 45 PR(for n: $regex.split\201$getenv\201NAMES\202, ' +', ''\202
{
  exe{$n}: cxx{$n}
})RP(

  )0 P(Note also that there is no notion of vari)HY(able)YH( local)HY(ity)YH( in
  )SM(for)ES( blocks and any value set inside is visible outside. At the
  end of the iter)HY(a)HY(tion)YH( the loop vari)HY(able)YH( contains the value of the last
  element, if any. For example:)EP(

  ) 7 22 PR(for x: x X
{
  y = Y
}

info $x  # Prints 'X'.
info $y  # Prints 'Y'.)RP(

  )0 2 17 H(1.9)WB 53 Sn()WB 19 Sn( Imple)HY(ment)HY(ing)YH( Unit Testing)EH(

  )0 P(As an example of how many of these features fit together to imple)HY(ment)YH(
  more advanced func)HY(tion)HY(al)HY(ity)YH(, let's examine a )SM(build)HY(file)YH()ES( that
  provides support for unit testing. This support is added by the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command if we specify the )SM(unit-tests)ES( option when creat)HY(ing)YH(
  executable \201)SM(-t\240exe,unit-tests)ES(\202 or library
  \201)SM(-t\240lib,unit-tests)ES(\202 projects. Here is the source
  subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES( of an executable created with this
  option:)EP(

  ) 20 55 PR(./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...}

# Unit tests.
#
exe{*.test}
{
  test = true
  install = false
}

for t: cxx{**.test...}
{
  d = $directory\201$t\202
  n = $name\201$t\202...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
}

cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )0 P(The basic idea behind this unit testing arrange)HY(ment)YH( is to keep unit tests
  next to the source code files that they test and auto)HY(mat)HY(i)HY(cally)YH( recog)HY(nize)YH( and
  build them into test executa)HY(bles)YH( without having to manu)HY(ally)YH( list each in the
  )SM(build)HY(file)YH()ES(. Specif)HY(i)HY(cally)YH(, if we have )SM(hello.hxx)ES( and
  )SM(hello.cxx)ES(, then to add a unit test for this module all we have
  to do is drop the )SM(hello.test.cxx)ES( source file next to them and
  it will be auto)HY(mat)HY(i)HY(cally)YH( picked up, built into an executable, and run during
  the )SM(test)ES( oper)HY(a)HY(tion)YH(.)EP(

  )0 P(As an example, let's say we've renamed )SM(hello.cxx)ES( to
  )SM(main.cxx)ES( and factored the print)HY(ing)YH( code into the
  )SM(hello.hxx/hello.cxx)ES( module that we would like to unit-test.
  Here is the new layout:)EP(

  ) 10 22 PR(hello/
|-- build
|   `-- ...
|-- hello
|   |-- hello.cxx
|   |-- hello.hxx
|   |-- hello.test.cxx
|   |-- main.cxx
|   `-- buildfile
`-- ...)RP(

  )0 P(Let's examine how this support is imple)HY(mented)YH( in our
  )SM(build)HY(ifle)YH()ES(, line by line. Because now we link
  )SM(hello.cxx)ES( object code into multi)HY(ple)YH( executa)HY(bles)YH( \201unit tests and
  the )SM(hello)ES( program itself\202, we have to place it into a
  )I(utility library)ES(. This is what the first line does \201it has to
  explic)HY(itly)YH( list )SM(exe{hello})ES( as a prereq)HY(ui)HY(site)YH( of the default
  targets since we now have multi)HY(ple)YH( targets that should be built by
  default\202:)EP(

  ) 1 55 PR(./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...})RP(

  )0 P(A utility library \201)SM()BD(u)ES()ES( in )SM(lib)BD(u)ES(e)ES(\202 is
  a static library that is built for a specific type of a )I(primary
  target)ES( \201)SM()BD(e)ES()ES( in )SM(libu)BD(e)ES()ES( for
  executable\202. If we were build)HY(ing)YH( a utility library for a library then we
  would have used the )SM(libul{})ES( target type instead. In fact, this
  would be the only differ)HY(ence)YH( in the above unit testing imple)HY(men)HY(ta)HY(tion)YH( if it
  were for a library project instead of an executable:)EP(

  ) 14 55 PR(./: lib{hello}: libul{hello}: {hxx cxx}{** -**.test...}

...

# Unit tests.
#
...

for t: cxx{**.test...}
{
  ...

  $d/exe{$n}: libul{hello}: bin.whole = false
})RP(

  )0 P(Going back to the first three lines of the executable
  )SM(build)HY(file)YH()ES(, notice that we had to exclude source files in the
  )SM(*.test.cxx)ES( form from the utility library. This makes sense
  since we don't want unit testing code \201each with its own
  )SM(main\201\202)ES(\202 to end up in the utility library.)EP(

  )0 P(The exclu)HY(sion)YH( pattern, )SM(-**.test...)ES(, looks a bit cryptic.
  What we have here is a second-level exten)HY(sion)YH( \201)SM(.test)ES(\202 which we
  use to clas)HY(sify)YH( our source files as belong)HY(ing)YH( to unit tests. Because it is a
  second-level exten)HY(sion)YH(, we have to indi)HY(cate)YH( this fact to the pattern
  match)HY(ing)YH( machin)HY(ery)YH( with the trail)HY(ing)YH( triple dot \201meaning "there are more
  exten)HY(sions)YH( coming"\202. If we didn't do that, )SM(.test)ES( would have
  been treated as a first-level exten)HY(sion)YH( explic)HY(itly)YH( spec)HY(i)HY(fied)YH( for our source
  files.)EP(

  )BR(
  )0 P(If you need to specify a name that does not have an exten)HY(sion)YH(, then end
  it with a single dot. For example, for a header )SM(utility)ES( you
  would write )SM(hxx{utility.})ES(. If you need to specify a name with
  an actual trail)HY(ing)YH( dot, then escape it with a double dot, for example,
  )SM(hxx{utility..})ES(.)EP(
  )BR(

  )0 P(The next couple of lines set target type/pattern-specific vari)HY(ables)YH( to
  treat all unit test executa)HY(bles)YH( as tests that should not be installed:)EP(

  ) 5 17 PR(exe{*.test}:
{
  test = true
  install = false
})RP(

  )BR(
  )0 P(You may be wonder)HY(ing)YH( why we had to escape the second-level
  )SM(.test)ES( exten)HY(sion)YH( in the name pattern above but not here. The
  answer is that these are differ)HY(ent)YH( kinds of patterns in differ)HY(ent)YH( contexts.
  In partic)HY(u)HY(lar)YH(, patterns in the target type/pattern-specific vari)HY(ables)YH( are
  only matched against target names without regard for exten)HY(sions)YH(. See )0 21 1 A(Name Patterns)21 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 P(Then we have the )SM(for)ES(-loop that declares an executable target
  for each unit test source file. The list of these files is gener)HY(ated)YH( with a
  name pattern that is the inverse of what we've used for the utility
  library:)EP(

  ) 8 51 PR(for t: cxx{**.test...}
{
  d = $directory\201$t\202
  n = $name\201$t\202...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
})RP(

  )0 P(In the loop body we first split the test source file into the direc)HY(tory)YH(
  \201remem)HY(ber)YH(, we can have sources, includ)HY(ing)YH( tests, in subdi)HY(rec)HY(to)HY(ries)YH(\202 and name
  \201which contains the )SM(.test)ES( second-level exten)HY(sion)YH( and which we
  imme)HY(di)HY(ately)YH( escape with )SM(...)ES(\202. And then we use these compo)HY(nents)YH(
  to declare a depen)HY(dency)YH( for the corre)HY(spond)HY(ing)YH( unit test executable. There is
  nothing here that we haven't already seen except for using vari)HY(able)YH(
  expan)HY(sions)YH( instead of literal names.)EP(

  )0 P(By default utility libraries are linked in the "whole archive" mode where
  every object file from the static library ends up in the result)HY(ing)YH(
  executable or library. This behav)HY(ior)YH( is what we want when linking the
  primary target but can normally be relaxed for unit tests to speed up
  linking. This is what the last line in the loop does using the
  )SM(bin.whole)ES( prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH(.)EP(

  )BR(
  )0 P(You can easily customize this and other aspects on a test-by-test basis
  by exclud)HY(ing)YH( the specific test\201s\202 from the loop and then provid)HY(ing)YH( a custom
  imple)HY(men)HY(ta)HY(tion)YH(. For example:)EP(

  ) 6 59 PR(for t: cxx{**.test... -special.test...}
{
  ...
}

./: exe{special.test...}: cxx{special.test...} libue{hello})RP(

  )0 P(Note also that if you plan to link any of your unit tests in the whole
  archive mode, then you will also need to exclude the source file contain)HY(ing)YH(
  the primary executable's )SM(main\201\202)ES( from the utility library. For
  example:)EP(

  ) 2 45 PR(./: exe{hello}: cxx{main} libue{hello}
libue{hello}: {hxx cxx}{** -main -**.test...})RP(
  )BR(

  )0 2 18 H(1.10)WB 54 Sn()WB 20 Sn( Diag)HY(nos)HY(tics)YH( and Debug)HY(ging)YH()EH(

  )0 P(Sooner or later we will run into a situ)HY(a)HY(tion)YH( where our
  )SM(build)HY(files)YH()ES( don't do what we expect them to. In this section we
  examine a number of tech)HY(niques)YH( and mech)HY(a)HY(nisms)YH( that can help us under)HY(stand)YH(
  the cause of a misbe)HY(hav)HY(ing)YH( build.)EP(

  )0 P(To perform a build the build system goes through several phases. During
  the )I(load)ES( phase the )SM(build)HY(files)YH()ES( are loaded and processed.
  The result of this phase is the in-memory )I(build state)ES( that contains
  the scopes, targets, vari)HY(ables)YH(, etc., defined by the
  )SM(build)HY(files)YH()ES(. Next, is the )I(match)ES( phase during which rules
  are matched to the targets that need to be built, recur)HY(sively)YH(. Finally,
  during the )I(execute)ES( phase the matched rules are executed to perform
  the build.)EP(

  )0 P(The load phase is always serial and stops at the first error. In
  contrast, by default, both match and execute are paral)HY(lel)YH( and continue in
  the pres)HY(ence)YH( of errors \201similar to the "keep going" )SM(make)ES( mode\202.
  While bene)HY(fi)HY(cial)YH( in normal circum)HY(stances)YH(, during debug)HY(ging)YH( this can lead to
  both inter)HY(leaved)YH( output that is hard to corre)HY(late)YH( as well as extra noise
  from cascad)HY(ing)YH( errors. As a result, for debug)HY(ging)YH(, it is usually helpful to
  run seri)HY(ally)YH( and stop at the first error, which can be achieved with the
  )SM(--serial-stop|-s)ES( option.)EP(

  )BR(
  )0 P(The match phase can be temporar)HY(ily)YH( switched to either \201serial\202 load or
  \201paral)HY(lel)YH(\202 execute. The former is used, for example, to load addi)HY(tional)YH(
  )SM(build)HY(files)YH()ES( during the )SM(dir{})ES( prereq)HY(ui)HY(site)YH( to target
  reso)HY(lu)HY(tion)YH(, as described in )0 6 1 A(Output Direc)HY(to)HY(ries)YH(
  and Scopes)6 0 TN TL()Ec /AF f D(. While the latter is used to update gener)HY(ated)YH( source code
  \201such as headers\202 that is required to complete the match.)EP(
  )BR(

  )0 P(Debug)HY(ging)YH( issues in each phase requires differ)HY(ent)YH( tech)HY(niques)YH(. Let's start
  with the load phase. As mentioned in )0 15 1 A(Build
  Language)15 0 TN TL()Ec /AF f D(, )SM(build)HY(files)YH()ES( are processed linearly with direc)HY(tives)YH(
  executed and vari)HY(ables)YH( expanded as they are encoun)HY(tered)YH(. As we have already
  seen, to print a vari)HY(able)YH( value we can use the )SM(info)ES( direc)HY(tive)YH(.
  For example:)EP(

  ) 2 7 PR(x = X
info $x)RP(

  )0 P(This will print some)HY(thing)YH( along these lines:)EP(

  ) 1 22 PR(buildfile:2:1: info: X)RP(

  )0 P(Or, if we want to clearly see where the value begins and ends \201useful
  when inves)HY(ti)HY(gat)HY(ing)YH( whites)HY(pace)YH(-related issues\202:)EP(

  ) 2 11 PR(x = " X "
info "'$x'")RP(

  )0 P(Which prints:)EP(

  ) 1 26 PR(buildfile:2:1: info: ' X ')RP(

  )0 P(Besides the )SM(info)ES( direc)HY(tive)YH(, there are also
  )SM(text)ES(, which doesn't print the )SM(info:)ES( prefix,
  )SM(warn)ES(, which prints a warning, as well as )SM(fail)ES(
  which prints an error and causes the build system to exit with an error.
  Here is an example of using each:)EP(

  ) 4 41 PR(text 'note: we are about to get an error'
warn 'the error is imminent'
fail 'this is the end'
info 'we will never get here')RP(

  )0 P(This will produce the follow)HY(ing)YH( output:)EP(

  ) 3 49 PR(buildfile:1:1: note: we are about to get an error
buildfile:2:1: warning: the error is imminent
buildfile:3:1: error: this is the end)RP(

  )0 P(If you find your)HY(self)YH( writing code like this:)EP(

  ) 2 35 PR(if \201$cxx.target.class == 'windows'\202
  fail 'Windows is not supported')RP(

  )0 P(Then the )SM(assert)ES( direc)HY(tive)YH( is a more concise way to express
  the same:)EP(

  ) 1 66 PR(assert \201$cxx.target.class != 'windows'\202 'Windows is not supported')RP(

  )0 P(The assert condi)HY(tion)YH( must be some)HY(thing)YH( that eval)HY(u)HY(ates)YH( to
  )SM(true)ES( or )SM(false)ES(, similar to the )SM(if)ES(
  direc)HY(tive)YH( \201see )0 17 1 A(Condi)HY(tions)YH(
  \201)SM(if-else)ES(\202)17 0 TN TL()Ec /AF f D( for details\202. The descrip)HY(tion)YH( after the condi)HY(tion)YH(
  is optional and, similar to )SM(if)ES(, there is also the
  )SM(assert!)ES( variant, which fails if the condi)HY(tion)YH( is
  )SM(true)ES(.)EP(

  )0 P(All the diag)HY(nos)HY(tics)YH( direc)HY(tives)YH( write to )SM(stderr)ES(. If instead
  we need to write some)HY(thing)YH( to )SM(stdout)ES(, for example, to send some
  infor)HY(ma)HY(tion)YH( back to our caller, then we can use the )SM(print)ES(
  direc)HY(tive)YH(. For example, this will print the C++ compiler id and its
  target:)EP(

  ) 1 27 PR(print "$cxx.id $cxx.target")RP(

  )BR(
  )0 P(To query the value of a target-specific vari)HY(able)YH( we use the qual)HY(i)HY(fied)YH(
  name syntax \201the )SM(eval-qual)ES( produc)HY(tion)YH(\202 of eval context, for
  example:)EP(

  ) 2 33 PR(obj{main}: cxx.poptions += -DMAIN
info $\201obj{main}: cxx.poptions\202)RP(

  )0 P(There is no direct way to query the value of a prereq)HY(ui)HY(site)YH(-specific
  vari)HY(able)YH( since a prereq)HY(ui)HY(site)YH( has no iden)HY(tity)YH(. Instead, we can use the
  )SM(dump)ES( direc)HY(tive)YH( discussed next to print the entire depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH(, includ)HY(ing)YH( prereq)HY(ui)HY(site)YH(-specific vari)HY(ables)YH( for each
  prereq)HY(ui)HY(site)YH(.)EP(
  )BR(

  )0 P(While print)HY(ing)YH( vari)HY(ables)YH( values is the most common mech)HY(a)HY(nism)YH( for
  diag)HY(nos)HY(ing)YH( )SM(build)HY(file)YH()ES( issues, some)HY(times)YH( it is also helpful to
  examine targets and scopes. For that we use the )SM(dump)ES(
  direc)HY(tive)YH(.)EP(

  )0 P(Without any argu)HY(ments)YH(, )SM(dump)ES( prints \201to )SM(stderr)ES(\202
  the contents of the scope it was encoun)HY(tered)YH( in and at that point of
  process)HY(ing)YH( the )SM(build)HY(file)YH()ES(. Its output includes vari)HY(ables)YH(,
  targets and their prerequsites, as well as nested scopes, recur)HY(sively)YH(. As an
  example, let's print the source direc)HY(tory)YH( scope of our )SM(hello)ES(
  executable project. Here is its )SM(build)HY(file)YH()ES( with the
  )SM(dump)ES( direc)HY(tive)YH( at the end:)EP(

  ) 5 43 PR(exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root"

dump)RP(

  )0 P(This will produce the output along these lines:)EP(

  ) 11 54 PR(buildfile:5:1: dump:
  /tmp/hello/hello/
  {
    [strings] cxx.poptions = -I/tmp/hello -I/tmp/hello
    [dir_path] out_base = /tmp/hello/hello/
    [dir_path] src_base = /tmp/hello/hello/

    build{buildfile.}:

    exe{hello.?}: cxx{hello.?}
  })RP(

  )BR(
  )0 P(The ques)HY(tion)YH( marks \201)SM(?)ES(\202 in the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( mean
  that the file exten)HY(sions)YH( haven't been assigned yet, which happens during the
  match phase.)EP(
  )BR(

  )0 P(Instead of print)HY(ing)YH( the entire scope, we can also print indi)HY(vid)HY(ual)YH(
  targets by spec)HY(i)HY(fy)HY(ing)YH( one or more target names in )SM(dump)ES(. To make
  things more inter)HY(est)HY(ing)YH(, let's convert our )SM(hello)ES( project to use
  a utility library, similar to the unit testing setup \201)0 19 1 A(Imple)HY(ment)HY(ing)YH( Unit Testing)19 0 TN TL()Ec /AF f D(\202. We will also link to
  the )SM(pthread)ES( library to see an example of a target-specific
  vari)HY(able)YH( being dumped:)EP(

  ) 5 43 PR(exe{hello}: libue{hello}: bin.whole = false
exe{hello}: cxx.libs += -lpthread
libue{hello}: {hxx cxx}{**}

dump exe{hello})RP(

  )0 P(The output will look along these lines:)EP(

  ) 9 66 PR(buildfile:5:1: dump:
  /tmp/hello/hello/exe{hello.?}:
  {
    [strings] cxx.libs = -lpthread
  }
  /tmp/hello/hello/exe{hello.?}: /tmp/hello/hello/:libue{hello.?}:
  {
    [bool] bin.whole = false
  })RP(

  )0 P(The output of )SM(dump)ES( might look famil)HY(iar)YH(: in )0 6 1 A(Output Direc)HY(to)HY(ries)YH( and Scopes)6 0 TN TL()Ec /AF f D( we've used the
  )SM(--dump)ES( option to print the entire build state, which looks
  pretty similar. In fact, the )SM(dump)ES( direc)HY(tive)YH( uses the same
  mech)HY(a)HY(nism)YH( but allows us to print indi)HY(vid)HY(ual)YH( scopes and targets.)EP(

  )0 P(There is, however, an impor)HY(tant)YH( differ)HY(ence)YH( to keep in mind:
  )SM(dump)ES( prints the state of a target or scope at the point in the
  )SM(build)HY(file)YH()ES( load phase where it was executed. In contrast, the
  )SM(--dump)ES( option can be used to print the state after the load
  phase \201)SM(--dump load)ES(\202 and/or after the match phase \201)SM(--dump
  match)ES(\202. In partic)HY(u)HY(lar)YH(, the after match print)HY(out)YH( reflects the changes
  to the build state made by the match)HY(ing)YH( rules, which may include enter)HY(ing)YH( of
  addi)HY(tional)YH( depen)HY(den)HY(cies)YH(, setting of addi)HY(tional)YH( vari)HY(ables)YH(, reso)HY(lu)HY(tion)YH( of
  prerequsites to targets, assign)HY(ment)YH( of file exten)HY(sions)YH(, etc. As a result,
  while the )SM(dump)ES( direc)HY(tive)YH( should be suffi)HY(cient)YH( in most cases,
  some)HY(times)YH( you may need to use the )SM(--dump)ES( option to examine the
  build state just before rule execu)HY(tion)YH(.)EP(

  )0 P(Let's now move from state to behav)HY(ior)YH(. As we already know, to see the
  under)HY(ly)HY(ing)YH( commands executed by the build system we use the )SM(-v)ES(
  options \201which is equiv)HY(a)HY(lent)YH( to )SM(--verbose\2402)ES(\202. Note,
  however, that these are )I(logical)ES( rather than actual commands. You can
  still run them and they should produce the desired result, but in reality
  the build system may have achieved the same result in a differ)HY(ent)YH( way. To
  see the actual commands we use the )SM(-V)ES( option instead
  \201equiv)HY(a)HY(lent)YH( to )SM(--verbose\2403)ES(\202. Let's see the differ)HY(ence)YH( in
  an example. Here is what build)HY(ing)YH( our )SM(hello)ES( executable with
  )SM(-v)ES( might look like:)EP(

  ) 3 27 PR($ b -s -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o)RP(

  )0 P(And here is the same build with )SM(-V)ES(:)EP(

  ) 5 66 PR($ b -s -V
g++ -MD -E -fdirectives-only -MF hello.o.t -o hello.o.ii hello.cxx
g++ -E -fpreprocessed -fdirectives-only hello.o.ii
g++ -o hello.o -c -fdirectives-only hello.o.ii
g++ -o hello hello.o)RP(

  )0 P(From the second listing we can see that in reality )SM(build2)ES(
  first partially prepro)HY(cessed)YH( )SM(hello.cxx)ES( while extract)HY(ing)YH( its
  header depen)HY(dency)YH( infor)HY(ma)HY(tion)YH(. It then prepro)HY(cessed)YH( it fully, which is used
  to extract module depen)HY(dency)YH( infor)HY(ma)HY(tion)YH(, calcu)HY(late)YH( the check)HY(sum)YH( for
  ignor)HY(able)YH( change detec)HY(tion)YH(, etc.  When it comes to produc)HY(ing)YH(
  )SM(hello.o)ES(, the build system compiled the partially prepro)HY(cessed)YH(
  output rather than the orig)HY(i)HY(nal)YH( )SM(hello.cxx)ES(. The end result,
  however, is the same as in the first listing.)EP(

  )0 P(Verbosity level )SM(3)ES( \201)SM(-V)ES(\202 also trig)HY(gers)YH( print)HY(ing)YH(
  of the build system module config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH(. Here is what we would
  see for the )SM(cxx)ES( module:)EP(

  ) 15 67 PR(cxx hello@/tmp/hello/
  cxx        g++@/usr/bin/g++
  id         gcc
  version    7.2.0 \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  major      7
  minor      2
  patch      0
  build      \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  signature  gcc version 7.2.0 \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  checksum   09b3b59d337eb9a760dd028fa0df585b307e6a49c2bfa00b3[...]
  target     x86_64-linux-gnu
  runtime    libgcc
  stdlib     libstdc++
  c stdlib   glibc
...)RP(

  )0 P(Verbosity levels higher than )SM(3)ES( enable build system tracing.
  In partic)HY(u)HY(lar)YH(, level )SM(4)ES( is useful for under)HY(stand)HY(ing)YH( why a rule
  doesn't match a target or if it does, why it deter)HY(mined)YH( the target to be out
  of date. For example, assum)HY(ing)YH( we have an up-to-date build of our
  )SM(hello)ES(, let's change a compile option:)EP(

  ) 7 64 PR($ b -s --verbose 4
info: /tmp/hello/dir{hello/} is up to date

$ b -s --verbose 4 config.cxx.poptions+=-DNDEBUG
trace: cxx::compile_rule::apply: options mismatch forcing update
of /tmp/hello/hello/obje{hello.o}
...)RP(

  )0 P(Higher verbosity levels result in more and more tracing state)HY(ments)YH( being
  printed. These include )SM(build)HY(file)YH()ES( loading and parsing,
  prereq)HY(ui)HY(site)YH( to target reso)HY(lu)HY(tion)YH(, as well as build system module and
  rule-specific logic.)EP(

  )0 P(Another useful diag)HY(nos)HY(tics)YH( option is )SM(--mtime-check)ES(. When
  spec)HY(i)HY(fied)YH(, the build system performs a number of file modi)HY(fi)HY(ca)HY(tion)YH( time
  sanity checks that can be helpful in diag)HY(nos)HY(ing)YH( spuri)HY(ous)YH( rebuilds.)EP(

  )0 P(If neither state dumps nor behav)HY(ior)YH( anal)HY(y)HY(sis)YH( are suffi)HY(cient)YH( to under)HY(stand)YH(
  the problem, there is always an option of running the build system under a
  C++ debug)HY(ger)YH( in order to better under)HY(stand)YH( what's going on. This can be
  partic)HY(u)HY(larly)YH( produc)HY(tive)YH( for debug)HY(ging)YH( complex rules.)EP(

  )0 P(Finally, to help with diag)HY(nos)HY(ing)YH( the build system perfor)HY(mance)YH( issues,
  there is the )SM(--stat)ES( option. It causes )SM(build2)ES( to
  print various execu)HY(tion)YH( statis)HY(tics)YH( which can be useful for pin-point)HY(ing)YH( the
  bottle)HY(necks)YH(. There are also a number of options for tuning the build
  system's perfor)HY(mance)YH(, such as, the number of jobs to perform in paral)HY(lel)YH(,
  the stack size, queue depths, etc. See the )0 2 A()SM()BD(b\2011\202)ES()ES()EA( man pages for details.)EP(

  )0 1 19 H(2)WB 55 Sn()WB 21 Sn( Name Patterns)EH(

  )0 P(For conve)HY(nience)YH(, in certain contexts, names can be gener)HY(ated)YH( with
  shell-like wild)HY(card)YH( patterns. A name is a )I(name pattern)ES( if its value
  contains one or more unquoted wild)HY(card)YH( char)HY(ac)HY(ters)YH( or char)HY(ac)HY(ter)YH( sequences.
  For example:)EP(

  ) 3 59 PR(./: */                     # All \201immediate\202 subdirectories
exe{hello}: {hxx cxx}{**}  # All C++ header/source files.
pattern = '*.txt'          # Literal '*.txt'.)RP(

  )0 P(Pattern-based name gener)HY(a)HY(tion)YH( is not performed in certain contexts.
  Specif)HY(i)HY(cally)YH(, it is not performed in target names where it is inter)HY(preted)YH( as
  a pattern for target type/pattern-specific vari)HY(able)YH( assign)HY(ments)YH(. For
  example.)EP(

  ) 3 56 PR(s = *.txt             # Variable assignment \201performed\202.
./: cxx{*}            # Prerequisite names \201performed\202.
cxx{*}: dist = false  # Target pattern \201not performed\202.)RP(

  )0 P(In contexts where it is performed, it can be inhib)HY(ited)YH( with quoting, for
  example:)EP(

  ) 2 18 PR(pat = 'foo*bar'
./: cxx{'foo*bar'})RP(

  )0 P(The follow)HY(ing)YH( char)HY(ac)HY(ters)YH( are wild)HY(cards)YH(:)EP(

  ) 2 52 PR(*  - match any number of characters \201including zero\202
?  - match any single character)RP(

  )0 P(If a pattern ends with a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(, then it only matches
  direc)HY(to)HY(ries)YH(. Other)HY(wise)YH(, it only matches files. Matches that start with a dot
  \201)SM(.)ES(\202 are auto)HY(mat)HY(i)HY(cally)YH( ignored unless the pattern itself also
  starts with this char)HY(ac)HY(ter)YH(.)EP(

  )0 P(In addi)HY(tion)YH( to the above wild)HY(card)YH( char)HY(ac)HY(ters)YH(, )SM(**)ES( and
  )SM(***)ES( are recog)HY(nized)YH( as wild)HY(card)YH( char)HY(ac)HY(ter)YH( sequences. If a
  pattern contains )SM(**)ES(, then it is matched just like
  )SM(*)ES( but in all the subdi)HY(rec)HY(to)HY(ries)YH(, recur)HY(sively)YH(, but exclud)HY(ing)YH(
  direc)HY(to)HY(ries)YH( that contain the )SM(.buildig)HY(nore)YH()ES( file. The
  )SM(***)ES( wild)HY(card)YH( behaves like )SM(**)ES( but also matches the
  start direc)HY(tory)YH( itself. For example:)EP(

  ) 1 56 PR(exe{hello}: cxx{**}  # All C++ source files recursively.)RP(

  )0 P(A group-enclosed \201)SM({})ES(\202 pattern value may be followed by
  inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches. A subse)HY(quent)YH( value is treated as an
  inclu)HY(sion)YH( or exclu)HY(sion)YH( if it starts with a literal, unquoted plus
  \201)SM(+)ES(\202 or minus \201)SM(-)ES(\202 sign, respec)HY(tively)YH(. In this case
  the remain)HY(ing)YH( group values, if any, must all be inclu)HY(sions)YH( or exclu)HY(sions)YH(. If
  the second value doesn't start with a plus or minus, then all the group
  values are consid)HY(ered)YH( inde)HY(pen)HY(dent)YH( with leading pluses and minuses not having
  any special meaning. For regu)HY(lar)HY(ity)YH( as well as to allow patterns without
  wild)HY(cards)YH(, the first pattern can also start with the plus sign. For
  example:)EP(

  ) 7 68 PR(exe{hello}: cxx{f* -foo}            # Exclude foo if exists.
exe{hello}: cxx{f* +bar}            # Include bar if exists.
exe{hello}: cxx{f* -fo?}            # Exclude foo and fox if exist.
exe{hello}: cxx{f* +b* -foo -bar}   # Exclude foo and bar if exist.
exe{hello}: cxx{+f* +b* -foo -bar}  # Same as above.
exe{hello}: cxx{+foo}               # Pattern without wildcards.
exe{hello}: cxx{f* b* -z*}          # Names matching three patterns.)RP(

  )0 P(Inclu)HY(sions)YH( and exclu)HY(sions)YH( are applied in the order spec)HY(i)HY(fied)YH( and only to
  the result produced up to that point. The order of names in the result is
  unspec)HY(i)HY(fied)YH(. However, it is guar)HY(an)HY(teed)YH( not to contain dupli)HY(cates)YH(. The first
  pattern and the follow)HY(ing)YH( inclu)HY(sions)YH(/exclu)HY(sions)YH( must be consis)HY(tent)YH( with
  regards to the type of filesys)HY(tem)YH( entry they match. That is, they should all
  match either files or direc)HY(to)HY(ries)YH(. For example:)EP(

  ) 3 66 PR(exe{hello}: cxx{f* -foo +*oo}  # Exclusion has no effect.
exe{hello}: cxx{f* +*oo}       # Ok, no duplicates.
./: {*/ -build}                # Error: exclusion not a directory.)RP(

  )0 P(As a more real)HY(is)HY(tic)YH( example, let's say we want to exclude source files
  that reside in the )SM(test/)ES( direc)HY(to)HY(ries)YH( \201and their subdi)HY(rec)HY(to)HY(ries)YH(\202
  anywhere in the tree. This can be achieved with the follow)HY(ing)YH( pattern:)EP(

  ) 1 32 PR(exe{hello}: cxx{** -***/test/**})RP(

  )0 P(Simi)HY(larly)YH(, if we wanted to exclude all source files that have the
  )SM(-test)ES( suffix:)EP(

  ) 1 28 PR(exe{hello}: cxx{** -**-test})RP(

  )0 P(In contrast, the follow)HY(ing)YH( pattern only excludes such files from the top
  direc)HY(tory)YH(:)EP(

  ) 1 27 PR(exe{hello}: cxx{** -*-test})RP(

  )0 P(If many inclu)HY(sions)YH( or exclu)HY(sions)YH( need to be spec)HY(i)HY(fied)YH(, then an
  inclu)HY(sion)YH(/exclu)HY(sion)YH( group can be used. For example:)EP(

  ) 2 36 PR(exe{hello}: cxx{f* -{foo bar}}
exe{hello}: cxx{+{f* b*} -{foo bar}})RP(

  )0 P(This is partic)HY(u)HY(larly)YH( useful if you would like to list the names to
  include or exclude in a vari)HY(able)YH(. For example, this is how we can exclude
  certain files from compi)HY(la)HY(tion)YH( but still include them as ordi)HY(nary)YH( file
  prereq)HY(ui)HY(sites)YH( \201so that they are still included into the distri)HY(bu)HY(tion)YH(\202:)EP(

  ) 2 44 PR(exc = foo.cxx bar.cxx
exe{hello}: cxx{+{f* b*} -{$exc}} file{$exc})RP(

  )0 P(If we want to specify our pattern in a vari)HY(able)YH(, then we have to use the
  explicit inclu)HY(sion)YH( syntax, for example:)EP(

  ) 10 39 PR(pat = 'f*'
exe{hello}: cxx{+$pat} # Pattern match.
exe{hello}: cxx{$pat}  # Literal 'f*'.

pat = '+f*'
exe{hello}: cxx{$pat}  # Literal '+f*'.

inc = 'f*'  'b*'
exc = 'f*o' 'b*r'
exe{hello}: cxx{+{$inc} -{$exc}})RP(

  )0 P(One common situ)HY(a)HY(tion)YH( that calls for exclu)HY(sions)YH( is auto-gener)HY(ated)YH( source
  code. Let's say we have auto-gener)HY(ated)YH( command line parser in
  )SM(options.hxx)ES( and )SM(options.cxx)ES(. Because of the
  in-tree builds, our name pattern may or may not find these files. Note,
  however, that we cannot just include them as non-pattern prereq)HY(ui)HY(sites)YH(. We
  also have to exclude them from the pattern match since other)HY(wise)YH( we may end
  up with dupli)HY(cate)YH( prereq)HY(ui)HY(sites)YH(. As a result, this is how we have to handle
  this case provided we want to continue using patterns to find other,
  non-gener)HY(ated)YH( source files:)EP(

  ) 1 52 PR(exe{hello}: {hxx cxx}{* -options} {hxx cxx}{options})RP(

  )0 P(If the name pattern includes an abso)HY(lute)YH( direc)HY(tory)YH(, then the pattern
  match is performed in that direc)HY(tory)YH( and the gener)HY(ated)YH( names include
  abso)HY(lute)YH( direc)HY(to)HY(ries)YH( as well. Other)HY(wise)YH(, the pattern match is performed in
  the )I(pattern base)ES( direc)HY(tory)YH(. In build)HY(files)YH( this is
  )SM(src_base)ES( while on the command line \235 the current working
  direc)HY(tory)YH(. In this case the gener)HY(ated)YH( names are rela)HY(tive)YH( to the base
  direc)HY(tory)YH(. For example, assum)HY(ing)YH( we have the )SM(foo.cxx)ES( and
  )SM(b/bar.cxx)ES( source files:)EP(

  ) 2 72 PR(exe{hello}: $src_base/cxx{**}  # $src_base/cxx{foo} $src_base/b/cxx{bar}
exe{hello}:           cxx{**}  #           cxx{foo}           b/cxx{bar})RP(

  )0 P(Pattern match)HY(ing)YH( as well as inclu)HY(sion)YH(/exclu)HY(sion)YH( logic is target
  type-specific. If the name pattern does not contain a type, then the
  )SM(dir{})ES( type is assumed if the pattern ends with a direc)HY(tory)YH(
  sepa)HY(ra)HY(tor)YH( and )SM(file{})ES( other)HY(wise)YH(.)EP(

  )0 P(For the )SM(dir{})ES( target type the trail)HY(ing)YH( direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(
  is added to the pattern and all the inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches
  that do not already end with one. Then the filesys)HY(tem)YH( search is performed
  for match)HY(ing)YH( direc)HY(to)HY(ries)YH(. For example:)EP(

  ) 1 51 PR(./: dir{* -build}  # Search for */, exclude build/.)RP(

  )0 P(For the )SM(file{})ES( and )SM(file{})ES(-based target types
  the default exten)HY(sion)YH( \201if any\202 is added to the pattern and all the
  inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches that do not already contain an
  exten)HY(sion)YH(. Then the filesys)HY(tem)YH( search is performed for match)HY(ing)YH( files.)EP(

  )0 P(For example, the )SM(cxx{})ES( target type obtains the default
  exten)HY(sion)YH( from the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH(. Assum)HY(ing)YH( we have the
  follow)HY(ing)YH( line in our )SM(root.build)ES(:)EP(

  ) 1 23 PR(cxx{*}: extension = cxx)RP(

  )0 P(And the follow)HY(ing)YH( in our )SM(build)HY(file)YH()ES(:)EP(

  ) 1 34 PR(exe{hello}: {cxx}{* -foo -bar.cxx})RP(

  )0 P(The pattern match will first search for all the files match)HY(ing)YH( the
  )SM(*.cxx)ES( pattern in )SM(src_base)ES( and then exclude
  )SM(foo.cxx)ES( and )SM(bar.cxx)ES( from the result. Note also
  that target type-specific deco)HY(ra)HY(tions)YH( are removed from the result. So in the
  above example if the pattern match produces )SM(baz.cxx)ES(, then the
  prereq)HY(ui)HY(site)YH( name is )SM(cxx{baz})ES(, not
  )SM(cxx{baz.cxx})ES(.)EP(

  )0 P(If the name gener)HY(a)HY(tion)YH( cannot be performed because the base direc)HY(tory)YH( is
  unknown, target type is unknown, or the target type is not direc)HY(tory)YH( or
  file-based, then the name pattern is returned as is \201that is, as an ordi)HY(nary)YH(
  name\202. Project-qual)HY(i)HY(fied)YH( names are never consid)HY(ered)YH( to be patterns.)EP(

  )0 1 20 H(3)WB 56 Sn()WB 22 Sn( Vari)HY(ables)YH()EH(

  )0 P(Note: this section is a work in progress.)EP(

  )0 P(Note that while expan)HY(sions)YH( in the target and prereq)HY(ui)HY(site)YH(-specific
  assign)HY(ments)YH( happen in the corre)HY(spond)HY(ing)YH( target and prereq)HY(ui)HY(site)YH( contexts,
  respec)HY(tively)YH(, for type/pattern-specific assign)HY(ments)YH( they happen in the scope
  context. Plus, a type/pattern-specific prepend/append is applied at the time
  of expan)HY(sion)YH( for the actual target. For example:)EP(

  ) 24 38 PR(x = s

file{foo}:              # target
{
  x += t    # s t
  y = $x y  # s t y
}

file{foo}: file{bar}    # prerequisite
{
  x += p    # x t p
  y = $x y  # x t p y
}

file{b*}:               # type/pattern
{
  x += w   # <append w>
  y = $x w # <assign s w>
}

x = S

info $\201file{bar}: x\202 # S w
info $\201file{bar}: y\202 # s w)RP(

  )0 1 21 H(4)WB 57 Sn()WB 23 Sn( )SM(test)ES( Module)EH(

  )0 P(The targets to be tested as well as the tests/groups from testscripts to
  be run can be narrowed down using the )SM(config.test)ES( vari)HY(able)YH(.
  While this value is normally spec)HY(i)HY(fied)YH( as a command line over)HY(ride)YH( \201for
  example, to quickly re-run a previ)HY(ously)YH( failed test\202, it can also be
  persisted in )SM(config.build)ES( in order to create a config)HY(u)HY(ra)HY(tion)YH(
  that will only run a subset of tests by default. For example:)EP(

  ) 2 70 PR(b test config.test=foo/exe{driver} # Only test foo/exe{driver} target.
b test config.test=bar/baz         # Only run bar/baz testscript test.)RP(

  )0 P(The )SM(config.test)ES( vari)HY(able)YH( contains a list of
  )SM(@)ES(-sepa)HY(rated)YH( pairs with the left hand side being the target and
  the right hand side being the testscript id path. Either can be omitted
  \201along with )SM(@)ES(\202. If the value contains a target type or ends
  with a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(, then it is treated as a target name. Other)HY(wise)YH(
  \235 an id path. The targets are resolved rela)HY(tive)YH( to the root scope
  where the )SM(config.test)ES( value is set. For example:)EP(

  ) 1 38 PR(b test config.test=foo/exe{driver}@bar)RP(

  )0 P(To specify multi)HY(ple)YH( id paths for the same target we can use the pair
  gener)HY(a)HY(tion)YH( syntax:)EP(

  ) 1 44 PR(b test config.test=foo/exe{driver}@{bar baz})RP(

  )0 P(If no targets are spec)HY(i)HY(fied)YH( \201only id paths\202, then all the targets are
  tested \201with the testscript tests to be run limited to the spec)HY(i)HY(fied)YH( id
  paths\202. If no id paths are spec)HY(i)HY(fied)YH( \201only targets\202, then all the testscript
  tests are run \201with the targets to be tested limited to the spec)HY(i)HY(fied)YH(
  targets\202. An id path without a target applies to all the targets being
  consid)HY(ered)YH(.)EP(

  )0 P(A direc)HY(tory)YH( target without an explicit target type \201for example,
  )SM(foo/)ES(\202 is treated specially. It enables all the tests at and
  under its direc)HY(tory)YH(. This special treat)HY(ment)YH( can be inhib)HY(ited)YH( by spec)HY(i)HY(fy)HY(ing)YH(
  the target type explic)HY(itly)YH( \201for example, )SM(dir{foo/})ES(\202.)EP(

  )0 1 22 H(5)WB 58 Sn()WB 24 Sn( )SM(version)ES( Module)EH(

  )0 P(A project can use any version format as long as it meets the package
  version require)HY(ments)YH(. The toolchain also provides addi)HY(tional)YH( func)HY(tion)HY(al)HY(ity)YH(
  for manag)HY(ing)YH( projects that conform to the )SM(build2)ES( )I(stan)HY(dard)YH(
  version)ES( format. If you are start)HY(ing)YH( a new project that uses
  )SM(build2)ES(, you are strongly encour)HY(aged)YH( to use this version)HY(ing)YH(
  scheme. It is based on much thought and, often painful, expe)HY(ri)HY(ence)YH(. If you
  decide not to follow this advice, you are essen)HY(tially)YH( on your own when
  version manage)HY(ment)YH( is concerned.)EP(

  )0 P(The stan)HY(dard)YH( )SM(build2)ES( project version conforms to )R2 2 A(Seman)HY(tic)YH( Version)HY(ing)YH()EA( and has the follow)HY(ing)YH(
  form:)EP(

  ) 1 34 PR(<major>.<minor>.<patch>[-<prerel>])RP(

  )0 P(For example:)EP(

  ) 3 9 PR(1.2.3
1.2.3-a.1
1.2.3-b.2)RP(

  )0 P(The )SM(build2)ES( package version that uses the stan)HY(dard)YH( project
  version will then have the follow)HY(ing)YH( form \201)I(epoch)ES( is the version)HY(ing)YH(
  scheme version and )I(revi)HY(sion)YH()ES( is the package revi)HY(sion)YH(\202:)EP(

  ) 1 58 PR([+<epoch>-]<major>.<minor>.<patch>[-<prerel>][+<revision>])RP(

  )0 P(For example:)EP(

  ) 3 14 PR(1.2.3
1.2.3+1
+2-1.2.3-a.1+2)RP(

  )0 P(The )I(major)ES(, )I(minor)ES(, and )I(patch)ES( should be numeric values
  between )SM(0)ES( and )SM(99999)ES( and all three cannot be zero
  at the same time. For initial devel)HY(op)HY(ment)YH( it is recom)HY(mended)YH( to use
  )SM(0)ES( for )I(major)ES(, start with version )SM(0.1.0)ES(, and
  change to )SM(1.0.0)ES( once things stabi)HY(lize)YH(.)EP(

  )0 P(In the context of C and C++ \201or other compiled languages\202, you should
  incre)HY(ment)YH( )I(patch)ES( when making binary-compat)HY(i)HY(ble)YH( changes, )I(minor)ES(
  when making source-compat)HY(i)HY(ble)YH( changes, and )I(major)ES( when making break)HY(ing)YH(
  changes. While the binary compat)HY(i)HY(bil)HY(ity)YH( must be set in stone, the source
  compat)HY(i)HY(bil)HY(ity)YH( rules can some)HY(times)YH( be bent. For example, you may decide to
  make a break)HY(ing)YH( change in a rarely used inter)HY(face)YH( as part of a minor release
  \201though this is prob)HY(a)HY(bly)YH( still a bad idea if your library is widely depended
  upon\202. Note also that in the context of C++ decid)HY(ing)YH( whether a change is
  binary-compat)HY(i)HY(ble)YH( is a non-trivial task. There are resources that list the
  rules but no auto)HY(mated)YH( tooling yet. If unsure, incre)HY(ment)YH( )I(minor)ES(.)EP(

  )0 P(If present, the )I(prerel)ES( compo)HY(nent)YH( signi)HY(fies)YH( a pre-release. Two
  types of pre-releases are supported by the stan)HY(dard)YH( version)HY(ing)YH( scheme:
  )I(final)ES( and )I(snap)HY(shot)YH()ES( \201non-pre-release versions are natu)HY(rally)YH(
  always final\202. For final pre-releases the )I(prerel)ES( compo)HY(nent)YH( has the
  follow)HY(ing)YH( form:)EP(

  ) 1 11 PR(\201a|b\202.<num>)RP(

  )0 P(For example:)EP(

  ) 2 9 PR(1.2.3-a.1
1.2.3-b.2)RP(

  )0 P(The letter ')SM(a)ES(' signi)HY(fies)YH( an alpha release and
  ')SM(b)ES(' \235 beta. The alpha/beta numbers \201)I(num)ES(\202 should be
  between 1 and 499.)EP(

  )0 P(Note that there is no support for release candi)HY(dates)YH(. Instead, it is
  recom)HY(mended)YH( that you use later-stage beta releases for this purpose \201and, if
  you wish, call them "release candi)HY(dates)YH(" in announce)HY(ments)YH(, etc\202.)EP(

  )0 P(What version should be used during devel)HY(op)HY(ment)YH(? The common approach is to
  incre)HY(ment)YH( to the next version and use that until the release. This has one
  major draw)HY(back)YH(: if we publish inter)HY(me)HY(di)HY(ate)YH( snap)HY(shots)YH( \201for example, for
  testing\202 they will all be indis)HY(tin)HY(guish)HY(able)YH( both between each other and,
  even worse, from the final release. One way to remedy this is to incre)HY(ment)YH(
  the pre-release number before each publi)HY(ca)HY(tion)YH(. However, unless auto)HY(mated)YH(,
  this will be burden)HY(some)YH( and error-prone. Also, there is a real possi)HY(bil)HY(ity)YH(
  of running out of version numbers if, for example, we do contin)HY(u)HY(ous)YH(
  inte)HY(gra)HY(tion)YH( by publish)HY(ing)YH( and testing each commit.)EP(

  )0 P(To address this, the stan)HY(dard)YH( version)HY(ing)YH( scheme supports )I(snap)HY(shot)YH(
  pre-releases)ES( with the )I(prerel)ES( compo)HY(nent)YH( having the follow)HY(ing)YH(
  extended form:)EP(

  ) 1 31 PR(\201a|b\202.<num>.<snapsn>[.<snapid>])RP(

  )0 P(For example:)EP(

  ) 1 37 PR(1.2.3-a.1.20180319215815.26efe301f4a7)RP(

  )0 P(In essence, a snap)HY(shot)YH( pre-release is after the previ)HY(ous)YH( final release
  but before the next \201)SM(a.1)ES( and, perhaps, )SM(a.2)ES( in the
  above example\202 and is uniquely iden)HY(ti)HY(fied)YH( by the snap)HY(shot)YH( sequence number
  \201)I(snapsn)ES(\202 and optional snap)HY(shot)YH( id \201)I(snapid)ES(\202.)EP(

  )0 P(The )I(num)ES( compo)HY(nent)YH( has the same seman)HY(tics)YH( as in the final
  pre-releases except that it can be )SM(0)ES(. The )I(snapsn)ES(
  compo)HY(nent)YH( should be either the special value ')SM(z)ES(' or a numeric,
  non-zero value that increases for each subse)HY(quent)YH( snap)HY(shot)YH(. It must not be
  longer than 16 decimal digits. The )I(snapid)ES( compo)HY(nent)YH(, if present,
  should be an alpha-numeric value that uniquely iden)HY(ti)HY(fies)YH( the snap)HY(shot)YH(. It
  is not required for version compar)HY(i)HY(son)YH( \201)I(snapsn)ES( should be suffi)HY(cient)YH(\202
  and is included for refer)HY(ence)YH(. It must not be longer than 16 char)HY(ac)HY(ters)YH(.)EP(

  )0 P(Where do the snap)HY(shot)YH( number and id come from? Normally from the version
  control system. For example, for )SM(git)ES(, )I(snapsn)ES( is the
  commit date in the )I(YYYYM)HY(MD)HY(Dhh)HY(mmss)YH()ES( form and UTC time)HY(zone)YH( and
  )I(snapid)ES( is a 12-char)HY(ac)HY(ter)YH( abbre)HY(vi)HY(ated)YH( commit id. As discussed below,
  the )SM(build2)ES( )SM(version)ES( module extracts and manages all
  this infor)HY(ma)HY(tion)YH( auto)HY(mat)HY(i)HY(cally)YH( \201but the use of )SM(git)ES( commit dates
  is not without limi)HY(ta)HY(tions)YH(; see below for details\202.)EP(

  )0 P(The special ')SM(z)ES(' )I(snapsn)ES( value iden)HY(ti)HY(fies)YH( the
  )I(latest)ES( or )I(uncom)HY(mit)HY(ted)YH()ES( snap)HY(shot)YH(. It is chosen to be greater
  than any other possi)HY(ble)YH( )I(snapsn)ES( value and its use is discussed further
  below.)EP(

  )0 P(As an illus)HY(tra)HY(tion)YH( of this approach, let's examine how versions change
  during the life)HY(time)YH( of a project:)EP(

  ) 13 52 PR(0.1.0-a.0.z     # development after a.0
0.1.0-a.1       # pre-release
0.1.0-a.1.z     # development after a.1
0.1.0-a.2       # pre-release
0.1.0-a.2.z     # development after a.2
0.1.0-b.1       # pre-release
0.1.0-b.1.z     # development after b.1
0.1.0           # release
0.1.1-b.0.z     # development after b.0 \201bugfix\202
0.2.0-a.0.z     # development after a.0
0.1.1           # release \201bugfix\202
1.0.0           # release \201jumped straight to 1.0.0\202
...)RP(

  )0 P(As shown in the above example, there is nothing wrong with "jumping" to a
  further version \201for example, from alpha to beta, or from beta to release,
  or even from alpha to release\202. We cannot, however, jump back)HY(wards)YH( \201for
  example, from beta back to alpha\202. As a result, a sensi)HY(ble)YH( strat)HY(egy)YH( is to
  start with )SM(a.0)ES( since it can always be upgraded \201but not
  down)HY(grade)YH(\202 at a later stage.)EP(

  )0 P(When it comes to the version control systems, the recom)HY(mended)YH( work)HY(flow)YH( is
  as follows: The change to the final version should be the last commit in the
  \201pre-\202release. It is also a good idea to tag this commit with the project
  version. A commit imme)HY(di)HY(ately)YH( after that should change the version to a
  snap)HY(shot)YH(, "opening" the repos)HY(i)HY(tory)YH( for devel)HY(op)HY(ment)YH(.)EP(

  )0 P(The project version without the snap)HY(shot)YH( part can be repre)HY(sented)YH( as a
  64-bit decimal value compa)HY(ra)HY(ble)YH( as inte)HY(gers)YH( \201for example, in prepro)HY(ces)HY(sor)YH(
  direc)HY(tives)YH(\202. The integer repre)HY(sen)HY(ta)HY(tion)YH( has the follow)HY(ing)YH( form:)EP(

  ) 7 32 PR(AAAAABBBBBCCCCCDDDE

AAAAA - major
BBBBB - minor
CCCCC - patch
DDD   - alpha / beta \201DDD + 500\202
E     - final \2010\202 / snapshot \2011\202)RP(

  )0 P(If the )I(DDDE)ES( value is not zero, then it signi)HY(fies)YH( a pre-release. In
  this case one is subtracted from the )I(AAAAABBBB)HY(BC)HY(C)HY(CCC)YH()ES( value. An alpha
  number is stored in )I(DDD)ES( as is while beta \235 incre)HY(mented)YH( by
  )SM(500)ES(. If )I(E)ES( is )SM(1)ES(, then this is a snap)HY(shot)YH(
  after )I(DDD)ES(.)EP(

  )0 P(For example:)EP(

  ) 7 32 PR(             AAAAABBBBBCCCCCDDDE
0.1.0        0000000001000000000
0.1.2        0000000001000020000
1.2.3        0000100002000030000
2.2.0-a.1    0000200001999990010
3.0.0-b.2    0000299999999995020
2.2.0-a.1.z  0000200001999990011)RP(

  )0 P(A project that uses stan)HY(dard)YH( version)HY(ing)YH( can rely on the
  )SM(build2)ES( )SM(version)ES( module to simplify and auto)HY(mate)YH(
  version manage)HY(ments)YH(. The )SM(version)ES( module has two primary
  func)HY(tions)YH(: elim)HY(i)HY(nate)YH( the need to change the version anywhere except in the
  project's mani)HY(fest)YH( file and auto)HY(mat)HY(i)HY(cally)YH( extract and prop)HY(a)HY(gate)YH( the snap)HY(shot)YH(
  infor)HY(ma)HY(tion)YH( \201serial number and id\202.)EP(

  )0 P(The )SM(version)ES( module must be loaded in the project's
  )SM(boot)HY(strap)YH(.build)ES(. While being loaded, it reads the project's
  mani)HY(fest)YH( and extracts its version \201which must be in the stan)HY(dard)YH( form\202. The
  version is then parsed and presented as the follow)HY(ing)YH( build system vari)HY(ables)YH(
  \201which can be used in the build)HY(files)YH(\202:)EP(

  ) 27 70 PR([string] version                     # +2-1.2.3-b.4.1234567.deadbeef+3

[string] version.project             # 1.2.3-b.4.1234567.deadbeef
[uint64] version.project_number      # 0000100002000025041
[string] version.project_id          # 1.2.3-b.4.deadbeef

[bool]   version.stub                # false \201true for 0[+<revision>]\202

[uint64] version.epoch               # 2

[uint64] version.major               # 1
[uint64] version.minor               # 2
[uint64] version.patch               # 3

[bool]   version.alpha               # false
[bool]   version.beta                # true
[bool]   version.pre_release         # true
[string] version.pre_release_string  # b.4
[uint64] version.pre_release_number  # 4

[bool]   version.snapshot            # true
[uint64] version.snapshot_sn         # 1234567
[string] version.snapshot_id         # deadbeef
[string] version.snapshot_string     # 1234567.deadbeef
[bool]   version.snapshot_committed  # true

[uint64] version.revision            # 3)RP(

  )0 P(As a conve)HY(nience)YH(, the )SM(version)ES( module also extract the
  )SM(summary)ES( and )SM(url)ES( mani)HY(fest)YH( values and sets them as
  the follow)HY(ing)YH( build system vari)HY(ables)YH( \201this addi)HY(tional)YH( infor)HY(ma)HY(tion)YH( is used,
  for example, when gener)HY(at)HY(ing)YH( the )SM(pkg-config)ES( files\202:)EP(

  ) 2 24 PR([string] project.summary
[string] project.url)RP(

  )0 P(If the version is the latest snap)HY(shot)YH( \201that is, it's in the
  )SM(.z)ES( form\202, then the )SM(version)ES( module extracts the
  snap)HY(shot)YH( infor)HY(ma)HY(tion)YH( from the version control system used by the project.
  Currently only )SM(git)ES( is supported with the follow)HY(ing)YH(
  seman)HY(tics)YH(.)EP(

  )0 P(If the project's source direc)HY(tory)YH( \201)SM(src_root)ES(\202 is clean \201that
  is, it does not have any changed or untracked files\202, then the
  )SM(HEAD)ES( commit date and id are used as the snap)HY(shot)YH( number and id,
  respec)HY(tively)YH(.)EP(

  )0 P(Other)HY(wise)YH( \201that is, the project is between commits\202, the
  )SM(HEAD)ES( commit date is incre)HY(mented)YH( by one second and is used as
  the snap)HY(shot)YH( number with no id. While we can work with such uncom)HY(mit)HY(ted)YH(
  snap)HY(shots)YH( locally, we should not distribute or publish them since they are
  indis)HY(tin)HY(guish)HY(able)YH( from each other.)EP(

  )0 P(Finally, if the project does not have )SM(HEAD)ES( \201that is, the
  project has no commits yet\202, the special )SM(19700101000000)ES( \201UNIX
  epoch\202 commit date is used.)EP(

  )0 P(The use of )SM(git)ES( commit dates for snap)HY(shot)YH( order)HY(ing)YH( has its
  limi)HY(ta)HY(tions)YH(: they have one second reso)HY(lu)HY(tion)YH( which means it is possi)HY(ble)YH( to
  create two commits with the same date \201but not the same commit id and thus
  snap)HY(shot)YH( id\202. We also need all the commit)HY(ters)YH( to have a reason)HY(ably)YH( accu)HY(rate)YH(
  clock. Note, however, that in case of a commit date clash/order)HY(ing)YH( issue, we
  still end up with distinct versions \201because of the commit id\202 \235 they
  are just not ordered correctly. As a result, we feel that the risks are
  justi)HY(fied)YH( when the only alter)HY(na)HY(tive)YH( is manual version manage)HY(ment)YH( \201which is
  always an option, never)HY(the)HY(less)YH(\202.)EP(

  )0 P(When we prepare a distri)HY(bu)HY(tion)YH( of a snap)HY(shot)YH(, the )SM(version)ES(
  module auto)HY(mat)HY(i)HY(cally)YH( adjusts the package name to include the snap)HY(shot)YH(
  infor)HY(ma)HY(tion)YH( as well as patches the mani)HY(fest)YH( file in the distri)HY(bu)HY(tion)YH( with
  the snap)HY(shot)YH( number and id \201that is, replac)HY(ing)YH( )SM(.z)ES( in the
  version value with the actual snap)HY(shot)YH( infor)HY(ma)HY(tion)YH(\202. The result is a package
  that is specific to this commit.)EP(

  )0 P(Besides extract)HY(ing)YH( the version infor)HY(ma)HY(tion)YH( and making it avail)HY(able)YH( as
  indi)HY(vid)HY(ual)YH( compo)HY(nents)YH(, the )SM(version)ES( module also provide rules
  for installing the mani)HY(fest)YH( file as well as auto)HY(mat)HY(i)HY(cally)YH( gener)HY(at)HY(ing)YH( version
  headers \201or other similar version-based files\202.)EP(

  )0 P(By default the project's )SM(mani)HY(fest)YH()ES( file is installed as
  docu)HY(men)HY(ta)HY(tion)YH(, just like other )SM(doc{)ES(} targets \201thus replac)HY(ing)YH(
  the )SM(version)ES( file custom)HY(ar)HY(ily)YH( shipped in the project root
  direc)HY(tory)YH(\202. The mani)HY(fest)YH( instal)HY(la)HY(tion)YH( rule in the )SM(version)ES(
  module in addi)HY(tion)YH( patches the installed mani)HY(fest)YH( file with the actual
  snap)HY(shot)YH( number and id, just like during the prepa)HY(ra)HY(tion)YH( of
  distri)HY(bu)HY(tions)YH(.)EP(

  )0 P(The version header rule is based on the )0 34 1 A()SM(in)ES()34 0 TN TL()Ec /AF f D( module rule and can be used to
  prepro)HY(cesses)YH( a template file with version infor)HY(ma)HY(tion)YH(. While it is usually
  used to gener)HY(ate)YH( C/C++ version headers \201thus the name\202, it can really
  gener)HY(ate)YH( any kind of files.)EP(

  )0 P(The rule matches a )SM(file)ES(-based target that has the
  corre)HY(spond)HY(ing)YH( )SM(in)ES( prereq)HY(ui)HY(site)YH( and also depends on the project's
  )SM(mani)HY(fest)YH()ES( file. As an example, let's assume we want to
  auto-gener)HY(ate)YH( a header called )SM(version.hxx)ES( for our
  )SM(libhello)ES( library. To accom)HY(plish)YH( this we add the
  )SM(version.hxx.in)ES( template as well as some)HY(thing)YH( along these lines
  to our )SM(build)HY(file)YH()ES(:)EP(

  ) 6 50 PR(lib{hello}: ... hxx{version}

hxx{version}: in{version} $src_root/file{manifest}
{
  dist = true
})RP(

  )0 P(The header rule is a line-based prepro)HY(ces)HY(sor)YH( that substi)HY(tutes)YH( frag)HY(ments)YH(
  enclosed between \201and includ)HY(ing)YH(\202 a pair of dollar signs \201)SM($)ES(\202
  with )SM($$)ES( being the escape sequence \201see the )0 34 1 A()SM(in)ES()34 0 TN TL()Ec /AF f D( module for details\202. As an example,
  let's assume our )SM(version.hxx.in)ES( contains the follow)HY(ing)YH(
  lines:)EP(

  ) 6 65 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#endif)RP(

  )0 P(If our )SM(libhello)ES( is at version )SM(1.2.3)ES(, then the
  gener)HY(ated)YH( )SM(version.hxx)ES( will look like this:)EP(

  ) 6 47 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#endif)RP(

  )0 P(The first compo)HY(nent)YH( after the opening )SM($)ES( should be either the
  name of the project itself \201like )SM(libhello)ES( above\202 or a name of
  one of its depen)HY(den)HY(cies)YH( as listed in the mani)HY(fest)YH(. If it is the project
  itself, then the rest can refer to one of the )SM(version.*)ES(
  vari)HY(ables)YH( that we discussed earlier \201in reality it can be any vari)HY(able)YH(
  visible from the project's root scope\202.)EP(

  )0 P(If the name refers to one of the depen)HY(de)HY(cies)YH( \201that is, projects listed
  with )SM(depends:)ES( in the mani)HY(fest)YH(\202, then the follow)HY(ing)YH( special
  substi)HY(tu)HY(tions)YH( are recog)HY(nized)YH(:)EP(

  ) 3 75 PR($<name>.version$                           - textual version constraint
$<name>.condition\201<VERSION>[,<SNAPSHOT>]\202$ - numeric satisfaction condition
$<name>.check\201<VERSION>[,<SNAPSHOT>]\202$     - numeric satisfaction check)RP(

  )0 P(Here )I(VERSION)ES( is the version number macro and the optional
  )I(SNAP)HY(SHOT)YH()ES( is the snap)HY(shot)YH( number macro. The snap)HY(shot)YH( is only required
  if you plan to include snap)HY(shot)YH( infor)HY(ma)HY(tion)YH( in your depen)HY(dency)YH(
  constraints.)EP(

  )0 P(As an example, let's assume our )SM(libhello)ES( depends on
  )SM(libprint)ES( which is reflected with the follow)HY(ing)YH( line in our
  mani)HY(fest)YH(:)EP(

  ) 1 26 PR(depends: libprint >= 2.3.4)RP(

  )0 P(We also assume that )SM(libprint)ES( provides its version
  infor)HY(ma)HY(tion)YH( in the )SM(libprint/version.hxx)ES( header and uses
  anal)HY(o)HY(gous)YH(-named macros. Here is how we can add a version check to our
  )SM(version.hxx.in)ES(:)EP(

  ) 10 65 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#include <libprint/version.hxx>

$libprint.check\201LIBPRINT_VERSION\202$

#endif)RP(

  )0 P(After the substi)HY(tu)HY(tion)YH( our )SM(version.hxx)ES( header will look like
  this:)EP(

  ) 14 71 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#include <libprint/version.hxx>

#ifdef LIBPRINT_VERSION
#  if !\201LIBPRINT_VERSION >= 200003000040000ULL\202
#    error incompatible libprint version, libprint >= 2.3.4 is required
#  endif
#endif

#endif)RP(

  )0 P(The )SM(version)ES( and )SM(condi)HY(tion)YH()ES( substi)HY(tu)HY(tions)YH( are the
  build)HY(ing)YH( blocks of the )SM(check)ES( substi)HY(tu)HY(tion)YH(. For example, here is
  how we can imple)HY(ment)YH( a check with a customized error message:)EP(

  ) 3 55 PR(#if !\201$libprint.condition\201LIBPRINT_VERSION\202$\202
#  error bad libprint, need libprint $libprint.version$
#endif)RP(

  )0 P(The )SM(version)ES( module also treats one depen)HY(dency)YH( in a special
  way: if you specify the required version of the build system in your
  mani)HY(fest)YH(, then the module will auto)HY(mat)HY(i)HY(cally)YH( check it for you. For example,
  if we have the follow)HY(ing)YH( line in our mani)HY(fest)YH(:)EP(

  ) 1 26 PR(depends: * build2 >= 0.5.0)RP(

  )0 P(And someone tries to build our project with )SM(build2)ES(
  )SM(0.4.0)ES(, then they will see an error like this:)EP(

  ) 3 61 PR(build/bootstrap.build:3:1: error: incompatible build2 version
  info: running 0.4.0
  info: required 0.5.0)RP(

  )0 P(What version constraints should be use when depend)HY(ing)YH( on other project.
  We start with a simple case where we depend on a release. Let's say
  )SM(libprint)ES( )SM(2.3.0)ES( added a feature that we need in our
  )SM(libhello)ES(. If )SM(libprint)ES( follows the source/binary
  compat)HY(i)HY(bil)HY(ity)YH( guide)HY(lines)YH( discussed above, then any )SM(2.X.Y)ES(
  version should work provided )SM(X >= 3)ES(. And this how we can
  specify it in the mani)HY(fest)YH(:)EP(

  ) 1 24 PR(depends: libprint ^2.3.0)RP(

  )0 P(Let's say we are now working on )SM(libhello)ES( )SM(2.0.0)ES(
  and would like to start using features from )SM(libprint)ES(
  )SM(3.0.0)ES(. However, currently, only pre-releases of
  )SM(3.0.0)ES( are avail)HY(able)YH(. If you would like to add a depen)HY(dency)YH( on a
  pre-release \201most likely from your own pre-release\202, then the recom)HY(men)HY(da)HY(tion)YH(
  is to only allow a specific version, essen)HY(tially)YH( "expir)HY(ing)YH(" the combi)HY(na)HY(tion)YH(
  as soon as newer versions become avail)HY(able)YH(. For example:)EP(

  ) 2 30 PR(version: 2.0.0-b.1
depends: libprint == 3.0.0-b.2)RP(

  )0 P(Finally, let's assume we are feeling adven)HY(ter)HY(ous)YH( and would like to test
  devel)HY(op)HY(ment)YH( snap)HY(shots)YH( of )SM(libprint)ES( \201most likey from our own
  snap)HY(shots)YH(\202. In this case the recom)HY(men)HY(da)HY(tion)YH( is to only allow a snap)HY(shot)YH(
  range for a specific pre-release with the under)HY(stand)HY(ing)YH( and a warning that
  no compat)HY(i)HY(bil)HY(ity)YH( between snap)HY(shot)YH( versions is guar)HY(an)HY(teed)YH(. For example:)EP(

  ) 2 41 PR(version: 2.0.0-b.1.z
depends: libprint [3.0.0-b.2.1 3.0.0-b.3\202)RP(

  )0 1 23 H(6)WB 59 Sn()WB 25 Sn( )SM(bin)ES( Module)EH(

  )0 P(Coming soon.)EP(

  )0 1 24 H(7)WB 60 Sn()WB 26 Sn( )SM(cxx)ES( Module)EH(

  )0 P(This chapter describes the )SM(cxx)ES( build system module which
  provides the C++ compi)HY(la)HY(tion)YH( and linking support. Most of its func)HY(tion)HY(al)HY(ity)YH(,
  however, is provided by the )SM(cc)ES( module, a common imple)HY(men)HY(ta)HY(tion)YH(
  for the C-family languages.)EP(

  )0 2 25 H(7.1)WB 61 Sn()WB 27 Sn( C++ Modules Support)EH(

  )0 P(This section describes the build system support for C++ modules.)EP(

  )0 3 26 H(7.1.1)WB 62 Sn()WB 28 Sn( Modules Intro)HY(duc)HY(tion)YH()EH(

  )0 P(The goal of this section is to provide a prac)HY(ti)HY(cal)YH( intro)HY(duc)HY(tion)YH( to C++
  Modules and to estab)HY(lish)YH( key concepts and termi)HY(nol)HY(ogy)YH(.)EP(

  )0 P(A pre-modules C++ program or library consists of one or more
  )I(trans)HY(la)HY(tion)YH( units)ES( which are custom)HY(ar)HY(ily)YH( referred to as C++ source
  files. Trans)HY(la)HY(tion)YH( units are compiled to )I(object files)ES( which are then
  linked together to form a program or library.)EP(

  )0 P(Let's also recap the differ)HY(ence)YH( between an )I(exter)HY(nal)YH( name)ES( and a
  )I(symbol)ES(: Exter)HY(nal)YH( names refer to language enti)HY(ties)YH(, for example
  classes, func)HY(tions)YH(, and so on. The )I(exter)HY(nal)YH()ES( qual)HY(i)HY(fier)YH( means they are
  visible across trans)HY(la)HY(tion)YH( units.)EP(

  )0 P(Symbols are derived from exter)HY(nal)YH( names for use inside object files. They
  are the cross-refer)HY(enc)HY(ing)YH( mech)HY(a)HY(nism)YH( for linking a program from multi)HY(ple)YH(,
  sepa)HY(rately)YH(-compiled trans)HY(la)HY(tion)YH( units. Not all exter)HY(nal)YH( names end up
  becom)HY(ing)YH( symbols and symbols are often )I(deco)HY(rated)YH()ES( with addi)HY(tional)YH(
  infor)HY(ma)HY(tion)YH(, for example, a names)HY(pace)YH(. We often talk about a symbol having
  to be satis)HY(fied)YH( by linking an object file or a library that provides it.
  Simi)HY(larly)YH(, dupli)HY(cate)YH( symbol issues may arise if more than one object file or
  library provides the same symbol.)EP(

  )0 P(What is a C++ module? It is hard to give a single but intu)HY(itive)YH( answer to
  this ques)HY(tion)YH(.  So we will try to answer it from three differ)HY(ent)YH(
  perspec)HY(tives)YH(: that of a module consumer, a module producer, and a build
  system that tries to make those two play nice. But we can make one thing
  clear at the outset: modules are a )I(language-level)ES( not a
  prepro)HY(ces)HY(sor)YH(-level mech)HY(a)HY(nism)YH(; it is )SM(import)ES(, not
  )SM(#import)ES(.)EP(

  )0 P(One may also wonder why C++ modules, what are the bene)HY(fits)YH(? Modules offer
  isola)HY(tion)YH(, both from prepro)HY(ces)HY(sor)YH( macros and other modules' symbols. Unlike
  headers, modules require explicit expor)HY(ta)HY(tion)YH( of enti)HY(ties)YH( that will be
  visible to the consumers. In this sense they are a )I(phys)HY(i)HY(cal)YH( design
  mech)HY(a)HY(nism)YH()ES( that forces us to think how we struc)HY(ture)YH( our code. Modules
  promise signif)HY(i)HY(cant)YH( build speedups since import)HY(ing)YH( a module, unlike
  includ)HY(ing)YH( a header, should be essen)HY(tially)YH( free. Modules are also the first
  step to not needing the prepro)HY(ces)HY(sor)YH( in most trans)HY(la)HY(tion)YH( units. Finally,
  modules have a chance of bring)HY(ing)YH( to main)HY(stream)YH( reli)HY(able)YH( and easy to setup
  distributed C++ compi)HY(la)HY(tion)YH(, since with modules build systems can make sure
  compil)HY(ers)YH( on the local and remote hosts are provided with iden)HY(ti)HY(cal)YH(
  inputs.)EP(

  )0 P(To refer to a module we use a )I(module name)ES(, a sequence of
  dot-sepa)HY(rated)YH( iden)HY(ti)HY(fiers)YH(, for example )SM(hello.core)ES(. While the
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH( does not assign any hier)HY(ar)HY(chi)HY(cal)YH( seman)HY(tics)YH( to this sequence,
  it is custom)HY(ary)YH( to refer to )SM(hello.core)ES( as a submod)HY(ule)YH( of
  )SM(hello)ES(. We discuss submod)HY(ules)YH( and provide the module naming
  guide)HY(lines)YH( below.)EP(

  )0 P(From a consumer's perspec)HY(tive)YH(, a module is a collec)HY(tion)YH( of exter)HY(nal)YH(
  names, called )I(module inter)HY(face)YH()ES(, that become )I(visible)ES( once the
  module is imported:)EP(

  ) 1 17 PR(import hello.core)RP(

  )0 P(What exactly does )I(visible)ES( mean? To quote the stan)HY(dard)YH(: )I(An
  import-decla)HY(ra)HY(tion)YH( makes exported decla)HY(ra)HY(tions)YH( [...] visible to name lookup
  in the current trans)HY(la)HY(tion)YH( unit, in the same names)HY(paces)YH( and contexts [...].
  [ Note: The enti)HY(ties)YH( are not rede)HY(clared)YH( in the trans)HY(la)HY(tion)YH( unit contain)HY(ing)YH(
  the module import decla)HY(ra)HY(tion)YH(. -- end note ])ES( One intu)HY(itive)YH( way to think
  about this visi)HY(bil)HY(ity)YH( is )I(as if)ES( there were only a single trans)HY(la)HY(tion)YH(
  unit for the entire program that contained all the modules as well as all
  their consumers. In such a trans)HY(la)HY(tion)YH( unit all the names would be visible
  to every)HY(one)YH( in exactly the same way and no entity would be rede)HY(clared)YH(.)EP(

  )0 P(This visi)HY(bil)HY(ity)YH( seman)HY(tics)YH( suggests that modules are not a name scoping
  mech)HY(a)HY(nism)YH( and are orthog)HY(o)HY(nal)YH( to names)HY(paces)YH(. Specif)HY(i)HY(cally)YH(, a module can
  export names from any number of names)HY(paces)YH(, includ)HY(ing)YH( the global names)HY(pace)YH(.
  While the module name and its names)HY(pace)YH( names need not be related, it
  usually makes sense to have a paral)HY(lel)YH( naming scheme, as discussed below.
  Finally, the )SM(import)ES( decla)HY(ra)HY(tion)YH( does not imply any addi)HY(tional)YH(
  visi)HY(bil)HY(ity)YH( for names declared inside names)HY(paces)YH(. Specif)HY(i)HY(cally)YH(, to access
  such names we must continue using the stan)HY(dard)YH( mech)HY(a)HY(nisms)YH(, such as
  qual)HY(i)HY(fi)HY(ca)HY(tion)YH( or using decla)HY(ra)HY(tion)YH(/direc)HY(tive)YH(.  For example:)EP(

  ) 7 50 PR(import hello.core;        // Exports hello::say\201\202.

say \201\202;                   // Error.
hello::say \201\202;            // Ok.

using namespace hello;
say \201\202;                   // Ok.)RP(

  )0 P(Note also that from the consumer's perspec)HY(tive)YH( a module does not provide
  any symbols, only C++ entity names. If we use names from a module, then we
  may have to satisfy the corre)HY(spond)HY(ing)YH( symbols using the usual mech)HY(a)HY(nisms)YH(:
  link an object file or a library that provides them. In this respect,
  modules are similar to headers and as with headers, module's use is not
  limited to libraries; they make perfect sense when struc)HY(tur)HY(ing)YH( programs.
  Further)HY(more)YH(, a library may also have private or imple)HY(men)HY(ta)HY(tion)YH( modules that
  are not meant to be consumed by the library's users.)EP(

  )0 P(The producer perspec)HY(tive)YH( on modules is predictably more complex. In
  pre-modules C++ we only had one kind of trans)HY(la)HY(tion)YH( unit \201or source file\202.
  With modules there are three kinds: )I(module inter)HY(face)YH( unit)ES(, )I(module
  imple)HY(men)HY(ta)HY(tion)YH( unit)ES(, and the orig)HY(i)HY(nal)YH( kind which we will call a
  )I(non-module trans)HY(la)HY(tion)YH( unit)ES(.)EP(

  )0 P(From the producer's perspec)HY(tive)YH(, a module is a collec)HY(tion)YH( of module
  trans)HY(la)HY(tion)YH( units: one inter)HY(face)YH( unit and zero or more imple)HY(men)HY(ta)HY(tion)YH( units.
  A simple module may consist of just the inter)HY(face)YH( unit that includes
  imple)HY(men)HY(ta)HY(tions)YH( of all its func)HY(tions)YH( \201not neces)HY(sar)HY(ily)YH( inline\202. A more
  complex module may span multi)HY(ple)YH( imple)HY(men)HY(ta)HY(tion)YH( units.)EP(

  )0 P(A trans)HY(la)HY(tion)YH( unit is a module inter)HY(face)YH( unit if it contains an
  )I(export)HY(ing)YH( module decla)HY(ra)HY(tion)YH()ES(:)EP(

  ) 1 25 PR(export module hello.core;)RP(

  )0 P(A trans)HY(la)HY(tion)YH( unit is a module imple)HY(men)HY(ta)HY(tion)YH( unit if it contains a
  )I(non-export)HY(ing)YH( module decla)HY(ra)HY(tion)YH()ES(:)EP(

  ) 1 18 PR(module hello.core;)RP(

  )0 P(While module inter)HY(face)YH( units may use the same file exten)HY(sion)YH( as normal
  source files, we recom)HY(mend)YH( that a differ)HY(ent)YH( exten)HY(sion)YH( be used to distin)HY(guish)YH(
  them as such, similar to header files. While the compiler vendors suggest
  various \201and predictably differ)HY(ent)YH(\202 exten)HY(sions)YH(, our recom)HY(men)HY(da)HY(tion)YH( is
  )SM(.mxx)ES( for the )SM(.hxx/.cxx)ES( source file naming and
  )SM(.mpp)ES( for )SM(.hpp/.cpp)ES(. And if you are using some
  other naming scheme, then perhaps now is a good oppor)HY(tu)HY(nity)YH( to switch to one
  of the above. Contin)HY(u)HY(ing)YH( using the source file exten)HY(sion)YH( for module
  imple)HY(men)HY(ta)HY(tion)YH( units appears reason)HY(able)YH( and that's what we recom)HY(mend)YH(.)EP(

  )0 P(A module decla)HY(ra)HY(tion)YH( \201export)HY(ing)YH( or non-export)HY(ing)YH(\202 starts a )I(module
  purview)ES( that extends until the end of the module trans)HY(la)HY(tion)YH( unit. Any
  name declared in a module's purview )I(belongs)ES( to said module. For
  example:)EP(

  ) 6 53 PR(#include <string>                // Not in purview.

export module hello.core;        // Start of purview.

void
say_hello \201const std::string&\202;  // In purview.)RP(

  )0 P(A name that belongs to a module is )I(invis)HY(i)HY(ble)YH()ES( to the module's
  consumers unless it is )I(exported)ES(. A name can be declared exported only
  in a module inter)HY(face)YH( unit, only in the module's purview, and there are
  several syntac)HY(tic)YH( ways to accom)HY(plish)YH( this. We can start the decla)HY(ra)HY(tion)YH( with
  the )SM(export)ES( spec)HY(i)HY(fier)YH(, for example:)EP(

  ) 6 47 PR(export module hello.core;

export enum class volume {quiet, normal, loud};

export void
say_hello \201const char*, volume\202;)RP(

  )0 P(Alter)HY(na)HY(tively)YH(, we can enclose one or more decla)HY(ra)HY(tions)YH( into an
  )I(exported group)ES(, for example:)EP(

  ) 9 42 PR(export module hello.core;

export
{
  enum class volume {quiet, normal, loud};

  void
  say_hello \201const char*, volume\202;
})RP(

  )0 P(Finally, if a names)HY(pace)YH( defi)HY(ni)HY(tion)YH( is declared exported, then every name
  in its body is exported, for example:)EP(

  ) 15 46 PR(export module hello.core;

export namespace hello
{
  enum class volume {quiet, normal, loud};

  void
  say \201const char*, volume\202;
}

namespace hello
{
  void
  impl \201const char*, volume\202; // Not exported.
})RP(

  )0 P(Up until now we've only been talking about names belond)HY(ing)YH( to a module.
  What about the corre)HY(spond)HY(ing)YH( symbols? For exported names, the result)HY(ing)YH(
  symbols would be the same as if those names were declared outside of a
  module's purview \201or as if no modules were used at all\202. Non-exported names,
  on the other hand, have )I(module linkage)ES(: their symbols can be resolved
  from this module's units but not from other trans)HY(la)HY(tion)YH( units. They also
  cannot clash with symbols for iden)HY(ti)HY(cal)YH( names from other modules \201and
  non-modules\202. This is usually achieved by deco)HY(rat)HY(ing)YH( the non-exported
  symbols with the module name.)EP(

  )0 P(This owner)HY(ship)YH( model has an impor)HY(tant)YH( back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH(
  impli)HY(ca)HY(tion)YH(: a library built with modules enabled can be linked to a program
  that still uses headers. And even the other way around: we can build and use
  a module for a library that was built with headers.)EP(

  )0 P(What about the prepro)HY(ces)HY(sor)YH(? Modules do not export prepro)HY(ces)HY(sor)YH( macros,
  only C++ names. A macro defined in the module inter)HY(face)YH( unit cannot affect
  the module's consumers. And macros defined by the module's consumers cannot
  affect the module inter)HY(face)YH( they are import)HY(ing)YH(. In other words, module
  produc)HY(ers)YH( and consumers are isolated from each other when the prepro)HY(ces)HY(sor)YH(
  is concerned. For example, consider this module inter)HY(face)YH(:)EP(

  ) 6 36 PR(export module hello;

#ifndef SMALL
#define HELLO
export void say_hello \201const char*\202;
#endif)RP(

  )0 P(And its consumer:)EP(

  ) 8 35 PR(// module consumer
//
#define SMALL       // No effect.
import hello;

#ifdef HELLO        // Not defined.
...
#endif)RP(

  )0 P(This is not to say that the prepro)HY(ces)HY(sor)YH( cannot be used by either, it
  just doesn't "leak" through the module inter)HY(face)YH(. One prac)HY(ti)HY(cal)YH( impli)HY(ca)HY(tion)YH(
  of this model is the insignif)HY(i)HY(cance)YH( of the import order.)EP(

  )0 P(If a module imports another module in its purview, the imported module's
  names are not made auto)HY(mat)HY(i)HY(cally)YH( visible to the consumers of the import)HY(ing)YH(
  module. This is unlike headers and can be surpris)HY(ing)YH(. Consider this module
  inter)HY(face)YH( as an example:)EP(

  ) 6 31 PR(export module hello;

import std.core;

export void
say_hello \201const std::string&\202;)RP(

  )0 P(And its consumer:)EP(

  ) 7 22 PR(import hello;

int
main \201\202
{
  say_hello \201"World"\202;
})RP(

  )0 P(This example will result in a compile error and the diag)HY(nos)HY(tics)YH( may
  confus)HY(ingly)YH( indi)HY(cate)YH( that there is no known conver)HY(sion)YH( from a C string to
  "some)HY(thing)YH(" called )SM(std::string)ES(. But with the under)HY(stand)HY(ing)YH( of
  the differ)HY(ence)YH( between )SM(import)ES( and )SM(#include)ES( the
  reason should be clear: while the module inter)HY(face)YH( "sees"
  )SM(std::string)ES( \201because it imported its module\202, we \201the consumer\202
  do not \201since we did not\202. So the fix is to explic)HY(itly)YH( import
  )SM(std.core)ES(:)EP(

  ) 8 22 PR(import std.core;
import hello;

int
main \201\202
{
  say_hello \201"World"\202;
})RP(

  )0 P(A module, however, can choose to re-export a module it imports. In this
  case, all the names from the imported module will also be visible to the
  import)HY(ing)YH( module's consumers. For example, with this change to the module
  inter)HY(face)YH( the first version of our consumer will compile without errors
  \201note that whether this is a good design choice is debat)HY(able)YH(, as discussed
  below\202:)EP(

  ) 6 31 PR(export module hello;

export import std.core;

export void
say_hello \201const std::string&\202;)RP(

  )0 P(One way to think of a re-export is )I(as if)ES( an import of a module
  also "injects" all the imports said module re-exports, recur)HY(sively)YH(. That's
  essen)HY(tially)YH( how most compil)HY(ers)YH( imple)HY(ment)YH( it.)EP(

  )0 P(Module re-export is the mech)HY(a)HY(nism)YH( for assem)HY(bling)YH( bigger modules out of
  submod)HY(ules)YH(. As an example, let's say we had the )SM(hello.core)ES(,
  )SM(hello.basic)ES(, and )SM(hello.extra)ES( modules. To make life
  easier for users that want to import all of them we can create the
  )SM(hello)ES( module that re-exports the three:)EP(

  ) 8 21 PR(export module hello;

export
{
  import hello.core;
  import hello.basic;
  import hello.extra;
})RP(

  )0 P(Besides start)HY(ing)YH( a module purview, a non-export)HY(ing)YH( module decla)HY(ra)HY(tion)YH( in
  the imple)HY(men)HY(ta)HY(tion)YH( unit makes non-inter)HY(nal)YH( linkage names declared or made
  visible in the )I(inter)HY(face)YH( purview)ES( also visible in the
  )I(imple)HY(men)HY(ta)HY(tion)YH( purview)ES(. In this sense non-export)HY(ing)YH( module
  decla)HY(ra)HY(tion)YH( acts as an extended )SM(import)ES(. For example:)EP(

  ) 14 62 PR(import hello.impl;          // Not visible \201exports impl\201\202\202.

void
extra_impl \201\202;              // Not visible.

export module hello.extra;  // Start of interface purview.

import hello.core;          // Visible \201exports core\201\202\202.

void
extra \201\202;                   // Visible.

static void
extra2 \201\202;                  // Not visible \201internal linkage\202.)RP(

  )0 P(And this is the imple)HY(men)HY(ta)HY(tion)YH( unit:)EP(

  ) 11 63 PR(module hello.extra;         // Start of implementation purview.

void
f \201\202
{
  impl \201\202;        // Error.
  extra_impl \201\202;  // Error.
  core \201\202;        // Ok.
  extra \201\202;       // Ok.
  extra2 \201\202;      // Error.
})RP(

  )0 P(In partic)HY(u)HY(lar)YH(, this means that while the rela)HY(tive)YH( order of imports is not
  signif)HY(i)HY(cant)YH(, the place)HY(ment)YH( of imports in the module inter)HY(face)YH( unit rela)HY(tive)YH(
  to the module decla)HY(ra)HY(tion)YH( can be.)EP(

  )0 P(The final perspec)HY(tive)YH( that we consider is that of the build system. From
  its point of view the central piece of the module infras)HY(truc)HY(ture)YH( is the
  )I(binary module inter)HY(face)YH()ES(: a binary file that is produced by compil)HY(ing)YH(
  the module inter)HY(face)YH( unit and that is required when compil)HY(ing)YH( any
  trans)HY(la)HY(tion)YH( unit that imports this module as well as the module's
  imple)HY(men)HY(ta)HY(tion)YH( units.)EP(

  )0 P(Then, in a nutshell, the main func)HY(tion)HY(al)HY(ity)YH( of a build system when it
  comes to modules support is figur)HY(ing)YH( out the order in which all the
  trans)HY(la)HY(tion)YH( units should be compiled and making sure that every compi)HY(la)HY(tion)YH(
  process is able to find the binary module inter)HY(faces)YH( it needs.)EP(

  )0 P(Predictably, the details are more complex. Compil)HY(ing)YH( a module inter)HY(face)YH(
  unit produces two outputs: the binary module inter)HY(face)YH( and the object file.
  The latter contains object code for non-inline func)HY(tions)YH(, global vari)HY(ables)YH(,
  etc., that the inter)HY(face)YH( unit may define. This object file has to be linked
  when produc)HY(ing)YH( any binary \201program or library\202 that uses this module.)EP(

  )0 P(Also, all the compil)HY(ers)YH( currently imple)HY(ment)YH( module re-export as a shallow
  refer)HY(ence)YH( to the re-exported module name which means that their binary
  inter)HY(faces)YH( must be discov)HY(er)HY(able)YH( as well, recur)HY(sively)YH(. In fact, currently,
  all the imports are handled like this, though a differ)HY(ent)YH( imple)HY(men)HY(ta)HY(tion)YH( is
  at least plau)HY(si)HY(ble)YH(, if unlikely.)EP(

  )0 P(While the details vary between compil)HY(ers)YH(, the contents of the binary
  module inter)HY(face)YH( can range from a stream of prepro)HY(cessed)YH( tokens to some)HY(thing)YH(
  fairly close to object code. As a result, binary inter)HY(faces)YH( can be sensi)HY(tive)YH(
  to the compiler options and if the options used to produce the binary
  inter)HY(face)YH( \201for example, when build)HY(ing)YH( a library\202 are suffi)HY(ciently)YH( differ)HY(ent)YH(
  compared to the ones used when compil)HY(ing)YH( the module consumers, the binary
  inter)HY(face)YH( may be unus)HY(able)YH(. So while a build system should strive to reuse
  exist)HY(ing)YH( binary inter)HY(faces)YH(, it should also be prepared to compile its own
  versions "on the side".)EP(

  )0 P(This also suggests that binary module inter)HY(faces)YH( are not a distri)HY(bu)HY(tion)YH(
  mech)HY(a)HY(nism)YH( and should prob)HY(a)HY(bly)YH( not be installed. Instead, we should install
  and distribute module inter)HY(face)YH( sources and build systems should be prepared
  to compile them, again, on the side.)EP(

  )0 3 27 H(7.1.2)WB 63 Sn()WB 29 Sn( Build)HY(ing)YH( Modules)EH(

  )0 P(Compiler support for C++ Modules is still exper)HY(i)HY(men)HY(tal)YH(. As a result, it
  is currently only enabled if the C++ stan)HY(dard)YH( is set to
  )SM(exper)HY(i)HY(men)HY(tal)YH()ES(. After loading the )SM(cxx)ES( module we can
  check if modules are enabled using the )SM(cxx.features.modules)ES(
  boolean vari)HY(able)YH(. This is what the rele)HY(vant)YH( )SM(root.build)ES( frag)HY(ment)YH(
  could look like for a modu)HY(lar)HY(ized)YH( project:)EP(

  ) 8 64 PR(cxx.std = experimental

using cxx

assert $cxx.features.modules 'compiler does not support modules'

mxx{*}: extension = mxx
cxx{*}: extension = cxx)RP(

  )0 P(To support C++ modules the )SM(cxx)ES( module \201build system\202 defines
  several addi)HY(tional)YH( target types. The )SM(mxx{})ES( target is a module
  inter)HY(face)YH( unit. As you can see from the above )SM(root.build)ES(
  frag)HY(ment)YH(, in this project we are using the )SM(.mxx)ES( exten)HY(sion)YH( for
  our module inter)HY(face)YH( files. While you can use the same exten)HY(sion)YH( as for
  )SM(cxx{})ES( \201source files\202, this is not recom)HY(mended)YH( since some
  func)HY(tion)HY(al)HY(ity)YH(, such as wild)HY(card)YH( patterns, will become unus)HY(able)YH(.)EP(

  )0 P(The )SM(bmi{})ES( group and its )SM(bmie{})ES(,
  )SM(bmia{})ES(, and )SM(bmis{})ES( members are used to repre)HY(sent)YH(
  binary module inter)HY(faces)YH( targets. We normally do not need to mention them
  explic)HY(itly)YH( in our build)HY(files)YH( except, perhaps, to specify addi)HY(tional)YH(, module
  inter)HY(face)YH(-specific compile options. We will see some exam)HY(ples)YH( of this
  below.)EP(

  )0 P(To build a modu)HY(lar)HY(ized)YH( executable or library we simply list the module
  inter)HY(faces)YH( as its prereq)HY(ui)HY(sites)YH(, just as we do for source files. As an
  example, let's build the )SM(hello)ES( program that we have started in
  the intro)HY(duc)HY(tion)YH( \201you can find the complete project in the )R3 2 A(Hello Repos)HY(i)HY(tory)YH()EA( under
  )SM(mhello)ES(\202. Specif)HY(i)HY(cally)YH(, we assume our project contains the
  follow)HY(ing)YH( files:)EP(

  ) 8 37 PR(// file: hello.mxx \201module interface\202

export module hello;

import std.core;

export void
say_hello \201const std::string&\202;)RP(

  ) 13 43 PR(// file: hello.cxx \201module implementation\202

module hello;

import std.io;

using namespace std;

void
say_hello \201const string& name\202
{
  cout << "Hello, " << name << '!' << endl;
})RP(

  ) 10 22 PR(// file: driver.cxx

import std.core;
import hello;

int
main \201\202
{
  say_hello \201"World"\202;
})RP(

  )0 P(To build a )SM(hello)ES( executable from these files we can write
  the follow)HY(ing)YH( )SM(build)HY(file)YH()ES(:)EP(

  ) 1 40 PR(exe{hello}: cxx{driver} {mxx cxx}{hello})RP(

  )0 P(Or, if you prefer to use wild)HY(card)YH( patterns:)EP(

  ) 1 24 PR(exe{hello}: {mxx cxx}{*})RP(

  )0 P(Alter)HY(na)HY(tively)YH(, we can package the module into a library and then link the
  library to the executable:)EP(

  ) 2 34 PR(exe{hello}: cxx{driver} lib{hello}
lib{hello}: {mxx cxx}{hello})RP(

  )0 P(As you might have surmised from this example, the modules support in
  )SM(build2)ES( auto)HY(mat)HY(i)HY(cally)YH( resolves imports to module inter)HY(face)YH( units
  that are spec)HY(i)HY(fied)YH( either as direct prereq)HY(ui)HY(sites)YH( or as prereq)HY(ui)HY(sites)YH( of
  library prereq)HY(ui)HY(sites)YH(.)EP(

  )0 P(To perform this reso)HY(lu)HY(tion)YH( without a signif)HY(i)HY(cant)YH( over)HY(head)YH(, the
  imple)HY(men)HY(ta)HY(tion)YH( delays the extrac)HY(tion)YH( of the actual module name from module
  inter)HY(face)YH( units \201since not all avail)HY(able)YH( module inter)HY(faces)YH( are neces)HY(sar)HY(ily)YH(
  imported by all the trans)HY(la)HY(tion)YH( units\202. Instead, the imple)HY(men)HY(ta)HY(tion)YH( tries to
  guess which inter)HY(face)YH( unit imple)HY(ments)YH( each module being imported based on
  the inter)HY(face)YH( file path. Or, more precisely, a two-step reso)HY(lu)HY(tion)YH( process
  is performed: first a best match between the desired module name and the
  file path is sought and then the actual module name is extracted and the
  correct)HY(ness)YH( of the initial guess is veri)HY(fied)YH(.)EP(

  )0 P(The prac)HY(ti)HY(cal)YH( impli)HY(ca)HY(tion)YH( of this imple)HY(men)HY(ta)HY(tion)YH( detail is that our
  module inter)HY(face)YH( files must embed a portion of a module name, or, more
  precisely, a suffi)HY(cient)YH( amount of "module name tail" to unam)HY(bigu)HY(ously)YH(
  resolve all the modules used in a project. Note also that this guess)HY(work)YH( is
  only performed for direct module inter)HY(face)YH( prereq)HY(ui)HY(sites)YH(; for those that
  come from libraries the module names are known and are there)HY(fore)YH( matched
  exactly.)EP(

  )0 P(As an example, let's assume our )SM(hello)ES( project had two
  modules: )SM(hello.core)ES( and )SM(hello.extra)ES(. While we
  could call our inter)HY(face)YH( files )SM(hello.core.mxx)ES( and
  )SM(hello.extra.mxx)ES(, respec)HY(tively)YH(, this doesn't look partic)HY(u)HY(larly)YH(
  good and may be contrary to the file naming scheme used in our project. To
  resolve this issue the match of module names to file names is made "fuzzy":
  it is case-insen)HY(si)HY(tive)YH(, it treats all sepa)HY(ra)HY(tors)YH( \201dots, dashes, under)HY(scores)YH(,
  etc\202 as equal, and it treats a case change as an imag)HY(i)HY(nary)YH( sepa)HY(ra)HY(tor)YH(. As a
  result, the follow)HY(ing)YH( naming schemes will all match the
  )SM(hello.core)ES( module name:)EP(

  ) 4 14 PR(hello-core.mxx
hello_core.mxx
HelloCore.mxx
hello/core.mxx)RP(

  )0 P(We also don't have to embed the full module name. In our case, for
  example, it would be most natural to call the files )SM(core.mxx)ES(
  and )SM(extra.mxx)ES( since they are already in the project direc)HY(tory)YH(
  called )SM(hello/)ES(. This will work since our module names can still
  be guessed correctly and unam)HY(bigu)HY(ously)YH(.)EP(

  )0 P(If a guess turns out to be incor)HY(rect)YH(, the imple)HY(men)HY(ta)HY(tion)YH( issues
  diag)HY(nos)HY(tics)YH( and exits with an error before attempt)HY(ing)YH( to build anything. To
  resolve this situ)HY(a)HY(tion)YH( we can either adjust the inter)HY(face)YH( file names or we
  can specify the module name explic)HY(itly)YH( with the )SM(cxx.module_name)ES(
  vari)HY(able)YH(. The latter approach can be used with inter)HY(face)YH( file names that
  have nothing in common with module names, for example:)EP(

  ) 1 39 PR(mxx{foobar}@./: cxx.module_name = hello)RP(

  )0 P(Note also that stan)HY(dard)YH( library modules \201)SM(std)ES( and
  )SM(std.*)ES(\202 are treated specially: they are not fuzzy-matched and
  they need not be resolv)HY(able)YH( to the corre)HY(spond)HY(ing)YH( )SM(mxx{})ES( or
  )SM(bmi{})ES( in which case it is assumed they will be resolved in an
  ad hoc way by the compiler. This means that if you want to build your own
  stan)HY(dard)YH( library module \201for example, because your compiler doesn't yet ship
  one; note that this may not be supported by all compil)HY(ers)YH(\202, then you have to
  specify the module name explic)HY(itly)YH(. For example:)EP(

  ) 3 54 PR(exe{hello}: cxx{driver} {mxx cxx}{hello} mxx{std-core}

mxx{std-core}@./: cxx.module_name = std.core)RP(

  )0 P(When C++ modules are enabled and avail)HY(able)YH(, the build system makes sure
  the )SM(__cpp_modules)ES( feature test macro is defined. Currently, its
  value is )SM(201703)ES( for VC and )SM(201704)ES( for GCC and
  Clang but this will most likely change in the future.)EP(

  )0 P(One major differ)HY(ence)YH( between the current C++ modules imple)HY(men)HY(ta)HY(tion)YH( in VC
  and the other two compil)HY(ers)YH( is the use of the )SM(export module)ES(
  syntax to iden)HY(tify)YH( the inter)HY(face)YH( units. While both GCC and Clang have
  adopted this new syntax, VC is still using the old one without the
  )SM(export)ES( keyword. We can use the )SM(__cpp_modules)ES( macro
  to provide a portable decla)HY(ra)HY(tion)YH(:)EP(

  ) 4 27 PR(#if __cpp_modules >= 201704
export
#endif
module hello;)RP(

  )0 P(Note, however, that the modules support in )SM(build2)ES( provides
  tempo)HY(rary)YH( "magic" that allows us to use the new syntax even with VC \201don't
  ask how\202.)EP(

  )0 3 28 H(7.1.3)WB 64 Sn()WB 30 Sn( Module Symbols Export)HY(ing)YH()EH(

  )0 P(When build)HY(ing)YH( a shared library, some plat)HY(forms)YH( \201notably Windows\202 require
  that we explic)HY(itly)YH( export symbols that must be acces)HY(si)HY(ble)YH( to the library
  users. If you don't need to support such plat)HY(forms)YH(, you can thank your lucky
  stars and skip this section.)EP(

  )0 P(When using headers, the tradi)HY(tional)YH( way of achiev)HY(ing)YH( this is via an
  "export macro" that is used to mark exported APIs, for example:)EP(

  ) 2 26 PR(LIBHELLO_EXPORT void
say_hello \201const string&\202;)RP(

  )0 P(This macro is then appro)HY(pri)HY(ately)YH( defined \201often in a sepa)HY(rate)YH( "export
  header"\202 to export symbols when build)HY(ing)YH( the shared library and to import
  them when build)HY(ing)YH( the library's users.)EP(

  )0 P(The intro)HY(duc)HY(tion)YH( of modules changes this in a number of ways, at least as
  imple)HY(mented)YH( by VC \201hope)HY(fully)YH( other compil)HY(ers)YH( will follow suit\202. While we
  still have to explic)HY(itly)YH( mark exported symbols in our module inter)HY(face)YH( unit,
  there is no need \201and, in fact, no way\202 to do the same when said module is
  imported. Instead, the compiler auto)HY(mat)HY(i)HY(cally)YH( treats all such explic)HY(itly)YH(
  exported symbols \201note: symbols, not names\202 as imported.)EP(

  )0 P(One notable aspect of this new model is the local)HY(ity)YH( of the export macro:
  it is only defined when compil)HY(ing)YH( the module inter)HY(face)YH( unit and is not
  visible to the consumers of the module. This is unlike headers where the
  macro has to have a unique per-library name \201that )SM(LIBHELLO_)ES(
  prefix\202 because a header from one library can be included while build)HY(ing)YH(
  another library.)EP(

  )0 P(We can continue using the same export macro and header with modules and,
  in fact, that's the recom)HY(mended)YH( approach when main)HY(tain)HY(ing)YH( the dual,
  header/module arrange)HY(ment)YH( for back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( \201discussed below\202.
  However, for modules-only code)HY(bases)YH(, we have an oppor)HY(tu)HY(nity)YH( to improve the
  situ)HY(a)HY(tion)YH( in two ways: we can use a single, keyword-like macro instead of a
  library-specific one and we can make the build system manage it for us thus
  getting rid of the export header.)EP(

  )0 P(To enable this func)HY(tion)HY(al)HY(ity)YH( in )SM(build2)ES( we set the
  )SM(cxx.features.symex)HY(port)YH()ES( boolean vari)HY(able)YH( to )SM(true)ES(
  before loading the )SM(cxx)ES( module. For example:)EP(

  ) 7 29 PR(cxx.std = experimental

cxx.features.symexport = true

using cxx

...)RP(

  )0 P(Once enabled, )SM(build2)ES( auto)HY(mat)HY(i)HY(cally)YH( defines the
  )SM(__symex)HY(port)YH()ES( macro to the appro)HY(pri)HY(ate)YH( value depend)HY(ing)YH( on the
  plat)HY(form)YH( and the type of library being built. As library authors, all we
  have to do is use it in appro)HY(pri)HY(ate)YH( places in our module inter)HY(face)YH( units,
  for example:)EP(

  ) 6 31 PR(export module hello;

import std.core;

export __symexport void
say_hello \201const std::string&\202;)RP(

  )0 P(As an aside, you may be wonder)HY(ing)YH( why can't a module export auto)HY(mat)HY(i)HY(cally)YH(
  mean a symbol export? While you will normally want to export symbols of all
  your module-exported names, you may also need to do so for some
  non-module-exported ones. For example:)EP(

  ) 10 30 PR(export module foo;

__symexport void
f_impl \201\202;

export __symexport inline void
f \201\202
{
  f_impl \201\202;
})RP(

  )0 P(Further)HY(more)YH(, symbol export)HY(ing)YH( is a murky area with many limi)HY(ta)HY(tions)YH( and
  pitfalls \201such as auto-export)HY(ing)YH( of base classes\202. As a result, it would not
  be unrea)HY(son)HY(able)YH( to expect such an auto)HY(matic)YH( module export)HY(ing)YH( to only further
  muddy the matter.)EP(

  )0 3 29 H(7.1.4)WB 65 Sn()WB 31 Sn( Modules Instal)HY(la)HY(tion)YH()EH(

  )0 P(As discussed in the intro)HY(duc)HY(tion)YH(, binary module inter)HY(faces)YH( are not a
  distri)HY(bu)HY(tion)YH( mech)HY(a)HY(nism)YH( and installing module inter)HY(face)YH( sources appears to be
  the preferred approach.)EP(

  )0 P(Module inter)HY(face)YH( units are by default installed in the same loca)HY(tion)YH( as
  headers \201for example, )SM(/usr/include)ES(\202. However, instead of
  relying on a header-like search mech)HY(a)HY(nism)YH( \201)SM(-I)ES( paths, etc.\202, an
  explicit list of exported modules is provided for each library in its
  )SM(.pc)ES( \201)SM(pkg-config)ES(\202 file.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, the library's )SM(.pc)ES( file contains the
  )SM(cxx_modules)ES( vari)HY(able)YH( that lists all the exported C++ modules in
  the )SM(<name>=<path>)ES( form with )SM(<name>)ES( being
  the module's C++ name and )SM(<path>)ES( \235 the module
  inter)HY(face)YH( file's abso)HY(lute)YH( path. For example:)EP(

  ) 6 93 PR(Name: libhello
Version: 1.0.0
Cflags:
Libs: -L/usr/lib -lhello

cxx_modules = hello.core=/usr/include/hello/core.mxx hello.extra=/usr/include/hello/extra.mxx)RP(

  )0 P(Addi)HY(tional)YH( module prop)HY(er)HY(ties)YH( are spec)HY(i)HY(fied)YH( with vari)HY(ables)YH( in the
  )SM(cxx_module_<prop)HY(erty)YH(>.<name>)ES( form, for example:)EP(

  ) 2 40 PR(cxx_module_symexport.hello.core = true
cxx_module_preprocessed.hello.core = all)RP(

  )0 P(Currently, two prop)HY(er)HY(ties)YH( are defined. The )SM(symex)HY(port)YH()ES(
  prop)HY(erty)YH( with the boolean value signals whether the module uses the
  )SM(__symex)HY(port)YH()ES( support discussed above.)EP(

  )0 P(The )SM(prepro)HY(cessed)YH()ES( prop)HY(erty)YH( indi)HY(cates)YH( the degree of
  prepro)HY(cess)HY(ing)YH( the module unit requires and is used to opti)HY(mize)YH( module
  compi)HY(la)HY(tion)YH(. Valid values are )SM(none)ES( \201not prepro)HY(cessed)YH(\202,
  )SM(includes)ES( \201no )SM(#include)ES( direc)HY(tives)YH( in the source\202,
  )SM(modules)ES( \201as above plus no module decla)HY(ra)HY(tions)YH( depend on the
  prepro)HY(ces)HY(sor)YH(, for example, )SM(#ifdef)ES(, etc.\202, and )SM(all)ES(
  \201the source is fully prepro)HY(cessed)YH(\202. Note that for )SM(all)ES( the
  source may still contain comments and line contin)HY(u)HY(a)HY(tions)YH(.)EP(

  )0 3 30 H(7.1.5)WB 66 Sn()WB 32 Sn( Modules Design Guide)HY(lines)YH()EH(

  )0 P(Modules are a phys)HY(i)HY(cal)YH( design mech)HY(a)HY(nism)YH( for struc)HY(tur)HY(ing)YH( and orga)HY(niz)HY(ing)YH(
  our code. Their explicit expor)HY(ta)HY(tion)YH( seman)HY(tics)YH( combined with the way they
  are built make many aspects of creat)HY(ing)YH( and consum)HY(ing)YH( modules signif)HY(i)HY(cantly)YH(
  differ)HY(ent)YH( compared to headers. This section provides basic guide)HY(lines)YH( for
  design)HY(ing)YH( modules. We start with the overall consid)HY(er)HY(a)HY(tions)YH( such as module
  gran)HY(u)HY(lar)HY(ity)YH( and parti)HY(tion)HY(ing)YH( into trans)HY(la)HY(tion)YH( units then continue with the
  struc)HY(ture)YH( of typical module inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH( units. The
  follow)HY(ing)YH( section discusses prac)HY(ti)HY(cal)YH( approaches to modu)HY(lar)HY(iz)HY(ing)YH( exist)HY(ing)YH(
  code and provid)HY(ing)YH( dual, header/module inter)HY(faces)YH( for
  back)HY(wards)YH(-compat)HY(i)HY(bil)HY(ity)YH(.)EP(

  )0 P(Unlike headers, the cost of import)HY(ing)YH( modules should be negli)HY(gi)HY(ble)YH(. As a
  result, it may be tempt)HY(ing)YH( to create "mega-modules", for example, one per
  library. After all, this is how the stan)HY(dard)YH( library is modu)HY(lar)HY(ized)YH( with its
  fairly large )SM(std.core)ES( and )SM(std.io)ES( modules.)EP(

  )0 P(There is, however, a signif)HY(i)HY(cant)YH( draw)HY(back)YH( to this choice: every time we
  make a change, all consumers of such a mega-module will have to be
  recom)HY(piled)YH(, whether the change affects them or not. And the bigger the
  module the higher the chance that any given change does not \201seman)HY(ti)HY(cally)YH(\202
  affect a large portion of the module's consumers. Note also that this is not
  an issue for the stan)HY(dard)YH( library modules since they are not expected to
  change often.)EP(

  )0 P(Another, more subtle, issue with mega-modules \201which does affect the
  stan)HY(dard)YH( library\202 is the inabil)HY(ity)YH( to re-export only specific inter)HY(faces)YH(, as
  will be discussed below.)EP(

  )0 P(The other extreme in choos)HY(ing)YH( module gran)HY(u)HY(lar)HY(ity)YH( is a large number of
  "mini-modules". Their main draw)HY(back)YH( is the tedious)HY(ness)YH( of impor)HY(ta)HY(tion)YH( by the
  consumers.)EP(

  )0 P(The sensi)HY(ble)YH( approach is then to create modules of concep)HY(tu)HY(ally)YH(-related
  and commonly-used enti)HY(ties)YH( possi)HY(bly)YH( comple)HY(mented)YH( with aggre)HY(gate)YH( modules for
  ease of impor)HY(ta)HY(tion)YH(. This also happens to be gener)HY(ally)YH( good design.)EP(

  )0 P(As an example, let's consider an XML library that provides support for
  both parsing and seri)HY(al)HY(iza)HY(tion)YH(. Since it is common for appli)HY(ca)HY(tions)YH( to only
  use one of the func)HY(tion)HY(al)HY(i)HY(ties)YH(, it makes sense to provide the
  )SM(xml.parser)ES( and )SM(xml.seri)HY(al)HY(izer)YH()ES( modules. While it is
  not too tedious to import both, for conve)HY(nience)YH( we could also provide the
  )SM(xml)ES( module that re-exports the two.)EP(

  )0 P(Once we are past select)HY(ing)YH( an appro)HY(pri)HY(ate)YH( gran)HY(u)HY(lar)HY(ity)YH( for our modules,
  the next ques)HY(tion)YH( is how to parti)HY(tion)YH( them into trans)HY(la)HY(tion)YH( units. A module
  can consist of just the inter)HY(face)YH( unit and, as discussed above, such a unit
  can contain anything an imple)HY(men)HY(ta)HY(tion)YH( unit can, includ)HY(ing)YH( non-inline
  func)HY(tion)YH( defi)HY(ni)HY(tions)YH(. Some may then view this as an oppor)HY(tu)HY(nity)YH( to get rid
  of the header/source sepa)HY(ra)HY(tion)YH( and have every)HY(thing)YH( in a single file.)EP(

  )0 P(There are a number of draw)HY(backs)YH( with this approach: Every time we change
  anything in the module inter)HY(face)YH( unit, all its consumers have to be
  recom)HY(piled)YH(. If we keep every)HY(thing)YH( in a single file, then every time we
  change the imple)HY(men)HY(ta)HY(tion)YH( we trigger recom)HY(pi)HY(la)HY(tions)YH( that would have been
  avoided had the imple)HY(men)HY(ta)HY(tion)YH( been factored out into a sepa)HY(rate)YH( unit. Note
  that a build system in coop)HY(er)HY(a)HY(tion)YH( with the compiler could theo)HY(ret)HY(i)HY(cally)YH(
  avoid such unnec)HY(es)HY(sary)YH( recom)HY(pi)HY(la)HY(tions)YH(: if the compiler produces iden)HY(ti)HY(cal)YH(
  binary inter)HY(face)YH( files when the module inter)HY(face)YH( is unchanged, then the
  build system could detect this and skip recom)HY(pil)HY(ing)YH( the module's
  consumers.)EP(

  )0 P(A related issue with single-file modules is the reduc)HY(tion)YH( in the build
  paral)HY(leliza)HY(tion)YH( oppor)HY(tu)HY(ni)HY(ties)YH(. If the imple)HY(men)HY(ta)HY(tion)YH( is part of the
  inter)HY(face)YH( unit, then the build system cannot start compil)HY(ing)YH( the module's
  consumers until both the inter)HY(face)YH( and the imple)HY(men)HY(ta)HY(tion)YH( are compiled. On
  the other hand, had the imple)HY(men)HY(ta)HY(tion)YH( been split into a sepa)HY(rate)YH( file, the
  build system could start compil)HY(ing)YH( the module's consumers \201as well as the
  imple)HY(men)HY(ta)HY(tion)YH( unit\202 as soon as the module inter)HY(face)YH( is compiled.)EP(

  )0 P(Another issues with combin)HY(ing)YH( the inter)HY(face)YH( with the imple)HY(men)HY(ta)HY(tion)YH( is
  the read)HY(abil)HY(ity)YH( of the inter)HY(face)YH( which could be signif)HY(i)HY(cantly)YH( reduced if
  littered with imple)HY(men)HY(ta)HY(tion)YH( details. We could keep the inter)HY(face)YH( sepa)HY(rate)YH(
  by moving the imple)HY(men)HY(ta)HY(tion)YH( to the bottom of the inter)HY(face)YH( file but then we
  might as well move it into a sepa)HY(rate)YH( file and avoid the unnec)HY(es)HY(sary)YH(
  recom)HY(pi)HY(la)HY(tions)YH( or paral)HY(leliza)HY(tion)YH( issues.)EP(

  )0 P(The sensi)HY(ble)YH( guide)HY(line)YH( is then to have a sepa)HY(rate)YH( module imple)HY(men)HY(ta)HY(tion)YH(
  unit except perhaps for modules with a simple imple)HY(men)HY(ta)HY(tion)YH( that is mostly
  inline/template. Note that more complex modules may have several
  imple)HY(men)HY(ta)HY(tion)YH( units, however, based on our gran)HY(u)HY(lar)HY(ity)YH( guide)HY(line)YH(, those
  should be rare.)EP(

  )0 P(Once we start writing our first real module the imme)HY(di)HY(ate)YH( ques)HY(tion)YH( that
  normally comes up is where to put )SM(#include)ES( direc)HY(tives)YH( and
  )SM(import)ES( decla)HY(ra)HY(tions)YH( and in what order. To recap, a module unit,
  both inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH(, is split into two parts: before the
  module decla)HY(ra)HY(tion)YH( which obeys the usual or "old" trans)HY(la)HY(tion)YH( unit rules and
  after the module decla)HY(ra)HY(tion)YH( which is the module purview. Inside the module
  purview all non-exported decla)HY(ra)HY(tions)YH( have module linkage which means their
  symbols are invis)HY(i)HY(ble)YH( to any other module \201includ)HY(ing)YH( the global module\202.
  With this under)HY(stand)HY(ing)YH(, consider the follow)HY(ing)YH( module inter)HY(face)YH(:)EP(

  ) 3 20 PR(export module hello;

#include <string>)RP(

  )0 P(Do you see the problem? We have included )SM(<string>)ES( in the
  module purview which means all its names \201as well as all the names in any
  headers it might include, recur)HY(sively)YH(\202 are now declared as having the
  )SM(hello)ES( module linkage. The result of doing this can range from
  silent code blot to strange-looking unre)HY(solved)YH( symbols.)EP(

  )0 P(The guide)HY(line)YH( this leads to should be clear: includ)HY(ing)YH( a header in the
  module purview is almost always a bad idea. There are, however, a few types
  of headers that may make sense to include in the module purview. The first
  are headers that only define prepro)HY(ces)HY(sor)YH( macros, for example, config)HY(u)HY(ra)HY(tion)YH(
  or export headers. There are also cases where we do want the included
  decla)HY(ra)HY(tions)YH( to end up in the module purview. The most common example is
  inline/template func)HY(tion)YH( imple)HY(men)HY(ta)HY(tions)YH( that have been factored out into
  sepa)HY(rate)YH( files for code orga)HY(ni)HY(za)HY(tion)YH( reasons. As an example, consider the
  follow)HY(ing)YH( module inter)HY(face)YH( that uses an export header \201which presum)HY(ably)YH( sets
  up symbols export)HY(ing)YH( macros\202 as well as an inline file:)EP(

  ) 12 30 PR(#include <string>

export module hello;

#include <libhello/export.hxx>

export namespace hello
{
  ...
}

#include <libhello/hello.ixx>)RP(

  )0 P(A note on inline/template files: in header-based projects we could
  include addi)HY(tional)YH( headers in those files, for example, if the included
  decla)HY(ra)HY(tions)YH( are only needed in the imple)HY(men)HY(ta)HY(tion)YH(. For the reasons just
  discussed, this does not work with modules and we have to move all the
  includes into the inter)HY(face)YH( file, before the module purview. On the other
  hand, with modules, it is safe to use names)HY(pace)YH(-level using-direc)HY(tives)YH( \201for
  example, )SM(using names)HY(pace)YH( std;)ES(\202 in inline/template files \201and,
  with care, even in the inter)HY(face)YH( file\202.)EP(

  )0 P(What about imports, where should we import other modules? Again, to
  recap, unlike a header inclu)HY(sion)YH(, an )SM(import)ES( decla)HY(ra)HY(tion)YH( only
  makes exported names visible without redeclar)HY(ing)YH( them. As result, in module
  imple)HY(men)HY(ta)HY(tion)YH( units, it doesn't really matter where we place imports, in or
  out of the module purview. There are, however, two differ)HY(ences)YH( when it comes
  to module inter)HY(face)YH( units: only imports in the purview are visible to
  imple)HY(men)HY(ta)HY(tion)YH( units and we can only re-export an imported module from the
  purview.)EP(

  )0 P(The guide)HY(line)YH( is then for inter)HY(face)YH( units to import in the module purview
  unless there is a good reason not to make the import visible to the
  imple)HY(men)HY(ta)HY(tion)YH( units. And for imple)HY(men)HY(ta)HY(tion)YH( units to always import in the
  purview for consis)HY(tency)YH(. For example:)EP(

  ) 14 30 PR(#include <cassert>

export module hello;

import std.core;

#include <libhello/export.hxx>

export namespace hello
{
  ...
}

#include <libhello/hello.ixx>)RP(

  )0 P(By putting all these guide)HY(lines)YH( together we can then create a module
  inter)HY(face)YH( unit template:)EP(

  ) 13 57 PR(// Module interface unit.

<header includes>

export module <name>;      // Start of module purview.

<module imports>

<special header includes>  // Configuration, export, etc.

<module interface>

<inline/template includes>)RP(

  )0 P(As well as the module imple)HY(men)HY(ta)HY(tion)YH( unit template:)EP(

  ) 9 59 PR(// Module implementation unit.

<header includes>

module <name>;             // Start of module purview.

<extra module imports>     // Only additional to interface.

<module implementation>)RP(

  )0 P(Let's now discuss module naming. Module names are in a sepa)HY(rate)YH( "name
  plane" and do not collide with names)HY(pace)YH(, type, or func)HY(tion)YH( names. Also, as
  mentioned earlier, the stan)HY(dard)YH( does not assign a hier)HY(ar)HY(chi)HY(cal)YH( meaning to
  module names though it is custom)HY(ary)YH( to assume module )SM(hello.core)ES(
  is a submod)HY(ule)YH( of )SM(hello)ES( and import)HY(ing)YH( the latter also imports
  the former.)EP(

  )0 P(It is impor)HY(tant)YH( to choose good names for public modules \201that is, modules
  pack)HY(aged)YH( into libraries and used by a wide range of consumers\202 since
  chang)HY(ing)YH( them later can be costly. We have more leeway with naming private
  modules \201that is, the ones used by programs or inter)HY(nal)YH( to libraries\202 though
  it's worth coming up with a consis)HY(tent)YH( naming scheme here as well.)EP(

  )0 P(The general guide)HY(line)YH( is to start names of public modules with the
  library's names)HY(pace)YH( name followed by a name describ)HY(ing)YH( the module's
  func)HY(tion)HY(al)HY(ity)YH(. In partic)HY(u)HY(lar)YH(, if a module is dedi)HY(cated)YH( to a single class
  \201or, more gener)HY(ally)YH(, has a single primary entity\202, then it makes sense to
  use its name as the module name's last compo)HY(nent)YH(.)EP(

  )0 P(As a concrete example, consider )SM(libbutl)ES( \201the
  )SM(build2)ES( utility library\202: All its compo)HY(nents)YH( are in the
  )SM(butl)ES( names)HY(pace)YH( so all its module names start with
  )SM(butl.)ES( One of its compo)HY(nents)YH( is the )SM(small_vector)ES(
  class template which resides in its own module called
  )SM(butl.small_vector)ES(. Another compo)HY(nent)YH( is a collec)HY(tion)YH( of string
  parsing util)HY(i)HY(ties)YH( that are grouped into the )SM(butl::string_parser)ES(
  names)HY(pace)YH( with the corre)HY(spond)HY(ing)YH( module called
  )SM(butl.string_parser)ES(.)EP(

  )0 P(When is it a good idea to re-export a module? The two straight)HY(for)HY(ward)YH(
  cases are when we are build)HY(ing)YH( an aggre)HY(gate)YH( module out of submod)HY(ules)YH(, for
  example, )SM(xml)ES( out of )SM(xml.parser)ES( and
  )SM(xml.seri)HY(al)HY(izer)YH()ES(, or when one module extends or super)HY(sedes)YH(
  another, for example, as )SM(std.core)ES( extends
  )SM(std.funda)HY(men)HY(tal)YH()ES(. It is also clear that there is no need to
  re-export a module that we only use in the imple)HY(men)HY(ta)HY(tion)YH(. The case when we
  use a module in our inter)HY(face)YH( is, however, a lot less clear cut.)EP(

  )0 P(But before consid)HY(er)HY(ing)YH( the last case in more detail, let's under)HY(stand)YH( the
  issue with re-export. In other words, why not simply re-export any module we
  import in our inter)HY(face)YH(? In essence, re-export implic)HY(itly)YH( injects another
  module import anywhere our module is imported. If we re-export
  )SM(std.core)ES( then consumers of our module will also auto)HY(mat)HY(i)HY(cally)YH(
  "see" all the names exported by )SM(std.core)ES(. They can then start
  using names from )SM(std)ES( without explic)HY(itly)YH( import)HY(ing)YH(
  )SM(std.core)ES( and every)HY(thing)YH( will compile until one day they no
  longer need to import our module or we no longer need to import
  )SM(std.core)ES(. In a sense, re-export becomes part of our inter)HY(face)YH(
  and it is gener)HY(ally)YH( good design to keep inter)HY(faces)YH( minimal.)EP(

  )0 P(And so, at the outset, the guide)HY(line)YH( is then to only re-export the
  minimum neces)HY(sary)YH(. This, by the way, is the reason why it may make sense to
  divide )SM(std.core)ES( into submod)HY(ules)YH( such as
  )SM(std.core.string)ES(, )SM(std.core.vector)ES(, etc.)EP(

  )0 P(Let's now discuss a few concrete exam)HY(ples)YH( to get a sense of when
  re-export might or might not be appro)HY(pri)HY(ate)YH(. Unfor)HY(tu)HY(nately)YH(, there does not
  seem to be a hard and fast rule and instead one has to rely on their good
  sense of design.)EP(

  )0 P(To start, let's consider a simple module that uses
  )SM(std::string)ES( in its inter)HY(face)YH(:)EP(

  ) 8 32 PR(export module hello;

import std.core;

export namespace hello
{
  void say \201const std::string&\202;
})RP(

  )0 P(Should we re-export )SM(std.core)ES( \201or,
  )SM(std.core.string)ES(\202 in this case? Most likely not. If consumers of
  our module want to use )SM(std::string)ES( in order to pass an argu)HY(ment)YH(
  to our func)HY(tion)YH(, then it is natural to expect them to explic)HY(itly)YH( import the
  neces)HY(sary)YH( module. In a sense, this is anal)HY(o)HY(gous)YH( to scoping: nobody expects
  to be able to use just )SM(string)ES( \201without )SM(std::)ES(\202
  because of )SM(using names)HY(pace)YH( hello;)ES(.)EP(

  )0 P(So it seems that a mere usage of a name in an inter)HY(face)YH( does not
  gener)HY(ally)YH( warrant a re-export. The fact that a consumer may not even use
  this part of our inter)HY(face)YH( further supports this conclu)HY(sion)YH(.)EP(

  )0 P(Let's now consider a more inter)HY(est)HY(ing)YH( case \201inspired by real events\202:)EP(

  ) 9 53 PR(export module small_vector;

import std.core;

template <typename T, std::size_t N>
export class small_vector: public std::vector<T, ...>
{
  ...
};)RP(

  )0 P(Here we have the )SM(small_vector)ES( container imple)HY(mented)YH( in terms
  of )SM(std::vector)ES( by provid)HY(ing)YH( a custom allo)HY(ca)HY(tor)YH( and with most of
  the func)HY(tions)YH( derived as is. Consider now this inno)HY(cent)YH(-looking consumer
  code:)EP(

  ) 6 26 PR(import small_vector;

small_vector<int, 1> a, b;

if \201a == b\202 // Error.
  ...)RP(

  )0 P(We don't refer)HY(ence)YH( )SM(std::vector)ES( directly so presum)HY(ably)YH( we
  shouldn't need to import its module. However, the compar)HY(i)HY(son)YH( won't compile:
  our )SM(small_vector)ES( imple)HY(men)HY(ta)HY(tion)YH( re-uses the compar)HY(i)HY(son)YH(
  oper)HY(a)HY(tors)YH( provided by )SM(std::vector)ES( \201via implicit to-base
  conver)HY(sion)YH(\202 but they aren't visible.)EP(

  )0 P(There is a palpa)HY(ble)YH( differ)HY(ence)YH( between the two cases: the first merely
  uses )SM(std.core)ES( inter)HY(face)YH( while the second is )I(based on)ES(
  and, in a sense, )I(extends)ES( it which feels like a stronger rela)HY(tion)HY(ship)YH(.
  Re-export)HY(ing)YH( )SM(std.core)ES( \201or, better yet,
  )SM(std.core.vector)ES(, should it become avail)HY(able)YH(\202 does not seem
  unrea)HY(son)HY(able)YH(.)EP(

  )0 P(Note also that there is no re-export of headers nor header inclu)HY(sion)YH(
  visi)HY(bil)HY(ity)YH( in the imple)HY(men)HY(ta)HY(tion)YH( units. Specif)HY(i)HY(cally)YH(, in the previ)HY(ous)YH(
  example, if the stan)HY(dard)YH( library is not modu)HY(lar)HY(ized)YH( and we have to use it
  via headers, then the consumers of our )SM(small_vector)ES( will always
  have to explic)HY(itly)YH( include )SM(<vector>)ES(. This suggest that
  modu)HY(lar)HY(iz)HY(ing)YH( a code)HY(base)YH( that still consumes substan)HY(tial)YH( compo)HY(nents)YH( \201like the
  stan)HY(dard)YH( library\202 via headers can incur some devel)HY(op)HY(ment)YH( over)HY(head)YH( compared
  to the old, headers-only approach.)EP(

  )0 3 31 H(7.1.6)WB 67 Sn()WB 33 Sn( Modu)HY(lar)HY(iz)HY(ing)YH( Exist)HY(ing)YH( Code)EH(

  )0 P(The aim of this section is to provide prac)HY(ti)HY(cal)YH( guide)HY(lines)YH( to
  modu)HY(lar)HY(iz)HY(ing)YH( exist)HY(ing)YH( code)HY(bases)YH( as well as support)HY(ing)YH( the dual,
  header/module inter)HY(face)YH( for back)HY(wards)YH(-compat)HY(i)HY(bil)HY(ity)YH(.)EP(

  )0 P(Predictably, a well modu)HY(lar)HY(ized)YH( \201in the general sense\202 set of headers
  makes conver)HY(sion)YH( to C++ modules easier. Inclu)HY(sion)YH( cycles will be
  partic)HY(u)HY(larly)YH( hard to deal with \201C++ modules do not allow circu)HY(lar)YH( inter)HY(face)YH(
  depen)HY(den)HY(cies)YH(\202. Further)HY(more)YH(, as we will see below, if you plan to provide the
  dual header/module inter)HY(face)YH(, then having a one-to-one header to module
  mapping will simplify this task. As a result, it may make sense to spend
  some time clean)HY(ing)YH( and re-orga)HY(niz)HY(ing)YH( your headers prior to attempt)HY(ing)YH(
  modu)HY(lar)HY(iza)HY(tion)YH(.)EP(

  )0 P(Let's first discuss why the modu)HY(lar)HY(iza)HY(tion)YH( approach illus)HY(trated)YH( by the
  follow)HY(ing)YH( example does not gener)HY(ally)YH( work:)EP(

  ) 6 20 PR(export module hello;

export
{
#include "hello.hxx"
})RP(

  )0 P(There are several issue that usually make this unwork)HY(able)YH(. Firstly, the
  header we are trying to export most likely includes other headers. For
  example, our )SM(hello.hxx)ES( may include )SM(<string>)ES( and
  we have already discussed why includ)HY(ing)YH( it in the module purview, let alone
  export)HY(ing)YH( its names, is a bad idea. Secondly, the included header may
  declare more names than what should be exported, for example, some
  imple)HY(men)HY(ta)HY(tion)YH( details. In fact, it may declare names with inter)HY(nal)YH( linkage
  \201uncom)HY(mon)YH( for headers but not impos)HY(si)HY(ble)YH(\202 which are illegal to export.
  Finally, the header may define macros which will no longer be visible to the
  consumers.)EP(

  )0 P(Some)HY(times)YH(, however, this can be the only approach avail)HY(able)YH( \201for example,
  if trying to non-intru)HY(sively)YH( modu)HY(lar)HY(ize)YH( a third-party library\202. It is
  possi)HY(ble)YH( to work around the first issue by )I(pre-includ)HY(ing)YH()ES( outside of
  the module purview headers that should not be exported. Here we rely on the
  fact that the second inclu)HY(sion)YH( of the same header will be ignored. For
  example:)EP(

  ) 8 61 PR(#include <string> // Pre-include to suppress inclusion below.

export module hello;

export
{
#include "hello.hxx"
})RP(

  )0 P(Need)HY(less)YH( to say this approach is very brittle and usually requires that
  you place all the inter-related headers into a single module. As a result,
  its use is best limited to exploratory modu)HY(lar)HY(iza)HY(tion)YH( and early
  proto)HY(typ)HY(ing)YH(.)EP(

  )0 P(When start)HY(ing)YH( modu)HY(lar)HY(iza)HY(tion)YH( of a code)HY(base)YH( there are two deci)HY(sions)YH( we
  have to make at the outset: the level of the C++ modules support we can
  assume and the level of back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( we need to provide.)EP(

  )0 P(The two modules support levels we distin)HY(guish)YH( are just modules and
  modules with the modu)HY(lar)HY(ized)YH( stan)HY(dard)YH( library. The choice we have to make
  then is whether to support the stan)HY(dard)YH( library only as headers, only as
  modules, or both. Note that some compiler/stan)HY(dard)YH( library combi)HY(na)HY(tions)YH( may
  not be usable in some of these modes.)EP(

  )0 P(The possi)HY(ble)YH( back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( levels are )I(modules-only)ES(
  \201consump)HY(tion)YH( via headers is no longer supported\202, )I(modules-or-headers)ES(
  \201consump)HY(tion)YH( either via headers or modules\202, and )I(modules-and-headers)ES(
  \201as the previ)HY(ous)YH( case but with support for consum)HY(ing)YH( a library built with
  modules via headers and vice versa\202.)EP(

  )0 P(What kind of situ)HY(a)HY(tions)YH( call for the last level? We may need to continue
  offer)HY(ing)YH( the library as headers if we have a large number of exist)HY(ing)YH(
  consumers that cannot possi)HY(bly)YH( be all modu)HY(lar)HY(ized)YH( at once \201or even ever\202. So
  the situ)HY(a)HY(tion)YH( we may end up in is a mixture of consumers trying to use the
  same build of our library with some of them using modules and some \235
  headers. The case where we may want to consume a library built with headers
  via modules is not as far fetched as it may seem: the library might have
  been built with an older version of the compiler \201for example, it was
  installed from a distri)HY(bu)HY(tion)YH('s package\202 while the consumer is being built
  with a compiler version that supports modules. Note also that as discussed
  earlier the modules owner)HY(ship)YH( seman)HY(tics)YH( supports both kinds of such
  "cross-usage".)EP(

  )0 P(Gener)HY(ally)YH(, compiler imple)HY(men)HY(ta)HY(tions)YH( do not support mixing inclu)HY(sion)YH( and
  impor)HY(ta)HY(tion)YH( of the same enti)HY(ties)YH( in the same trans)HY(la)HY(tion)YH( unit. This makes
  migra)HY(tion)YH( tricky if you plan to use the modu)HY(lar)HY(ized)YH( stan)HY(dard)YH( library because
  of its perva)HY(sive)YH( use. There are two plau)HY(si)HY(ble)YH( strate)HY(gies)YH( to handling this
  aspect of migra)HY(tion)YH(: If you are plan)HY(ning)YH( to consume the stan)HY(dard)YH( library
  exclu)HY(sively)YH( as modules, then it may make sense to first change your entire
  code)HY(base)YH( to do that. Simply replace all the stan)HY(dard)YH( library header
  inclu)HY(sions)YH( with impor)HY(ta)HY(tion)YH( of the rele)HY(vant)YH( )SM(std.*)ES( modules.)EP(

  )0 P(The alter)HY(na)HY(tive)YH( strat)HY(egy)YH( is to first complete the modu)HY(lar)HY(iza)HY(tion)YH( of our
  entire project \201as discussed next\202 while contin)HY(u)HY(ing)YH( consum)HY(ing)YH( the stan)HY(dard)YH(
  library as headers. Once this is done, we can normally switch to using the
  modu)HY(lar)HY(ized)YH( stan)HY(dard)YH( library quite easily. The reason for waiting until the
  complete modu)HY(lar)HY(iza)HY(tion)YH( is to elim)HY(i)HY(nate)YH( header inclu)HY(sions)YH( between compo)HY(nents)YH(
  which would often result in conflict)HY(ing)YH( styles of the stan)HY(dard)YH( library
  consump)HY(tion)YH(.)EP(

  )0 P(Note also that due to the lack of header re-export and include visi)HY(bil)HY(ity)YH(
  support discussed earlier, it may make perfect sense to only support the
  modu)HY(lar)HY(ized)YH( stan)HY(dard)YH( library when modules are enabled even when provid)HY(ing)YH(
  back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( with headers. In fact, if all the compiler/stan)HY(dard)YH(
  library imple)HY(men)HY(ta)HY(tions)YH( that your project caters to support the modu)HY(lar)HY(ized)YH(
  stan)HY(dard)YH( library, then there is little sense not to impose such a
  restric)HY(tion)YH(.)EP(

  )0 P(The overall strat)HY(egy)YH( for modu)HY(lar)HY(iz)HY(ing)YH( our own compo)HY(nents)YH( is to iden)HY(tify)YH(
  and modu)HY(lar)HY(ize)YH( inter-depen)HY(dent)YH( sets of headers one at a time start)HY(ing)YH( from
  the lower-level compo)HY(nents)YH(. This way any newly modu)HY(lar)HY(ized)YH( set will only
  depend on the already modu)HY(lar)HY(ized)YH( ones. After convert)HY(ing)YH( each set we can
  switch its consumers to using imports keeping our entire project build)HY(able)YH(
  and usable.)EP(

  )0 P(While ideally we would want to be able to modu)HY(lar)HY(ize)YH( just a single
  compo)HY(nent)YH( at a time, this does not seem to work in prac)HY(tice)YH( because we will
  have to continue consum)HY(ing)YH( some of the compo)HY(nents)YH( as headers. Since such
  headers can only be imported out of the module purview, it becomes hard to
  reason \201both for us and often the compiler\202 what is imported/included and
  where. For example, it's not uncom)HY(mon)YH( to end up import)HY(ing)YH( the module in its
  imple)HY(men)HY(ta)HY(tion)YH( unit which is not some)HY(thing)YH( that all the compil)HY(ers)YH( can handle
  grace)HY(fully)YH(.)EP(

  )0 P(Let's now explore how we can provide the various levels of back)HY(wards)YH(
  compat)HY(i)HY(bil)HY(ity)YH( discussed above. Here we rely on two feature test macros to
  deter)HY(mine)YH( the avail)HY(able)YH( modules support level: )SM(__cpp_modules)ES(
  \201modules are avail)HY(able)YH(\202 and )SM(__cpp_lib_modules)ES( \201stan)HY(dard)YH( library
  modules are avail)HY(able)YH(, assumes )SM(__cpp_modules)ES( is also
  defined\202.)EP(

  )0 P(If back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( is not neces)HY(sary)YH( \201the )I(modules-only)ES(
  level\202, then we can use the module inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH( unit
  templates presented earlier and follow the above guide)HY(lines)YH(. If we continue
  consum)HY(ing)YH( the stan)HY(dard)YH( library as headers, then we don't need to change
  anything in this area. If we only want to support the modu)HY(lar)HY(ized)YH( stan)HY(dard)YH(
  library, then we simply replace the stan)HY(dard)YH( library header inclu)HY(sions)YH( with
  the corre)HY(spond)HY(ing)YH( module imports. If we want to support both ways, then we
  can use the follow)HY(ing)YH( templates. The module inter)HY(face)YH( unit template:)EP(

  ) 15 26 PR(// C includes, if any.

#ifndef __cpp_lib_modules
<std includes>
#endif

// Other includes, if any.

export module <name>;

#ifdef __cpp_lib_modules
<std imports>
#endif

<module interface>)RP(

  )0 P(The module imple)HY(men)HY(ta)HY(tion)YH( unit template:)EP(

  ) 17 59 PR(// C includes, if any.

#ifndef __cpp_lib_modules
<std includes>

<extra std includes>
#endif

// Other includes, if any.

module <name>;

#ifdef __cpp_lib_modules
<extra std imports>        // Only additional to interface.
#endif

<module implementation>)RP(

  )0 P(For example:)EP(

  ) 13 48 PR(// hello.mxx \201module interface\202

#ifndef __cpp_lib_modules
#include <string>
#endif

export module hello;

#ifdef __cpp_lib_modules
import std.core;
#endif

export void say_hello \201const std::string& name\202;)RP(

  ) 20 40 PR(// hello.cxx \201module implementation\202

#ifndef __cpp_lib_modules
#include <string>

#include <iostream>
#endif

module hello;

#ifdef __cpp_lib_modules
import std.io;
#endif

using namespace std;

void say_hello \201const string& n\202
{
  cout << "Hello, " << n << '!' << endl;
})RP(

  )0 P(If we need support for symbol export)HY(ing)YH( in this setup \201that is, we are
  build)HY(ing)YH( a library and need to support Windows\202, then we can use the
  )SM(__symex)HY(port)YH()ES( mech)HY(a)HY(nism)YH( discussed earlier, for example:)EP(

  ) 5 60 PR(// hello.mxx \201module interface\202

...

export __symexport void say_hello \201const std::string& name\202;)RP(

  )0 P(The consumer code in the )I(modules-only)ES( setup is straight)HY(for)HY(ward)YH(:
  they simply import the desired modules.)EP(

  )0 P(To support consump)HY(tion)YH( via headers when modules are unavail)HY(able)YH( \201the
  )I(modules-or-headers)ES( level\202 we can use the follow)HY(ing)YH( setup. Here we
  also support the dual header/modules consump)HY(tion)YH( for the stan)HY(dard)YH( library
  \201if this is not required, replace )SM(#ifndef __cpp_lib_modules)ES(
  with )SM(#ifndef __cpp_modules)ES( and remove )SM(#ifdef
  __cpp_lib_modules)ES(\202. The module inter)HY(face)YH( unit template:)EP(

  ) 21 26 PR(#ifndef __cpp_modules
#pragma once
#endif

// C includes, if any.

#ifndef __cpp_lib_modules
<std includes>
#endif

// Other includes, if any.

#ifdef __cpp_modules
export module <name>;

#ifdef __cpp_lib_modules
<std imports>
#endif
#endif

<module interface>)RP(

  )0 P(The module imple)HY(men)HY(ta)HY(tion)YH( unit template:)EP(

  ) 23 59 PR(#ifndef __cpp_modules
#include <module interface file>
#endif

// C includes, if any.

#ifndef __cpp_lib_modules
<std includes>

<extra std includes>
#endif

// Other includes, if any

#ifdef __cpp_modules
module <name>;

#ifdef __cpp_lib_modules
<extra std imports>        // Only additional to interface.
#endif
#endif

<module implementation>)RP(

  )0 P(Notice the need to repeat )SM(<std includes>)ES( in the
  imple)HY(men)HY(ta)HY(tion)YH( file due to the lack of include visi)HY(bil)HY(ity)YH( discussed above.
  This is neces)HY(sary)YH( when modules are enabled but the stan)HY(dard)YH( library is not
  modu)HY(lar)HY(ized)YH( since in this case the imple)HY(men)HY(ta)HY(tion)YH( does not "see" any of the
  headers included in the inter)HY(face)YH(.)EP(

  )0 P(Besides these templates we will most likely also need an export header
  that appro)HY(pri)HY(ately)YH( defines a module export macro depend)HY(ing)YH( on whether
  modules are used or not. This is also the place where we can handle symbol
  export)HY(ing)YH(. For example, here is what it could look like for our
  )SM(libhello)ES( library:)EP(

  ) 25 52 PR(// export.hxx \201module and symbol export\202

#pragma once

#ifdef __cpp_modules
#  define LIBHELLO_MODEXPORT export
#else
#  define LIBHELLO_MODEXPORT
#endif

#if   defined\201LIBHELLO_SHARED_BUILD\202
#  ifdef _WIN32
#    define LIBHELLO_SYMEXPORT __declspec\201dllexport\202
#  else
#    define LIBHELLO_SYMEXPORT
#  endif
#elif defined\201LIBHELLO_SHARED\202
#  ifdef _WIN32
#    define LIBHELLO_SYMEXPORT __declspec\201dllimport\202
#  else
#    define LIBHELLO_SYMEXPORT
#  endif
#else
#  define LIBHELLO_SYMEXPORT
#endif)RP(

  )0 P(And this is the module that uses it and provides the dual header/module
  support:)EP(

  ) 24 56 PR(// hello.mxx \201module interface\202

#ifndef __cpp_modules
#pragma once
#endif

#ifndef __cpp_lib_modules
#include <string>
#endif

#ifdef __cpp_modules
export module hello;

#ifdef __cpp_lib_modules
import std.core;
#endif
#endif

#include <libhello/export.hxx>

LIBHELLO_MODEXPORT namespace hello
{
  LIBHELLO_SYMEXPORT void say \201const std::string& name\202;
})RP(

  ) 29 42 PR(// hello.cxx \201module implementation\202

#ifndef __cpp_modules
#include <libhello/hello.mxx>
#endif

#ifndef __cpp_lib_modules
#include <string>

#include <iostream>
#endif

#ifdef __cpp_modules
module hello;

#ifdef __cpp_lib_modules
import std.io;
#endif
#endif

using namespace std;

namespace hello
{
  void say \201const string& n\202
  {
    cout << "Hello, " << n << '!' << endl;
  }
})RP(

  )0 P(The consumer code in the )I(modules-or-headers)ES( setup has to use
  either inclu)HY(sion)YH( or impor)HY(ta)HY(tion)YH( depend)HY(ing)YH( on the modules support
  avail)HY(abil)HY(ity)YH(, for example:)EP(

  ) 5 29 PR(#ifdef __cpp_modules
import hello;
#else
#include <libhello/hello.mxx>
#endif)RP(

  )0 P(Predictably, the final back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH( level
  \201)I(modules-and-headers)ES(\202 is the most onerous to support. Here exist)HY(ing)YH(
  consumers have to continue working with the modu)HY(lar)HY(ized)YH( version of our
  library which means we have to retain all the exist)HY(ing)YH( header files. We also
  cannot assume that just because modules are avail)HY(able)YH( they are used \201a
  consumer may still prefer headers\202, which means we cannot rely on \201only\202 the
  )SM(__cpp_modules)ES( and )SM(__cpp_lib_modules)ES( macros to make
  the deci)HY(sions)YH(.)EP(

  )0 P(One way to arrange this is to retain the headers and adjust them
  accord)HY(ing)YH( to the )I(modules-or-headers)ES( template but with one impor)HY(tant)YH(
  differ)HY(ence)YH(: instead of using the stan)HY(dard)YH( module macros we use our custom
  ones \201and we can also have uncon)HY(di)HY(tional)YH( )SM(#pragma once)ES(\202. For
  example:)EP(

  ) 22 56 PR(// hello.hxx \201module header\202

#pragma once

#ifndef LIBHELLO_LIB_MODULES
#include <string>
#endif

#ifdef LIBHELLO_MODULES
export module hello;

#ifdef LIBHELLO_LIB_MODULES
import std.core;
#endif
#endif

#include <libhello/export.hxx>

LIBHELLO_MODEXPORT namespace hello
{
  LIBHELLO_SYMEXPORT void say \201const std::string& name\202;
})RP(

  )0 P(Now if this header is included \201for example, by an exist)HY(ing)YH( consumer\202
  then none of the )SM(LIBHELLO_*MODULES)ES( macros will be defined and
  the header will act as, well, a plain old header. Note that we will also
  need to make the equiv)HY(a)HY(lent)YH( change in the export header.)EP(

  )0 P(We also provide the module inter)HY(face)YH( files which appro)HY(pri)HY(ately)YH( define the
  two custom macros and then simply includes the corre)HY(spond)HY(ing)YH( headers:)EP(

  ) 11 31 PR(// hello.mxx \201module interface\202

#ifdef __cpp_modules
#define LIBHELLO_MODULES
#endif

#ifdef __cpp_lib_modules
#define LIBHELLO_LIB_MODULES
#endif

#include <libhello/hello.hxx>)RP(

  )0 P(The module imple)HY(men)HY(ta)HY(tion)YH( unit can remain unchanged. In partic)HY(u)HY(lar)YH(, we
  continue includ)HY(ing)YH( )SM(hello.mxx)ES( if modules support is unavail)HY(able)YH(.
  However, if you find the use of differ)HY(ent)YH( macros in the header and source
  files confus)HY(ing)YH(, then instead it can be adjusted as follows \201note also that
  now we are includ)HY(ing)YH( )SM(hello.hxx)ES(\202:)EP(

  ) 29 36 PR(// hello.cxx \201module implementation\202

#ifdef __cpp_modules
#define LIBHELLO_MODULES
#endif

#ifdef __cpp_lib_modules
#define LIBHELLO_LIB_MODULES
#endif

#ifndef LIBHELLO_MODULES
#include <libhello/hello.hxx>
#endif

#ifndef LIBHELLO_LIB_MODULES
#include <string>

#include <iostream>
#endif

#ifdef LIBHELLO_MODULES
module hello;

#ifdef LIBHELLO_LIB_MODULES
import std.io;
#endif
#endif

...)RP(

  )0 P(In this case it may also make sense to factor the
  )SM(LIBHELLO_*MODULES)ES( macro defi)HY(ni)HY(tions)YH( into a common header.)EP(

  )0 P(In the )I(modules-and-headers)ES( setup the exist)HY(ing)YH( consumers that would
  like to continue using headers don't require any changes. And for those that
  would like to use modules if avail)HY(able)YH( the arrange)HY(ment)YH( is the same as for
  the )I(modules-or-headers)ES( compat)HY(i)HY(bil)HY(ity)YH( level.)EP(

  )0 P(If our module needs to "export" macros then the recom)HY(mended)YH( approach is
  to simply provide an addi)HY(tional)YH( header that the consumer includes. While it
  might be tempt)HY(ing)YH( to also wrap the module import into this header, some may
  prefer to explic)HY(itly)YH( import the module and include the header, espe)HY(cially)YH( if
  the macros may not be needed by all consumers. This way we can also keep the
  header macro-only which means it can be included freely, in or out of module
  purviews.)EP(

  )0 1 32 H(8)WB 68 Sn()WB 34 Sn( )SM(in)ES( Module)EH(

  )0 P(The )SM(in)ES( build system module provides support for
  )SM(.in)ES( \201input\202 file prepro)HY(cess)HY(ing)YH(. Specif)HY(i)HY(cally)YH(, the
  )SM(.in)ES( file can contain a number of )I(substi)HY(tu)HY(tions)YH()ES( \235
  build system vari)HY(able)YH( names enclosed with the substi)HY(tu)HY(tion)YH( symbol
  \201)SM($)ES( by default\202 \235 which are replaced with the
  corre)HY(spond)HY(ing)YH( vari)HY(able)YH( values to produce the output file. For example:)EP(

  ) 3 18 PR(# build/root.build

using in)RP(

  ) 3 29 PR(// config.hxx.in

#define TARGET "$cxx.target$")RP(

  ) 3 23 PR(# buildfile

hxx{config}: in{config})RP(

  )0 P(The )SM(in)ES( module defines the )SM(in{})ES( target type and
  imple)HY(ments)YH( the )SM(in)ES( build system rule.)EP(

  )0 P(While we can specify the )SM(.in)ES( exten)HY(sion)YH( explic)HY(itly)YH(, it is not
  neces)HY(sary)YH( because the )SM(in{})ES( target type imple)HY(ments)YH(
  )I(target-depen)HY(dent)YH( search)ES( by taking into account the target it is a
  prereq)HY(ui)HY(site)YH( of. In other words, the follow)HY(ing)YH( depen)HY(dency)YH( decla)HY(ra)HY(tions)YH(
  produce the same result:)EP(

  ) 3 34 PR(hxx{config}:     in{config}
hxx{config.hxx}: in{config}
hxx{config.hxx}: in{config.hxx.in})RP(

  )0 P(By default the )SM(in)ES( rule uses )SM($)ES( as the
  substi)HY(tu)HY(tion)YH( symbol. This can be changed using the )SM(in.symbol)ES(
  vari)HY(able)YH(. For example:)EP(

  ) 3 29 PR(// data.cxx.in

const char data[] = "@data@";)RP(

  ) 7 24 PR(# buildfile

cxx{data}: in{data}
{
  in.symbol = '@'
  data = 'Hello, World!'
})RP(

  )0 P(Note that the substi)HY(tu)HY(tion)YH( symbol must be a single char)HY(ac)HY(ter)YH(.)EP(

  )0 P(The default substi)HY(tu)HY(tion)YH( mode is strict. In this mode every substi)HY(tu)HY(tion)YH(
  symbol is expected to start a substi)HY(tu)HY(tion)YH( with unre)HY(solved)YH( \201to a vari)HY(able)YH(
  value\202 names treated as errors. The double substi)HY(tu)HY(tion)YH( symbol \201for example,
  )SM($$)ES(\202 serves as an escape sequence.)EP(

  )0 P(The substi)HY(tu)HY(tion)YH( mode can be relaxed using the
  )SM(in.substi)HY(tu)HY(tion)YH()ES( vari)HY(able)YH(. Its valid values are
  )SM(strict)ES( \201default\202 and )SM(lax)ES(. In the lax mode a pair
  of substi)HY(tu)HY(tion)YH( symbols is only treated as a substi)HY(tu)HY(tion)YH( if what's between
  them looks like a build system vari)HY(able)YH( name \201that is, it doesn't contain
  spaces, etc\202. Every)HY(thing)YH( else, includ)HY(ing)YH( unter)HY(mi)HY(nated)YH( substi)HY(tu)HY(tion)YH( symbols,
  is copied as is. Note also that in this mode the double substi)HY(tu)HY(tion)YH( symbol
  is not treated as an escape sequence.)EP(

  )0 P(The lax mode is mostly useful when trying to reuse exist)HY(ing)YH(
  )SM(.in)ES( files from other build systems, such as
  )SM(auto)HY(conf)YH()ES(. Note, however, that the lax mode is still stricter
  than the )SM(auto)HY(conf)YH()ES('s seman)HY(tics)YH( which also leaves unre)HY(solved)YH(
  substi)HY(tu)HY(tions)YH( as is. For example:)EP(

  ) 10 40 PR(# buildfile

h{config}: in{config} # config.h.in
{
  in.symbol = '@'
  in.substitution = lax

  CMAKE_SYSTEM_NAME = $c.target.system
  CMAKE_SYSTEM_PROCESSOR = $c.target.cpu
})RP(

  )0 P(The )SM(in)ES( rule tracks changes to the input file as well as the
  substi)HY(tuted)YH( vari)HY(able)YH( values and auto)HY(mat)HY(i)HY(cally)YH( regen)HY(er)HY(ates)YH( the output file if
  any were detected. Substi)HY(tuted)YH( vari)HY(able)YH( values are looked up start)HY(ing)YH( from
  the target-specific vari)HY(ables)YH(. Typed vari)HY(able)YH( values are converted to string
  using the corre)HY(spond)HY(ing)YH( )SM(builtin.string\201\202)ES( func)HY(tion)YH( over)HY(load)YH(
  before substi)HY(tu)HY(tion)YH(.)EP(

  )0 P(A number of other build system modules, for example, )0 24 1 A()SM(version)ES()24 0 TN TL()Ec /AF f D( and )0 35 1 A()SM(bash)ES()35 0 TN TL()Ec /AF f D(, are based on the )SM(in)ES(
  module and provide extended func)HY(tion)HY(al)HY(ity)YH(. The )SM(in)ES( prepro)HY(cess)HY(ing)YH(
  rule matches any )SM(file{})ES(-based target that has the corre)HY(spond)HY(ing)YH(
  )SM(in{})ES( prereq)HY(ui)HY(site)YH( provided none of the extended rules
  match.)EP(

  )0 1 33 H(9)WB 69 Sn()WB 35 Sn( )SM(bash)ES( Module)EH(

  )0 P(The )SM(bash)ES( build system module provides modu)HY(lar)HY(iza)HY(tion)YH( support
  for )SM(bash)ES( scripts. It is based on the )0 34 1 A()SM(in)ES()34 0 TN TL()Ec /AF f D( build system module and extends its
  prepro)HY(cess)HY(ing)YH( rule with support for )I(import substi)HY(tu)HY(tions)YH()ES( in the
  )SM(@import\240<module>@)ES( form. During prepro)HY(cess)HY(ing)YH(, such
  imports are replaced with suit)HY(able)YH( )SM(source)ES( builtin calls. For
  example:)EP(

  ) 3 18 PR(# build/root.build

using bash)RP(

  ) 6 22 PR(# hello/say-hello.bash

function say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  ) 7 24 PR(#!/usr/bin/env bash

# hello/hello.in

@import hello/say-hello@

say_hello 'World')RP(

  ) 3 37 PR(# hello/buildfile

exe{hello}: in{hello} bash{say-hello})RP(

  )0 P(By default the )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule uses the lax
  substi)HY(tu)HY(tion)YH( mode and )SM(@)ES( as the substi)HY(tu)HY(tion)YH( symbol but this can
  be over)HY(rid)HY(den)YH( using the stan)HY(dard)YH( )SM(in)ES( module mech)HY(a)HY(nisms)YH(.)EP(

  )0 P(In the above example, )SM(say-hello.bash)ES( is a )I(module)ES(. By
  conven)HY(tion)YH(, )SM(bash)ES( modules have the )SM(.bash)ES( exten)HY(sion)YH(
  and we use the )SM(bash{})ES( target type \201defined by the
  )SM(bash)ES( build system module\202 to refer to them in build)HY(files)YH(.)EP(

  )0 P(The )SM(say-hello.bash)ES( module is )I(imported)ES( by the
  )SM(hello)ES( script with the
  )SM(@import\240hello/say-hello@)ES( substi)HY(tu)HY(tion)YH(. The )I(import
  path)ES( \201)SM(hello/say-hello)ES( in our case\202 is a rela)HY(tive)YH( path to
  the module file within the project. Its first compo)HY(nent)YH( \201)SM(hello)ES(
  in our case\202 must be the project base name and the )SM(.bash)ES( module
  exten)HY(sion)YH( can be omitted. The constraint placed on the
  first compo)HY(nent)YH( of the import path is required to imple)HY(ment)YH( impor)HY(ta)HY(tion)YH( of
  installed modules, as discussed below.)EP(

  )0 P(During prepro)HY(cess)HY(ing)YH(, the import substi)HY(tu)HY(tion)YH( will be replaced with a
  )SM(source)ES( builtin call and the import path resolved to one of the
  )SM(bash{})ES( prereq)HY(ui)HY(sites)YH( from the script's depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(.
  The actual module path used in )SM(source)ES( depends on whether the
  script is prepro)HY(cessed)YH( for instal)HY(la)HY(tion)YH(. If it's not \201devel)HY(op)HY(ment)YH( build\202,
  then the abso)HY(lute)YH( path to the module file is used. Other)HY(wise)YH(, a path
  rela)HY(tive)YH( to the sourc)HY(ing)YH( script's direc)HY(tory)YH( is derived. This allows
  installed scripts and their modules to be moved around.)EP(

  )BR(
  )0 P(The deriva)HY(tion)YH( of the sourc)HY(ing)YH( script's direc)HY(tory)YH( works even if the
  script is executed via a symbolic link from another direc)HY(tory)YH(. Imple)HY(ment)HY(ing)YH(
  this, however, requires )SM(read)HY(link)YH(\2011\202)ES( with support for the
  )SM(-f)ES( option. One notable plat)HY(form)YH( that does not provide such
  )SM(read)HY(link)YH(\2011\202)ES( by default is Mac OS. The script, however, can
  provide a suit)HY(able)YH( imple)HY(men)HY(ta)HY(tion)YH( as a func)HY(tion)YH(. See the )SM(bash)ES(
  module tests for a sample imple)HY(men)HY(ta)HY(tion)YH( of such a func)HY(tion)YH(.)EP(
  )BR(

  )0 P(By default, )SM(bash)ES( modules are installed into a subdi)HY(rec)HY(tory)YH(
  of the )SM(bin/)ES( instal)HY(la)HY(tion)YH( direc)HY(tory)YH( named as the project base
  name. For instance, in the above example, the script will be installed as
  )SM(bin/hello)ES( and the module as
  )SM(bin/hello/say-hello.bash)ES( with the script sourc)HY(ing)YH( the module
  rela)HY(tive)YH( to the )SM(bin/)ES( direc)HY(tory)YH(. Note that currently it is
  assumed the script and all its modules are installed into the same
  )SM(bin/)ES( direc)HY(tory)YH(.)EP(

  )0 P(Natu)HY(rally)YH(, modules can import other modules and modules can be pack)HY(aged)YH(
  into )I(module libraries)ES( and imported using the stan)HY(dard)YH( build system
  import mech)HY(a)HY(nism)YH(. For example, we could factor the
  )SM(say-hello.bash)ES( module into a sepa)HY(rate)YH( )SM(libhello)ES(
  project:)EP(

  ) 8 40 PR(# build/export.build

$out_root/
{
  include libhello/
}

export $src_root/libhello/$import.target)RP(

  ) 6 27 PR(# libhello/say-hello.bash

function hello_say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  )0 P(And then import it in a module of our )SM(hello)ES( project:)EP(

  ) 8 27 PR(# hello/hello-world.bash.in

@import libhello/say-hello@

function hello_world \201\202
{
  hello_say_hello 'World'
})RP(

  ) 7 26 PR(#!/usr/bin/env bash

# hello/hello.in

@import hello/hello-world@

hello_world)RP(

  ) 6 52 PR(# hello/buildfile

import mods = libhello%bash{say-hello}

exe{hello}:        in{hello}       bash{hello-world}
bash{hello-world}: in{hello-world} $mods)RP(

  )0 P(The )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule also supports impor)HY(ta)HY(tion)YH( of
  installed modules by search)HY(ing)YH( in the )SM(PATH)ES( envi)HY(ron)HY(ment)YH(
  vari)HY(able)YH(.)EP(

  )0 P(By conven)HY(tion)YH(, )SM(bash)ES( module libraries should use the
  )SM(lib)ES( name prefix, for example, )SM(libhello)ES(. If there
  is also a native library \201that is, one written in C/C++\202 that provides the
  same func)HY(tion)HY(al)HY(ity)YH( \201or the )SM(bash)ES( library is a language binding
  for said library\202, then it is custom)HY(ary)YH( to add the )SM(.bash)ES(
  exten)HY(sion)YH( to the )SM(bash)ES( library name, for example,
  )SM(libhello.bash)ES(. Note that in this case the project base name is
  )SM(libhello)ES(.)EP(

  )0 P(Modules can be )I(private)ES( or )I(public)ES(. Private modules are
  imple)HY(men)HY(ta)HY(tion)YH( details of a specific project and are not expected to be
  imported from other projects. The )SM(hello/hello-world.bash.in)ES(
  module above is an example of a private module. Public modules are meant to
  be used by other projects and are normally pack)HY(aged)YH( into libraries, like the
  )SM(libhello/say-hello.bash)ES( module above.)EP(

  )0 P(Public modules must take care to avoid name clashes. Since
  )SM(bash)ES( does not have a notion of names)HY(paces)YH(, the recom)HY(mended)YH( way
  is to prefix all module func)HY(tions)YH( \201and global vari)HY(ables)YH(, if any\202 with the
  library name \201without the )SM(lib)ES( prefix\202, like in the
  )SM(libhello/say-hello.bash)ES( module above.)EP(

  )0 P(While using such deco)HY(rated)YH( func)HY(tion)YH( names can be unwieldy, it is
  rela)HY(tively)YH( easy to create wrap)HY(pers)YH( with shorter names and use those instead.
  For example:)EP(

  ) 3 47 PR(@import libhello/say-hello@

function say_hello \201\202 { hello_say_hello "$@"; })RP(

  )0 P(A module should normally also prevent itself from being sourced multi)HY(ple)YH(
  times. The recom)HY(mended)YH( way to achieve this is to begin the module with a
  )I(source guard)ES(. For example:)EP(

  ) 12 31 PR(# libhello/say-hello.bash

if [ "$hello_say_hello" ]; then
  return 0
else
  hello_say_hello=true
fi

function hello_say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  )0 P(The )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule matches )SM(exe{})ES(
  targets that have the corre)HY(spond)HY(ing)YH( )SM(in{})ES( and one or more
  )SM(bash{})ES( prereq)HY(ui)HY(sites)YH( as well as )SM(bash{})ES( targets
  that have the corre)HY(spond)HY(ing)YH( )SM(in{})ES( prereq)HY(ui)HY(site)YH( \201if you need to
  prepro)HY(cess)YH( a script that does not depend on any modules, you can use the
  )SM(in)ES( module's rule\202.)EP(

)BR(

)WB NL
/TE t D NP /OU t D TU PM 1 eq and{/Pn () D showpage}if end restore
